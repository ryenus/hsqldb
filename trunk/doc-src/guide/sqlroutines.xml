<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="sqlroutines-chapt"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="sqlroutines-title">SQL-Invoked Routines</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <pubdate>$Date$</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2010 Fred Toussi. Permission is granted to distribute
      this document without any alteration under the terms of the HSQLDB
      license. Additional permission is granted to the HSQL Development Group
      to distribute this document with or without alterations under the terms
      of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <para>SQL-invoked routines are functions and procedures called from SQL.
  HyperSQL 2.0 supports routines conforming to two parts of the SQL Standard.
  Routines written in the SQL language are supported in conformance to SQL/PSM
  (Persistent Stored Modules) specification. Routines written in Java are
  supported in conformance to SQL/JRT specification. In addition, HyperSQL’s
  previous non-standard support for calling Java routines without prior method
  definition is retained and enhanced in the latest version by extending the
  SQL/JRT specification.</para>

  <para>HyperSQL also supports user defined aggregate functions written in the
  SQL language. This feature is an extension to the SQL Standard.</para>

  <para>SQL-invoked routines are schema objects. Naming and referencing
  follows conventions common to all schema objects. The same routine name can
  be defined in two different schemas and used with schema-qualified
  references.</para>

  <para>A routine is either a procedure or a function.</para>

  <para>A function:</para>

  <itemizedlist>
    <listitem>
      <para>is defined with CREATE FUNCTION</para>
    </listitem>

    <listitem>
      <para>always returns a value</para>
    </listitem>

    <listitem>
      <para>does not modify the data in the database</para>
    </listitem>

    <listitem>
      <para>is called as part of an SQL statement</para>
    </listitem>

    <listitem>
      <para>can have parameters</para>
    </listitem>

    <listitem>
      <para>can be polymorphic</para>
    </listitem>
  </itemizedlist>

  <para>A procedure:</para>

  <itemizedlist>
    <listitem>
      <para>is defined with CREATE PROCEDURE</para>
    </listitem>

    <listitem>
      <para>can return one or more values</para>
    </listitem>

    <listitem>
      <para>can modify the data in the database</para>
    </listitem>

    <listitem>
      <para>is called separately, using the CALL statement</para>
    </listitem>

    <listitem>
      <para>can have parameters</para>
    </listitem>

    <listitem>
      <para>can be polymorphic</para>
    </listitem>
  </itemizedlist>

  <para>Definition of routine signature and characteristics, name resolution
  and invocation are all implemented uniformly for routines written in SQL or
  Java.</para>

  <section>
    <title>SQL Language Routines (PSM)</title>

    <para>The PSM (Persistent Stored Module) specification extends the SQL
    language to allow definition of both SQL Function and SQL procedure bodies
    with the same structure and the same control statements (such as
    conditional and loop statements) with minor exceptions.</para>

    <para>The routine body is a SQL statement. In its simplest form, the body
    is a single SQL statement. A simple example of a function is given
    below:</para>

    <programlisting>CREATE FUNCTION an_hour_before (t TIMESTAMP)
    RETURNS TIMESTAMP
    RETURN t - 1 HOUR

</programlisting>

    <para>An example of the use of the function in an SQL statement is given
    below:</para>

    <programlisting>SELECT an_hour_before(event_timestamp) AS notification_timestamp, event_name FROM events;</programlisting>

    <para>A simple example of a procedure is given below:</para>

    <programlisting>CREATE PROCEDURE new_customer(firstname VARCHAR(50), lastname VARCHAR(50))
    MODIFIES SQL DATA
    INSERT INTO CUSTOMERS VALUES (DEFAULT, firstname, lastname, CURRENT_TIMESTAMP)

</programlisting>

    <para>The procedure inserts a row into an existing table with the
    definition given below:</para>

    <programlisting>CREATE TABLE customers(id INTEGER GENERATED BY DEFAULT AS IDENTITY, firstname VARCHAR(50), lastname VARCHAR(50), added TIMESTAMP);</programlisting>

    <para>An example of the use of the procedure is given below:</para>

    <programlisting>CALL new_customer('JOHN', 'SMITH');</programlisting>

    <para>The routine body is often a compound statement. A compound statement
    can contain one or more SQL statements, which can include control
    statements, as well as nested compound statements.</para>

    <section>
      <title>Routine Statements</title>

      <para>The following SQL Statements can be used only in routines.</para>

      <simpara><literal>&lt;handler declaration&gt;</literal></simpara>

      <simpara><literal>&lt;assignment statement&gt;</literal></simpara>

      <simpara><literal>&lt;compound statement&gt;</literal></simpara>

      <simpara><literal>&lt;case statement&gt;</literal></simpara>

      <simpara><literal>&lt;if statement&gt;</literal></simpara>

      <simpara><literal>&lt;while statement&gt;</literal></simpara>

      <simpara><literal>&lt;repeat statement&gt;</literal></simpara>

      <simpara><literal>&lt;for statement&gt;</literal></simpara>

      <simpara><literal>&lt;loop statement&gt;</literal></simpara>

      <simpara><literal>&lt;iterate statement</literal></simpara>

      <simpara><literal>&lt;leave statement&gt;</literal></simpara>

      <simpara><literal>&lt;signal statement&gt;</literal></simpara>

      <simpara><literal>&lt;resignal statement&gt;</literal></simpara>

      <simpara><literal>&lt;return statement&gt;</literal></simpara>

      <simpara><literal>&lt;select statement: single
      row&gt;</literal></simpara>

      <para>The following SQL Statements can be used in procedures but not in
      functions.</para>

      <para><literal>&lt;call statement&gt;</literal></para>

      <para><literal>&lt;delete statement&gt;</literal></para>

      <para><literal>&lt;insert statement&gt;</literal></para>

      <para><literal>&lt;update statement&gt;</literal></para>

      <para><literal>&lt;merge statement&gt;</literal></para>

      <para>As shown in the examples below, the formal parameters and the
      variables of the routine can be used in statements, similar to the way a
      column reference is used.</para>
    </section>

    <section>
      <title>Compound Statement</title>

      <para>A compound statement is enclosed in a BEGIN / END block with
      optional labels. It can contain one or more <literal>&lt;SQL variable
      declaration&gt;</literal> or <literal>&lt;handler
      declaration&gt;</literal> before at least one SQL statement. The BNF is
      given below:</para>

      <simpara><literal>&lt;compound statement&gt; ::= [ &lt;beginning
      label&gt; &lt;colon&gt; ] BEGIN [[NOT] ATOMIC] [{&lt;SQL variable
      declaration&gt; &lt;semicolon&gt;} ...] [{&lt;handler declaration&gt;
      &lt;semicolon&gt;}...] {&lt;SQL procedure statement&gt;
      &lt;semicolon&gt;} ... END [ &lt;ending label&gt; ]</literal></simpara>

      <para>An example of a simple compound statement body is given below. It
      performs the common task of inserting related data into two table. The
      IDENTITY value that is automatically inserted in the first table is
      retrieved using the IDENTITY() function and inserted into the second
      table.</para>

      <programlisting>CREATE PROCEDURE new_customer(firstname VARCHAR(50), lastname  VARCHAR(50), address VARCHAR(100))
    MODIFIES SQL DATA
    BEGIN ATOMIC
    INSERT INTO customers VALUES (DEFAULT, firstname, lastname, CURRENT_TIMESTAMP);
    INSERT INTO addresses VALUES (DEFAULT, IDENTITY(), address);
    END

</programlisting>
    </section>

    <section>
      <title>Variables</title>

      <para>A <literal>&lt;variable declaration&gt;</literal> defines the name
      and data type of the variable and, optionally, its default value. In the
      next example, a variable is used to hold the IDENTITY value. In
      addition, the formal parameters of the procedure are identified as input
      parameters with the use of the optional IN keyword. This procedure does
      exactly the same job as the procedure in the previous example.</para>

      <programlisting>CREATE PROCEDURE new_customer(IN firstname VARCHAR(50), IN lastname VARCHAR(50), IN address VARCHAR(100))
    MODIFIES SQL DATA
    BEGIN ATOMIC
    DECLARE temp_id INTEGER;
    INSERT INTO CUSTOMERS VALUES (DEFAULT, firstname, lastname, CURRENT_TIMESTAMP);
    SET temp_id = IDENTITY();
    INSERT INTO ADDRESSES VALUES (DEFAULT, temp_id, address);
    END

</programlisting>

      <para>The BNF for variable declaration is given below:</para>

      <simpara><literal>&lt;SQL variable declaration&gt; ::= DECLARE
      &lt;variable name list&gt; &lt;data type&gt; [DEFAULT &lt;default
      value&gt;]</literal></simpara>

      <simpara><literal>&lt;variable name list&gt; ::= &lt;variable name&gt; [
      { &lt;comma&gt; &lt;variable name&gt; }... ]</literal></simpara>

      <para>Examples of variable declaration are given below. Note that in a
      DECLARE statement with multiple comma-separated variable names, the type
      and the default value applies to all the variables in the list:</para>

      <programlisting>    BEGIN ATOMIC
    DECLARE temp_zero DATE;
    DECLARE temp_one, temp_two INTEGER DEFAULT 2;
    DECLARE temp_three VARCHAR(20) DEFAULT 'no name';
    -- more statements ...
    SET temp_zero = DATE '2010-03-18';
    SET temp_two = 5;
    -- more statements ...
    END</programlisting>
    </section>

    <section>
      <title>Handlers</title>

      <para>A <literal>&lt;handler declaration&gt;</literal> defines the
      course of action when an exception or warning is raised during the
      execution of the compound statement. A compound statement may have one
      or more handler declarations. These handlers become active when code
      execution enters the compound statement block and remain active in any
      sub-block and statement within the block. The handlers become inactive
      when code execution leaves the block.</para>

      <para>In the previous example, if an exception is thrown during the
      execution of either SQL statement, the execution of the compound
      statement is terminated and the exception is propagated and thrown by
      the CALL statement for the procedure. A handler declaration can resolve
      the thrown exception within the compound statement without propagating
      it, and allow the execution of the &lt;compound statement&gt; to
      continue.</para>

      <para>In the example below, the UNDO handler declaration catches any
      exception that is thrown during the execution of the compound statement
      inside the BEGIN / END block. As it is an UNDO handler, all the changes
      to data performed within the compound statement (BEGIN / END) block are
      rolled back. The procedure then returns without throwing an
      exception.</para>

      <programlisting>CREATE PROCEDURE NEW_CUSTOMER(IN firstname VARCHAR(50), IN lastname VARCHAR(50), IN address VARCHAR(100))
    MODIFIES SQL DATA
    label_one: BEGIN ATOMIC
    DECLARE temp_id INTEGER;
    DECLARE UNDO HANDLER FOR SQLEXCEPTION LEAVE label_one;
    INSERT INTO CUSTOMERS VALUES (DEFAULT, firstname, lastname, CURRENT_TIMESTAMP);
    SET temp_id = IDENTITY();
    INSERT INTO ADDRESSES VALUES (DEFAULT, temp_id, address);
    END

</programlisting>

      <para>Other types of hander are CONTINUE and EXIT handlers. A CONTINUE
      handler ignores any exception and proceeds to the next statement in the
      block. An EXIT handler terminates execution without undoing the data
      changes performed by the previous (successful) statements.</para>

      <para>The conditions can be general conditions, or specific conditions.
      Among general conditions that can be specified, SQLEXCEPTION covers all
      exceptions, SQLWARNING covers all warnings, while NOT FOUND covers the
      not-found condition, which is raised when a DELETE, UPDATE, INSERT or
      MERGE statement completes without actually affecting any row.
      Alternatively, one or more specific conditions can be specified
      (separated with commas) which apply to specific exceptions or warnings
      or classes or exceptions or warnings. A specific condition is specified
      with <literal>SQLSTATE &lt;value&gt;</literal>, for example SQLSTATE
      'W_01003' specifies the warning raised after a SQL statement is executed
      which contains an aggregate function which encounters a null value
      during execution. An example is given below which activates the handler
      when either of the two warnings is raised:</para>

      <programlisting>DECLARE UNDO HANDLER FOR SQLSTATE 'W_01003', 'W_01004' LEAVE label_one;</programlisting>

      <para>The BNF for <literal>&lt;handler declaration&gt;</literal> is
      given below:</para>

      <simpara><literal>&lt;handler declaration&gt; ::= DECLARE {UNDO |
      CONTINUE | EXIT} HANDLER FOR {SQLEXCEPTION | SQLWARNING | NOT FOUND} | {
      SQL_STATE &lt;state value&gt; [, ...]} [&lt;SQL procedure
      statement&gt;];</literal></simpara>

      <para>A handler declaration may specify an SQL procedure statement to be
      performed when the handler is activated. When an exception occurs, the
      example below performs the UNDO as in the previous example, then inserts
      the (invalid) data into a separate table.</para>

      <programlisting>DECLARE UNDO HANDLER FOR SQLEXCEPTION
    INSERT INTO invalid_customers VALUES(firstanme, lastname, address);</programlisting>

      <para>The <literal>&lt;SQL procedure statement&gt;</literal> is required
      by the SQL Standard but is optional in HyperSQL. If the execution of the
      <literal>&lt;SQL procedure statement&gt;</literal> specified in the
      handler declaration throws an exception itself, then it is handled by
      the handlers that are currently active. The <literal>&lt;SQL procedure
      statement&gt;</literal> can itself be a compound statement with its own
      handlers.</para>
    </section>

    <section>
      <title>Assignment Statement</title>

      <para>The SET statement is used for assignment. It can be used flexibly
      with rows or single values. The BNF is given below:</para>

      <simpara><literal>&lt;assignment statement&gt; ::= &lt;singleton
      variable assignment&gt; | &lt;multiple variable
      assignment&gt;</literal></simpara>

      <simpara><literal>&lt;singleton variable assignment&gt; ::= SET
      &lt;assignment target&gt; &lt;equals operator&gt; &lt;assignment
      source&gt;</literal></simpara>

      <simpara><literal>&lt;multiple variable assignment&gt; ::= SET
      (&lt;variable or parameter&gt;, ...) = &lt;row value
      expression&gt;</literal></simpara>

      <para>In the example below, the result of the SELECT is assigned to two
      OUT or INOUT arguments. The SELECT must return one row. If it returns
      more than one, an exception is raised. If it returns no row, no change
      is made to ARG1 and ARG2.</para>

      <programlisting>SET (arg1, arg2) = (SELECT col1, col2 FROM atable WHERE id = 10);</programlisting>

      <para>In the example below, the result of a function call is assigned to
      VAR1.</para>

      <programlisting>SET var1 = SQRT(var2);</programlisting>
    </section>

    <section>
      <title>Select Statement : Single Row</title>

      <para>A special form of SELECT can also be used for assigning values
      from a query to one or more arguments or variables. This works similar
      to a SET statement that has a SELECT statement as the source.</para>

      <indexterm significance="preferred" type="sql">
        <primary>SELECT : SINGLE ROW</primary>
      </indexterm>

      <simpara><emphasis role="bold">SELECT : SINGLE ROW</emphasis></simpara>

      <simpara><emphasis>select statement: single row</emphasis></simpara>

      <simpara><literal>&lt;select statement: single row&gt; ::= SELECT [
      &lt;set quantifier&gt; ] &lt;select list&gt; INTO &lt;select target
      list&gt; &lt;table expression&gt;</literal></simpara>

      <simpara><literal>&lt;select target list&gt; ::= &lt;target
      specification&gt; [ { &lt;comma&gt; &lt;target specification&gt; }...
      ]</literal></simpara>

      <simpara>Retrieve values from a specified row of a table assigns the
      fields to the specified targets. The example below has an identical
      effect to the example of SET statement given above.</simpara>

      <programlisting>SELECT col1, col2 INTO arg1, arg2 FROM atable WHERE id = 10;</programlisting>
    </section>

    <section>
      <title>Formal Parameters</title>

      <para>Each parameter of a procedure can be defined as IN, OUT or INOUT.
      An IN parameter is an input to the procedure and is passed by value. The
      value cannot be modified inside the procedure body. An OUT parameter is
      a reference for output. An INOUT parameter is a reference for both input
      and output. An OUT or INOUT parameter argument is passed by reference,
      therefore only a dynamic parameter argument or a variable within an
      enclosing procedure can be passed for it. The assignment statement is
      used to assign a value to an OUT or INOUT parameter.</para>

      <para>In the example below, the procedure is declared with an OUT
      parameter.</para>

      <programlisting>CREATE PROCEDURE new_customer(OUT newid INT, IN firstname VARCHAR(50), IN lastname VARCHAR(50), IN address VARCHAR(100))
    MODIFIES SQL DATA
    BEGIN ATOMIC
    DECLARE temp_id INTEGER;
    INSERT INTO CUSTOMERS VALUES (DEFAULT, firstname, lastname, CURRENT_TIMESTAMP);
    SET temp_id = IDENTITY();
    INSERT INTO ADDRESSES VALUES (DEFAULT, temp_id, address);
    SET newid = temp_id;
    END

</programlisting>

      <para>In the SQL session, or in the body of another stored procedure, a
      variable must be assigned to the OUT parameter. After the procedure
      call, this variable will hold the new identity value that was generated
      inside the procedure.</para>

      <para>In the example below, a session variable,
      <literal>the_new_id</literal> is declared. After the call to
      <literal>new_customer</literal>, the value for the identity is stored in
      <literal>the_new_id</literal> variable. This is returned via the next
      CALL statement. Alternatively, <literal>the_new_id</literal> can be used
      as an argument to another CALL statement.</para>

      <programlisting>DECLARE the_new_id INT DEFAULT NULL;
CALL new_customer(the_new_id, 'John', 'Smith', '10 Parliament Square'); 
CALL the_new_id;

</programlisting>
    </section>

    <section>
      <title>Iterated Statements</title>

      <para>Various iterated statements can be used in routines. In these
      statements, the <literal>&lt;SQL statement list&gt;</literal> consists
      of one or more SQL statements. The <literal>&lt;search
      condition&gt;</literal> can be any valid SQL expression of BOOLEAN
      type.</para>

      <simpara><literal>&lt;loop statement&gt; ::= [ &lt;beginning label&gt;
      &lt;colon&gt; ] LOOP &lt;SQL statement list&gt; END LOOP [ &lt;ending
      label&gt; ]</literal></simpara>

      <simpara><literal>&lt;while statement&gt; ::= [ &lt;beginning label&gt;
      &lt;colon&gt; ] WHILE &lt;search condition&gt; DO &lt;SQL statement
      list&gt; END WHILE [ &lt;ending label&gt; ]</literal></simpara>

      <simpara><literal>&lt;repeat statement&gt; ::= [ &lt;beginning label&gt;
      &lt;colon&gt; ]</literal></simpara>

      <simpara><literal>REPEAT &lt;SQL statement list&gt; UNTIL &lt;search
      condition&gt; END REPEAT [ &lt;ending label&gt;</literal></simpara>

      <para>In the example below, a multiple rows are inserted into a table in
      a WHILE loop:</para>

      <programlisting>loop_label: WHILE my_var &gt; 0 DO
    INSERT INTO CUSTOMERS VALUES (DEFAULT, my_var);
    SET my_var = my_var - 1;
    IF my_var = 10 THEN SET my_var = 8; END IF;
    IF my_var = 22 THEN LEAVE loop_label; END IF;
    END WHILE loop_label;

</programlisting>
    </section>

    <section>
      <title>Conditional Statements</title>

      <para>There are two types of CASE ... WHEN statement and the IF ... THEN
      statement.</para>

      <indexterm significance="preferred" type="sql">
        <primary>CASE WHEN in routines</primary>
      </indexterm>

      <simpara><emphasis role="bold">CASE WHEN</emphasis></simpara>

      <simpara><emphasis>case when statement</emphasis></simpara>

      <para>The simple case statement uses a <literal>&lt;case
      operand&gt;</literal> as the predicand of one or more predicates. For
      the right part of each predicate, it specifies one or more SQL
      statements to execute if the predicate evaluates TRUE. If the ELSE
      clause is not specified, at least one of the search conditions must be
      true, otherwise an exception is raised.</para>

      <simpara><literal>&lt;simple case statement&gt; ::= CASE &lt;case
      operand&gt; &lt;simple case statement when clause&gt;... [ &lt;case
      statement else clause&gt; ] END CASE</literal></simpara>

      <simpara><literal>&lt;simple case statement when clause&gt; ::= WHEN
      &lt;when operand list&gt; THEN &lt;SQL statement
      list&gt;</literal></simpara>

      <simpara><literal>&lt;case statement else clause&gt; ::= ELSE &lt;SQL
      statement list&gt;</literal></simpara>

      <para>A skeletal example is given below. The variable var_one is first
      tested for equality with 22 or 23 and if the test evaluates to TRUE,
      then the INSERT statement is performed and the statement ends. If the
      test does not evaluate to TRUE, the next condition test, which is an IN
      predicate, is performed with var_one and so on. The statement after the
      ELSE clause is performed if none the previous tests returns TRUE.</para>

      <programlisting>CASE var_one
    WHEN 22, 23 THEN INSERT INTO t_one ...;
    WHEN IN (2, 4, 5) THEN DELETE FROM t_one WHERE ...;
    ELSE UPDATE t_one ...;
    END CASE

</programlisting>

      <para>The searched case statement uses one or more search conditions,
      and for each search condition, it specifies one or more SQL statements
      to execute if the search condition evaluates TRUE. An exception is
      raised if there is no ELSE clause and none of the search conditions
      evaluates TRUE.</para>

      <simpara><literal>&lt;searched case statement&gt; ::= CASE &lt;searched
      case statement when clause&gt;... [ &lt;case statement else clause&gt; ]
      END CASE</literal></simpara>

      <simpara><literal>&lt;searched case statement when clause&gt; ::= WHEN
      &lt;search condition&gt; THEN &lt;SQL statement
      list&gt;</literal></simpara>

      <para>The example below is partly a rewrite of the previous example, but
      a new condition is added:</para>

      <programlisting>CASE WHEN var_one = 22 OR var_one = 23 THEN INSERT INTO t_one ...;
    WHEN var_one IN (2, 4, 5) THEN DELETE FROM t_one WHERE ...;
    WHEN var_two IS NULL THEN UPDATE t_one ...;
    ELSE UPDATE t_one ...;
    END CASE

</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>IF STATEMENT</primary>
      </indexterm>

      <simpara><emphasis role="bold">IF</emphasis></simpara>

      <simpara><emphasis>if statement</emphasis></simpara>

      <para>The if statement is very similar to the searched case statement.
      The difference is that no exception is raised if there is no ELSE clause
      and no search condition evaluates TRUE.</para>

      <simpara><literal>&lt;if statement&gt; ::= IF &lt;search condition&gt;
      &lt;if statement then clause&gt; [ &lt;if statement elseif clause&gt;...
      ] [ &lt;if statement else clause&gt; ] END IF</literal></simpara>

      <simpara><literal>&lt;if statement then clause&gt; ::= THEN &lt;SQL
      statement list&gt;</literal></simpara>

      <simpara><literal>&lt;if statement elseif clause&gt; ::= ELSEIF
      &lt;search condition&gt; THEN &lt;SQL statement
      list&gt;</literal></simpara>

      <simpara><literal>&lt;if statement else clause&gt; ::= ELSE &lt;SQL
      statement list&gt;</literal></simpara>
    </section>

    <section>
      <title>Return Statement</title>

      <para>The RETURN statement is required and used only in functions. The
      body of a function is either a RETURN statement, or a compound statement
      that contains a RETURN statement.</para>

      <indexterm significance="preferred" type="sql">
        <primary>RETURN</primary>
      </indexterm>

      <simpara><emphasis role="bold">RETURN</emphasis></simpara>

      <simpara><emphasis>return statement</emphasis></simpara>

      <simpara><literal>&lt;return statement&gt; ::= RETURN &lt;return
      value&gt;</literal></simpara>

      <simpara><literal>&lt;return value&gt; ::= &lt;value expression&gt; |
      NULL</literal></simpara>

      <simpara>Return a value from an SQL function. If the function is defined
      as RETURNS TABLE, then the value is a TABLE expression such as RETURN
      TABLE(SELECT ...) otherwise, the value expression can be any scalar
      expression. In the examples below, the same function is written with or
      without a BEGIN END block. In both versions, the RETURN value is a
      scalar expression.</simpara>

      <programlisting>CREATE FUNCTION an_hour_before_max (e_type INT)
    RETURNS TIMESTAMP
    RETURN (SELECT MAX(event_time) FROM atable WHERE event_type = e_type) - 1 HOUR

CREATE FUNCTION an_hour_before_max (e_type INT)
    RETURNS TIMESTAMP
    BEGIN ATOMIC
    DECLAR max_event TIMESTAMP;
    SET max_event = SELECT MAX(event_time) FROM atable WHERE event_type = e_type;
    RETURN max_event - 1 HOUR;
    END

</programlisting>
    </section>

    <section>
      <title>Control Statements</title>

      <para>In addition to the RETURN statement, the following statements can
      be used in specific contexts.</para>

      <para>ITERATE STATEMENT</para>

      <para>The ITERATE statement can be used to cause the next iteration of a
      labeled iterated statement (a WHILE, REPEAT or LOOP statement). It is
      similar to the "continue" statement in C and Java.</para>

      <simpara><literal>&lt;iterate statement&gt; ::= ITERATE &lt;statement
      label&gt;</literal></simpara>

      <para>LEAVE STATEMENT</para>

      <para>The LEAVE statement can be used to leave a labeled block. When
      used in an iterated statement, it is similar to the "break" statement is
      C and Java. But it can be used in compound statements as well.</para>

      <simpara><literal>&lt;leave statement&gt; ::= LEAVE &lt;statement
      label&gt;</literal></simpara>

      <simpara>Signal and Resignal Statements</simpara>

      <para>The SIGNAL statement is used to throw an exception (or force an
      exception). When invoked, any exception handler for the given exception
      is in turn invoked. If there is no handler, the exception is propagated
      to the enclosing context.</para>

      <simpara><literal>&lt;signal statement&gt; ::= SIGNAL SQL_STATE
      &lt;state value&gt;</literal></simpara>

      <para>The RESIGNAL statement is used to throw an exception from an
      exception handler’s <literal>&lt;SQL procedure statement&gt;</literal>,
      in effect propagating the exception to the enclosing context without
      further action by the currently active handlers.</para>

      <simpara><literal>&lt;resignal statement&gt; ::= RESIGNAL SQL_STATE
      &lt;state value&gt;</literal></simpara>
    </section>

    <section>
      <title>Routine Polymorphism</title>

      <para>More than one version of a routine can be created.</para>

      <para>For procedures, the different versions must have different
      parameter counts.  When the procedure is called, the parameter count
      determines which version is called.</para>

      <para>For functions, the different versions can have the same or
      different parameter counts. When the parameter count of two versions of
      a function is the same, the type of parameters must be different. The
      best matching version of the function is called, according to both the
      parameter count and parameter types.</para>

      <para>Two versions of an overloaded function are given below. One
      version accepts TIMESTAMP while the other accepts TIME arguments.</para>

      <programlisting>CREATE FUNCTION an_hour_before_or_now(t TIMESTAMP)
    RETURNS TIMESTAMP
    IF t &gt; CURRENT_TIMESTAMP THEN
    RETURN CURRENT_TIMESTAMP;
    ELSE
    RETURN t - 1 HOUR;
    END IF

CREATE FUNCTION an_hour_before_or_now(t TIME)
    RETURNS TIME
    CASE t
    WHEN &gt; CURRENT_TIME THEN
    RETURN CURRENT_TIME;
    WHEN &gt;= TIME'01:00:00' THEN
    RETURN t - 1 HOUR;
    ELSE
    RETURN CURRENT_TIME;
    END CASE

</programlisting>

      <para>more ..</para>
    </section>

    <section>
      <title>Returning Data From Procedures</title>

      <para>The OUT or INOUT parameters of a procedure are used to assign
      simple values to dynamic parameters or to variables in the calling
      context. In addition, a SQL/PSM procedure may return result sets to the
      calling context. These result sets are dynamic in the sense that a
      procedure may return a different number of result sets or none at all in
      different invocations.</para>

      <para>The SQL Standard uses a mechanism called CURSORS for accessing and
      modifying rows of a result set one by one. This mechanism is absolutely
      necessary when the database is accessed from an external application
      program. The JDBC ResultSet interface allows this method of access from
      Java programs and is supported by HyperSQL.</para>

      <para>The SQL Standard uses cursors within the body of a procedure to
      return result sets. It specifies a somewhat complex mechanism to allow
      access to these cursors from the calling contexts. HyperSQL does not
      support access to such result sets within a calling SQL/PSM procedure.
      This is considered redundant as all operations on data can be performed
      with non-cursor SQL statements.</para>

      <para>(feature to be implemented) HyperSQL will support returning single
      or multiple result sets from SQL/PSM procedures only via the JDBC
      CallableStatement interface. Cursors are declared and opened within the
      body of the procedure. No further operation is performed on the cursors
      within the procedure. When the execution of the procedure is complete,
      the cursors become available as Java ResultSet objects via the
      CallableStatement instance that called the SQL/PSM procedure.</para>

      <para>Currently, a single result can be returned from FUNCTION routines,
      when the function is defined as RETURNS TABLE ( .. )</para>

      <para>The JDBC CallableStatement class is used with the SQL statement
      <literal>CALL &lt;routine name&gt; ( &lt;argument 1&gt;, ... )</literal>
      is used to call both functions and procedures. The
      <literal>getXXX()</literal> methods can be used to retrieve INOUT or OUT
      arguments after the call. The <literal>getResultSet()</literal> call can
      be used to access the ResultSet returned from a function that returns a
      result set.</para>
    </section>
  </section>

  <section>
    <title>SQL Language Aggregate Functions</title>

    <para>HyperSQL adds an extension to the SQL Standard to allow user defined
    aggregate functions. A user defined aggregate function has a single
    parameter when it is used in SQL statements. Unlike the predefined
    aggregate functions, the keyword DISTINCT cannot be used when a user
    defined aggregate function is invoked. Like all user defined functions, an
    aggregate function belongs to a schema and can be polymorphic.</para>

    <para>A user defined aggregate function can be used in SQL statements
    where a predefined aggregate function is allowed.</para>

    <section>
      <title>Definition of Aggregate Functions</title>

      <para>An aggregate function is always defined with 4 parameters. The
      first parameter is the parameter that is used when the function is
      invoked in SQL statements, the rest of the parameter are invisible to
      the invoking statement. The type of the first parameter is user defined.
      The type of the second parameter must be BOOLEAN. The third and fourth
      parameters have user defined types and must be defined as INOUT
      parameters. The defined return type of the function determines the type
      of the value returned when the function is invoked.</para>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE AGGREGATE FUNCTION</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE AGGREGATE
      FUNCTION</emphasis></simpara>

      <simpara><emphasis>user defined aggregate function
      definition</emphasis></simpara>

      <para>Aggregate function definition is similar to normal function
      definition and has the mandatory <literal>&lt;returns
      clause&gt;</literal>. The BNF is given below.</para>

      <simpara><literal>&lt;user defined aggregate function&gt; ::= CREATE
      AGGREGATE FUNCTION &lt;schema qualified routine name&gt; &lt;SQL
      aggregate parameter declaration list&gt; &lt;returns clause&gt;
      &lt;routine characteristics&gt; &lt;routine body&gt;</literal></simpara>

      <para>The parameter declaration list BNF is given below. The type of the
      first parameter is used when the function is invoked as part of an SQL
      statement. When multiple versions of a function are required, each
      version will have the first parameter of a different type.</para>

      <simpara><literal>&lt;SQL aggregate declaration list&gt; ::= &lt;left
      paren&gt; [IN] [ &lt;SQL parameter name&gt; ] &lt;parameter type&gt;
      &lt;comma&gt; [IN] &lt;SQL parameter name&gt; BOOLEAN &lt;comma&gt;
      INOUT [ &lt;SQL parameter name&gt; ] &lt;parameter type&gt;
      &lt;comma&gt; INOUT [ &lt;SQL parameter name&gt; ] &lt;parameter
      type&gt; &lt;right paren&gt;</literal></simpara>

      <para>The return type is user defined. This is the type of the resulting
      value when the function is called. Usually an aggregate function is
      defined with CONTAINS SQL, as it normally does not read the data in
      database tables, but it is possible to define the function with READS
      SQL DATA and access the database tables.</para>

      <para>HyperSQL invokes the aggregate function, with all the arguments
      set, once per each row in order to compute the values. Finally, it
      invokes the function once more to return the final result.</para>

      <para>In the computation phase, the first argument is the value of the
      user argument as specified in the SQL statement, computed for the
      current row. The second argument is the boolean FALSE. The third and
      fourth argument values are initially null, but they can be updated in
      the body of the function during each invocation. The third and fourth
      arguments act as registers and hold their values between invocation. The
      return value of the function is ignored during the computation phase
      (when the second parameter is FALSE).</para>

      <para>After the computation phase, the function is invoked once more to
      get the final result. In this invocation, the first parameter is NULL
      and the second argument is boolean TRUE. The third and fourth parameters
      hold the values they held at the end of the last invocation. The value
      returned by the function in this invocation is used as the result of the
      aggregate function computation in the invoking SQL statement. In SQL
      queries with GROUP BY, the call sequence is repeated for each separate
      group.</para>

      <para>The example below features a user defined version of the Standard
      <literal>AVG(&lt;value expression&gt;)</literal> aggregate function for
      INTEGER input and output types. This function behaves differently from
      the Standard AVG function as it returns 0 when all the input values are
      null.</para>

      <programlisting>CREATE AGGREGATE FUNCTION udavg(IN x INTEGER, IN flag BOOLEAN, INOUT addup BIGINT, INOUT counter INT)
    RETURNS INTEGER
    CONTAINS SQL
    BEGIN ATOMIC
      IF flag THEN
        RETURN addup / counter;
      ELSE
        SET counter = COALESCE(counter, 0) + 1;
        SET addup = COALESCE(addup, 0) + COALESCE(x, 0);
        RETURN NULL;
      END IF;
    END

</programlisting>

      <para>The example below the user defined aggregate function is used in a
      select statement. Only the first parameter is visible and utilised in
      the select statement.</para>

      <programlisting>SELECT udavg(id) FROM customers GROUP BY lastname;</programlisting>
    </section>
  </section>

  <section>
    <title>Java Language Routines (SQL/JRT)</title>

    <para>The body of a Java language routine is a static method of a Java
    class, specified with a fully qualified method name in the routine
    definition.</para>

    <para>In the example below, the static method named
    <methodname>toZeroPaddedString</methodname> is specified to be called when
    the function is invoked.</para>

    <programlisting>CREATE FUNCTION zero_pad(x BIGINT, digits INT, maxsize INT)
    RETURNS CHAR VARYING(100)
    NO SQL
    LANGUAGE JAVA PARAMETER STYLE JAVA
    EXTERNAL NAME
    'CLASSPATH:org.hsqldb.lib.StringUtil.toZeroPaddedString'

</programlisting>

    <para>The signature of the Java method (used in the Java code but not in
    SQL code to create the function) is given below:</para>

    <programlisting>public static String toZeroPaddedString(long value, int precision, int maxSize)</programlisting>

    <para>The parameter and return types and of the SQL routine definition
    must match those of the Java method according to the table below:</para>

    <informaltable frame="all">
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><para>SMALLINT   </para></entry>

            <entry><para>Short or Short</para></entry>
          </row>

          <row>
            <entry><para>INT</para></entry>

            <entry><para>int or Integer</para></entry>
          </row>

          <row>
            <entry><para>BIGINT</para></entry>

            <entry><para>long or Long</para></entry>
          </row>

          <row>
            <entry><para>NUMERIC  or DECIMAL</para></entry>

            <entry><para>BigDecimal</para></entry>
          </row>

          <row>
            <entry><para>FLOAT  or DOUBLE</para></entry>

            <entry><para>Double or Double</para></entry>
          </row>

          <row>
            <entry><para>CHAR or VARCHAR</para></entry>

            <entry><para>String</para></entry>
          </row>

          <row>
            <entry><para>DATE</para></entry>

            <entry><para>java.sql.Date</para></entry>
          </row>

          <row>
            <entry><para>TIME</para></entry>

            <entry><para>java.sql.Time</para></entry>
          </row>

          <row>
            <entry><para>TIMESTAMP</para></entry>

            <entry><para>java.sql.Timestamp</para></entry>
          </row>

          <row>
            <entry><para>BINARY</para></entry>

            <entry><para>Byte[]</para></entry>
          </row>

          <row>
            <entry><para>BOOLEAN</para></entry>

            <entry><para>boolean or Boolean</para></entry>
          </row>

          <row>
            <entry><para>TABLE</para></entry>

            <entry><para>java.sql.ResultSet</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>If the specified Java method is not found or its parameters and
    return types do not match the definition, an exception is raised. If more
    than one version of the Java method exist, then the one with matching
    parameter and return types is found and registered. If two “equivalent”
    methods exist, the first one is registered. (This situation arises only
    when a parameter is a primitive in one version and an Object in another
    version, e.g. <classname>long</classname> and
    <classname>java.lang.Long</classname>.).</para>

    <para>When the Java method of an SQL/JRT routine returns a value, it
    should be within the size and precision limits defined in the return type
    of the SQL-invoked routine, otherwise an exception is raised. The scale
    difference are ignored and corrected. For example, in the above example,
    the <literal>RETURNS CHAR VARYING(100)</literal> clause limits the length
    of the strings returned from the Java method to 100. But if the number of
    digits after the decimal point (scale) of a returned BigDecimal value is
    larger than the scale specified in the RETURNS clause, the decimal
    fraction is silently truncated and no exception of warning is
    raised.</para>

    <section>
      <title>Polymorphism</title>

      <para>If two versions of the same SQL invoked routine with different
      parameter types are required, they can be defined to point to the same
      method name or different method names, or even methods in different
      classes. In the example below, the first two definitions refer to the
      same method name in the same class. In the Java class, the two static
      methods are defined with corresponding method signatures.</para>

      <para>In the third example, the Java function returns a result set and
      the SQL declaration includes RETURNS TABLE.</para>

      <programlisting>CREATE FUNCTION an_hour_before_or_now(t TIME)
    RETURNS TIME
    NO SQL
    LANGUAGE JAVA PARAMETER STYLE JAVA
    EXTERNAL NAME 'CLASSPATH:org.npo.lib.nowLessAnHour'

CREATE FUNCTION an_hour_before_or_now(t TIMESTAMP)
    RETURNS TIMESTAMP
    NO SQL
    LANGUAGE JAVA PARAMETER STYLE JAVA
    EXTERNAL NAME 'CLASSPATH:org.npo.lib.nowLessAnHour'

CREATE FUNCTION testquery(INTEGER) 
    RETURNS TABLE(n VARCHAR(20), i INT) 
    READS SQL DATA
    LANGUAGE JAVA
    EXTERNAL NAME 'CLASSPATH:org.hsqldb.test.TestJavaFunctions.getQueryResult'

</programlisting>

      <para>In the Java class:</para>

      <programlisting>    public static java.sql.Time nowLessAnHour(java.sql.Time value) {
        ...
    }
    public static java.sql.Timestamp nowLessAnHour(java.sql.Timestamp value)
        ...
    }

    public static ResultSet getQueryResult(Connection connection, int i) throws SQLException {
        Statement st = connection.createStatement();
        return st.executeQuery("SELECT * FROM T WHERE I &lt; " + i);
    }

</programlisting>
    </section>

    <section>
      <title>Legacy Support</title>

      <para>The legacy HyperSQL statement, <literal>CREATE ALIAS &lt;name&gt;
      FOR &lt;fully qualified java method name&gt;</literal> is no longer
      supported directly. It is supported when importing databases and
      translates to a special <literal>CREATE FUNCTION &lt;name&gt;</literal>
      statement that creates the function in the PUBLIC schema.</para>

      <para>The direct use of a Java method as a function is still supported
      but deprecated. It is internally translated to a special <literal>CREATE
      FUNCTION</literal> statement where the name of the function is the
      double quoted, fully qualified name of the Java method used.</para>
    </section>
  </section>

  <section>
    <title>Routine Definition</title>

    <para>As discussed in the previous pages, routine definition has several
    mandatory or optional clauses. The complete BNF supported by HyperSQL and
    the remaining clauses are documented in this section.</para>

    <indexterm significance="preferred" type="sql">
      <primary>CREATE FUNCTION</primary>
    </indexterm>

    <simpara><emphasis role="bold">CREATE FUNCTION</emphasis></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>CREATE PROCEDURE</primary>
    </indexterm>

    <simpara><emphasis role="bold">CREATE PROCEDURE</emphasis></simpara>

    <simpara><emphasis>routine definition</emphasis></simpara>

    <para>Routine definition is similar for procedures and functions. A
    function definition has the mandatory <literal>&lt;returns
    clause&gt;</literal> which is discussed later. The description given so
    far covers the essential elements of the specification with the BNF given
    below.</para>

    <simpara><literal>&lt;schema procedure&gt; ::= CREATE PROCEDURE &lt;schema
    qualified routine name&gt; &lt;SQL parameter declaration list&gt;
    &lt;routine characteristics&gt; &lt;routine body&gt;</literal></simpara>

    <simpara><literal>&lt;schema function&gt; ::= CREATE FUNCTION &lt;schema
    qualified routine name&gt; &lt;SQL parameter declaration list&gt;
    &lt;returns clause&gt; &lt;routine characteristics&gt; &lt;routine
    body&gt;</literal></simpara>

    <para>Parameter declaration list has been described above. For SQL/JRT
    routines, the <literal>&lt;SQL parameter name&gt;</literal> is optional
    while for SQL/PSM routines, it is required. If the <literal>&lt;parameter
    mode&gt;</literal> of a parameter is OUT or INOUT, it must be specified.
    The BNF is given below:</para>

    <simpara><literal>&lt;SQL parameter declaration list&gt; ::= &lt;left
    paren&gt; [ &lt;SQL parameter declaration&gt; [ { &lt;comma&gt; &lt;SQL
    parameter declaration&gt; }... ] ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;SQL parameter declaration&gt; ::= [ &lt;parameter
    mode&gt; ] [ &lt;SQL parameter name&gt; ] &lt;parameter
    type&gt;</literal></simpara>

    <simpara><literal>&lt;parameter mode&gt; ::= IN | OUT |
    INOUT</literal></simpara>

    <simpara><literal>&lt;parameter type&gt; ::= &lt;data
    type&gt;</literal></simpara>

    <para>Return Value and Table Functions</para>

    <indexterm significance="preferred" type="sql">
      <primary>RETURNS</primary>
    </indexterm>

    <simpara><emphasis role="bold">RETURNS</emphasis></simpara>

    <simpara><emphasis>returns clause</emphasis></simpara>

    <para>The <literal>&lt;returns clause&gt;</literal> specifies the type of
    the return value of a function. For all SQL/PSM functions and ordinary
    SQL/JRT functions, this is simply a type definition which can be a
    built-in type, a DOMAIN type or a DISTINCT type, or alternatively, a TABLE
    definition. For example, RETURNS INTEGER.</para>

    <para>For a SQL/JRT function, it is possible to define a
    <literal>&lt;returns table type&gt;</literal> for a Java method that
    returns a <classname>java.sql.ResultSet</classname> object. Such SQL/JRT
    functions are called <glossterm>table functions</glossterm>. Table
    functions are used differently from normal functions. A table function can
    be used in an SQL query expression exactly where a normal table or view is
    allowed. At the time of invocation, the Java method is called and the
    returned ResultSet is transformed into an SQL table. The column types of
    the declared TABLE must match those of the ResultSet, otherwise an
    exception is raised at the time of invocation.</para>

    <para>If a <literal>&lt;returns table type&gt;</literal> is defined for an
    SQL/PSM function, the following expression is used inside the function to
    return a table: <literal>RETURN TABLE ( &lt;query expression&gt;
    );</literal> In the example blow, a table with two columns is
    returned.</para>

    <programlisting>RETURN TABLE ( SELECT a, b FROM atable WHERE e = 10 );</programlisting>

    <para>If a JDBC <literal>CallableStatement</literal> is used to CALL the
    function, the table returned from the function call is returned and can be
    accessed with the <literal>getResultSet()</literal> method of the
    <literal>CallableStatement</literal>.</para>

    <simpara><literal>&lt;returns clause&gt; ::= RETURNS &lt;returns
    type&gt;</literal></simpara>

    <simpara><literal>&lt;returns type&gt; ::= &lt;returns data type&gt; |
    &lt;returns table type&gt;</literal></simpara>

    <simpara><literal>&lt;returns table type&gt; ::= TABLE &lt;table function
    column list&gt;</literal></simpara>

    <simpara><literal>&lt;table function column list&gt; ::= &lt;left
    paren&gt; &lt;table function column list element&gt; [ { &lt;comma&gt;
    &lt;table function column list element&gt; } ... ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;table function column list element&gt; ::=
    &lt;column name&gt; &lt;data type&gt;</literal></simpara>

    <simpara><literal>&lt;returns data type&gt; ::= &lt;data
    type&gt;</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>routine body</primary>
    </indexterm>

    <simpara><emphasis role="bold">routine body</emphasis></simpara>

    <simpara><emphasis>routine body</emphasis></simpara>

    <para>Routine body is either one or more SQL statements or a Java
    reference, as described. The user that defines the routine by issuing the
    CREATE FUNCTION or CREATE SCHEMA command must have the relevant access
    rights to all tables, sequences, routines, etc. that are accessed by the
    routine. If another user is given EXECUTE privilege on the routine, then
    there are two possibilities, depending on the <literal>&lt;rights
    clause&gt;</literal>. This clause refers to the access rights that are
    checked when a routine is invoked. The default is <literal>SQL SECURITY
    DEFINER</literal>, which means access rights of the definer are used;
    therefore no extra checks are performed when the other user invokes the
    routine. The alternative <literal>SQL SECURITY INVOKER</literal> means
    access rights on all the database objects referenced by the routine are
    checked for the invoker. This alternative is not supported by
    HyperSQL.</para>

    <simpara><literal>&lt;routine body&gt; ::= &lt;SQL routine spec&gt; |
    &lt;external body reference&gt;</literal></simpara>

    <simpara><literal>&lt;SQL routine spec&gt; ::= [ &lt;rights clause&gt; ]
    &lt;SQL routine body&gt;</literal></simpara>

    <simpara><literal>&lt;rights clause&gt; ::= SQL SECURITY INVOKER | SQL
    SECURITY DEFINER</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>SQL routine body</primary>
    </indexterm>

    <simpara><emphasis role="bold">SQL routine body</emphasis></simpara>

    <simpara><emphasis>SQL routine body</emphasis></simpara>

    <para>The routine body of a an SQL routine consists of an
    statement.</para>

    <simpara><literal>&lt;SQL routine body&gt; ::= &lt;SQL procedure
    statement&gt;</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>EXTERNAL NAME</primary>
    </indexterm>

    <simpara><emphasis role="bold">EXTERNAL NAME</emphasis></simpara>

    <simpara><emphasis>external body reference</emphasis></simpara>

    <para>External name specifies the qualified name of the Java method
    associated with this routine. Early releases of HyperSQL 2.0 only supports
    Java methods within the classpath. The <literal>&lt;external Java
    reference string&gt;</literal> is a quoted string which starts with
    CLASSPATH: and is followed by the java package, class and method names
    separated with dots.</para>

    <simpara><literal>&lt;external body reference&gt; ::= EXTERNAL NAME
    &lt;external Java reference string&gt; ]</literal></simpara>

    <simpara><literal>&lt;external Java reference string&gt; ::= &lt;jar and
    class name&gt; &lt;period&gt; &lt;Java method name&gt; [ &lt;Java
    parameter declaration list&gt; ]</literal></simpara>

    <para>The &lt;routine characteristics&gt; clause covers several
    sub-clauses</para>

    <simpara><literal>&lt;routine characteristics&gt; ::= [ &lt;routine
    characteristic&gt;... ]</literal></simpara>

    <simpara><literal>&lt;routine characteristic&gt; ::= &lt;language
    clause&gt; | &lt;parameter style clause&gt; | SPECIFIC &lt;specific
    name&gt; | &lt;deterministic characteristic&gt; | &lt;SQL-data access
    indication&gt; | &lt;null-call clause&gt; | &lt;returned result sets
    characteristic&gt; | &lt;savepoint level
    indication&gt;</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>LANGUAGE</primary>
    </indexterm>

    <simpara><emphasis role="bold">LANGUAGE</emphasis></simpara>

    <simpara><emphasis>language clause</emphasis></simpara>

    <para>The <literal>&lt;language clause&gt;</literal> refers to the
    language in which the routine body is written. It is either SQL or Java.
    The default is SQL, so JAVA must be specified for SQL/JRT routines.</para>

    <simpara><literal>&lt;language clause&gt; ::= LANGUAGE &lt;language
    name&gt;</literal></simpara>

    <simpara><literal>&lt;language name&gt; ::= SQL | JAVA</literal></simpara>

    <para>The parameter style is not allowed for SQL routines. It is optional
    for Java routines and, in HyperSQL, the only value allowed is JAVA.</para>

    <simpara><literal>&lt;parameter style&gt; ::= JAVA</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>SPECIFIC NAME</primary>
    </indexterm>

    <simpara><emphasis role="bold">SPECIFIC NAME</emphasis></simpara>

    <simpara><emphasis>specific name</emphasis></simpara>

    <para>The SPECIFIC <literal>&lt;specific name&gt;</literal> clause is
    optional but the engine will creates an automatic name if it is not
    present. When there are several versions of the same routine, the
    <literal>&lt;specific name&gt;</literal> is used in schema manipulation
    statements to drop or alter a specific version. The <literal>&lt;specific
    name&gt;</literal> is a user-defined name. It applies to both functions
    and procedures. In the examples below, a specific name is specified for
    each function.</para>

    <programlisting>CREATE FUNCTION an_hour_before_or_now(t TIMESTAMP)
    RETURNS TIMESTAMP
    NO SQL
    LANGUAGE JAVA PARAMETER STYLE JAVA
    SPECIFIC an_hour_before_or_now_with_timestamp
    EXTERNAL NAME 'CLASSPATH:org.npo.lib.nowLessAnHour'

CREATE FUNCTION an_hour_before_max (e_type INT)
    RETURNS TIMESTAMP SPECIFIC an_hour_before_max_with_int
    RETURN (SELECT MAX(event_time) FROM atable WHERE event_type = e_type) - 1 HOUR

</programlisting>

    <indexterm significance="preferred" type="sql">
      <primary>DETERMINISTIC characteristic</primary>
    </indexterm>

    <simpara><emphasis role="bold">DETERMINISTIC</emphasis></simpara>

    <simpara><emphasis>deterministic characteristic</emphasis></simpara>

    <para>The <literal>&lt;deterministic characteristic&gt;</literal> clause
    indicates that a routine is deterministic or not. Deterministic means the
    routine does not reference random values, external variables, or time of
    invocation. The default is <literal>NOT DETERMINISTIC</literal>. It is
    essential to declare this characteristics correctly for an SQL/JRT
    routine, as the engine does not know the contents of the Java code, which
    could include calls to methods returning random or time sensitive
    values.</para>

    <simpara><literal>&lt;deterministic characteristic&gt; ::= DETERMINISTIC |
    NOT DETERMINISTIC</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>SQL DATA access characteristic</primary>
    </indexterm>

    <simpara><emphasis role="bold">SQL DATA access</emphasis></simpara>

    <simpara><emphasis>SQL DATA access characteristic</emphasis></simpara>

    <para>The <literal>&lt;SQL-data access indication&gt;</literal>  clause
    indicates the extent to which a routine interacts with the database or the
    data stored in the database tables (SQL data).  NO SQL means no SQL
    command is issued in the routine body and can be used only for SQL/JRT
    functions. <literal>CONTAINS SQL</literal> means some SQL commands are
    used, but they do not read or modify the SQL data. <literal>READS SQL
    DATA</literal> and <literal>MODIFIES SQL DATA</literal> are self
    explanatory.</para>

    <simpara><literal>&lt;SQL-data access indication&gt; ::= NO SQL | CONTAINS
    SQL | READS SQL DATA | MODIFIES SQL DATA</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>NULL INPUT</primary>
    </indexterm>

    <simpara><emphasis role="bold">NULL INPUT</emphasis></simpara>

    <simpara><emphasis>null call clause</emphasis></simpara>

    <para>Null Arguments</para>

    <para>The <literal>&lt;null-call clause&gt;</literal> is used only for
    functions. If a function returns NULL when any of the calling arguments is
    null, then by specifying <literal>RETURNS NULL ON NULL INPUT</literal>,
    calls to the function are known to be redundant and do not take place when
    an argument is null. This simplifies the coding of the SQL/JRT Java
    methods and improves performance at the same time.</para>

    <simpara><literal>&lt;null-call clause&gt; ::= RETURNS NULL ON NULL INPUT
    | CALLED ON NULL INPUT</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>SAVEPOINT LEVEL</primary>
    </indexterm>

    <simpara><emphasis role="bold">SAVEPOINT LEVEL</emphasis></simpara>

    <simpara><emphasis>transaction impact</emphasis></simpara>

    <para>The <literal>&lt;savepoint level indication&gt;</literal> is used
    only for procedures and refers to the visibility of existing savepoints
    within the body of the procedure. If <literal>NEW SAVEPOINT
    LEVEL</literal> is specified, savepoints that have been declared prior to
    calling the procedure become invisible within the body of the procedure.
    HyperSQL’s implementation accepts only <literal>NEW SAVEPOINT
    LEVEL</literal>, which must be specified.</para>

    <simpara><literal>&lt;savepoint level indication&gt; ::= NEW SAVEPOINT
    LEVEL | OLD SAVEPOINT LEVEL</literal></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>DYNAMIC RESULT SETS</primary>
    </indexterm>

    <simpara><emphasis role="bold">DYNAMIC RESULT SETS</emphasis></simpara>

    <simpara><emphasis>returned result sets
    characteristic</emphasis></simpara>

    <para>The <literal>&lt;returned result sets characteristic&gt;</literal>
    is used only for SQL/PSM procedures. The maximum number of result sets
    that a procedure may return can be specified with the clause below. The
    default is zero. Details are discussed in the previous sections.</para>

    <simpara><literal>&lt;returned result sets characteristic&gt; ::= DYNAMIC
    RESULT SETS &lt;maximum returned result sets&gt;</literal></simpara>
  </section>
</chapter>
