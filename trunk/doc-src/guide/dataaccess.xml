<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % dummy22 SYSTEM "../entities/global.ent">
%dummy22;
]>
<chapter version="5.0" xml:id="dataaccess-chapt"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="dataaccess-title">Data Access and Change</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <pubdate>&timestamp;</pubdate>

    <keywordset>
      <keyword>HSQLDB</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2010-2020 Fred Toussi. Permission is granted to
      distribute this document without any alteration under the terms of the
      HSQLDB license. Additional permission is granted to the HSQL Development
      Group to distribute this document with or without alterations under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section xml:id="dac_overview">
    <title>Overview</title>

    <para>HyperSQL data access and data change statements are compatible with
    the latest SQL:2016 Standard. There are a few extensions and some
    relaxation of rules, but these do not affect statements that are written
    to the Standard syntax. There is full support for classic SQL, as
    specified by SQL-92, and many enhancements added in later versions of the
    standard.</para>
  </section>

  <section xml:id="dac_jdbc_cursors_result_sets">
    <title>Cursors And Result Sets</title>

    <para>An SQL statement can be executed in two ways. One way is to use the
    <classname>java.sql.Statement</classname> interface. The Statement object
    can be reused to execute completely different SQL statements.
    Alternatively, a <classname>PreparedStatment</classname> can be used to
    execute an SQL statement repeatedly, and the statements can use
    parameters. Using either form, if the SQL statement is a query expression,
    a <classname>ResultSet</classname> is returned.</para>

    <para>In SQL, when a query expression (SELECT or similar SQL statement) is
    executed, an ephemeral table is created. When this table is returned to
    the application program, it is returned as a result set, which is accessed
    row by row by a cursor. A JDBC <classname>ResultSet</classname> represents
    an SQL result set and its cursor.</para>

    <para>The minimal definition of a cursor is a list of rows with a position
    that can move forward. Some cursors also allow the position to move
    backwards or jump to any position in the list.</para>

    <para>An SQL cursor has several attributes. These attributes depend on the
    query expression. Some of these attributes can be overridden by specifying
    qualifiers in the SQL statement or by specifying values for the parameters
    of the JDBC <classname>Statement</classname> or
    <classname>PreparedStatement</classname>.</para>

    <section xml:id="dac_jdbc_columns_rows">
      <title>Columns and Rows</title>

      <para>The columns of the result set are determined by the query
      expression. The number of columns and the type and name characteristics
      of each column are known when the query expression is compiled and
      before its execution. This metadata information remains constant
      regardless of changes to the contents of the tables used in the query
      expression. The metadata for the JDBC <classname>ResultSet</classname>
      is in the form of a <classname>ResultSetMetaData</classname> object.
      Various methods of the <classname>ResultSetMetaData</classname>
      interface return different properties of each column of the
      <classname>ResultSet</classname>.</para>

      <para>A result set may contain 0 or more rows. The rows are determined
      by the execution of the query expression.</para>

      <para>The <methodname>setMaxRows(int)</methodname> method of JDBC
      <classname>Statement</classname> allows limiting the number of rows
      returned by the statement. This limit is conceptually applied after the
      result has been built, and the excess rows are discarded.</para>
    </section>

    <section xml:id="dac_jdbc_cursor_navigation">
      <title>Navigation</title>

      <para>A cursor is either scrollable or not. Scrollable cursors allow
      accessing rows by absolute or relative positioning. No-scroll cursors
      only allow moving to the next row. The cursor can be optionally declared
      with the SQL qualifiers SCROLL, or NO SCROLL. The JDBC statement
      parameter can be specified as: TYPE_FORWARD_ONLY and
      TYPE_SCROLL_INSENSITIVE. The JDBC type TYPE_SCROLL_SENSITIVE is not
      supported by HSQLDB.</para>

      <para>The default is NO SCROLL or TYPE_FORWARD_ONLY.</para>

      <para>When a JDBC <classname>ResultSet</classname> is opened, it is
      positioned before the first row. Using the
      <methodname>next()</methodname> method, the position is moved to the
      first row. While the <classname>ResultSet</classname> is positioned on a
      row, various getter methods can be used to access the columns of the
      row.</para>
    </section>

    <section xml:id="dac_jdbc_cursor_updatability">
      <title>Updatability</title>

      <para>The result returned by some query expressions is updatable. HSQLDB
      supports core SQL updatability features, plus some enhancements from the
      SQL optional features.</para>

      <para>A query expression is updatable if it is a SELECT from a single
      underlying base table (or updatable view) either directly or indirectly.
      A SELECT statement featuring DISTINCT or GROUP BY or FETCH, LIMIT,
      OFFSET is not updatable. In an updatable query expression, one or more
      columns are updatable. An updatable column is a column that can be
      traced directly to the underlying table. Therefore, columns that contain
      expressions are not updatable. Examples of updatable query expressions
      are given below. The view V is updatable when its query expression is
      updatable. The SELECT statement from this view is also updatable:</para>

      <informalexample>
        <programlisting> SELECT A, B FROM T WHERE C &gt; 5
 SELECT A, B FROM (SELECT * FROM T WHERE C &gt; 10) AS TT WHERE TT.B &lt;10
 CREATE VIEW V(X,Y) AS SELECT A, B FROM T WHERE C &gt; 0 AND B &lt; 10
 SELECT X FROM V WHERE Y = 5
</programlisting>
      </informalexample>

      <para>If a cursor is declared with the SQL qualifier, <literal>FOR
      UPDATE OF &lt;column name list&gt;</literal>, then only the stated
      columns in the result set become updatable. If any of the stated columns
      is not actually updatable, then the cursor declaration will not
      succeed.</para>

      <para>If the SQL qualifier, FOR UPDATE is used, then all the updatable
      columns of the result set become updatable.</para>

      <para>If a cursor is declared with FOR READ ONLY, then it is not
      updatable.</para>

      <para>In HyperSQL, if FOR READ ONLY or FOR UPDATE is not used then all
      the updatable columns of the result set become updatable. This relaxes
      the SQL standard rule that in this case limits updatability to only
      simply updatable SELECT statements (where all columns are
      updatable).</para>

      <para>In JDBC, CONCUR_READ_ONLY or CONCUR_UPDATABLE can be specified for
      the <classname>Statement</classname> parameter. CONCUR_UPDATABLE is
      required if the returning ResultSet is to be updatable. If
      CONCUR_READ_ONLY, which is the default, is used, then even an updatable
      ResultSet becomes read-only.</para>

      <para>When a <classname>ResultSet</classname> is updatable, various
      setter methods can be used to modify the column values. The names of the
      setter methods begin with "update". After all the updates on a row are
      done, the <methodname>updateRow()</methodname> method must be called
      only once to finalise the row update.</para>

      <para>An updatable <classname>ResultSet</classname> may or may not be
      insertable-into. In an insertable <classname>ResultSet</classname>, all
      columns of the result are updatable and any column of the base table
      that is not in the result must be a generated column or have a default
      value.</para>

      <para>In the <classname>ResultSet</classname> object, a special
      pseudo-row, called the insert row, is used to populate values for
      insertion into the <classname>ResultSet</classname> (and consequently,
      into the base table). The setter methods must be used on all the
      columns, followed by a call to
      <methodname>insertRow()</methodname>.</para>

      <para>Individual rows from all updatable result sets can be deleted one
      at a time. The <methodname>deleteRow()</methodname> is called when the
      <classname>ResultSet</classname> is positioned on a row.</para>

      <para>While using an updatable ResultSet to modify data, it is
      recommended not to change the same data using another ResultSet and not
      to execute SQL data change statements that modify the same data.</para>
    </section>

    <section xml:id="dac_jdbc_cursor_sensitivity">
      <title>Sensitivity</title>

      <para>The sensitivity of the cursor relates to visibility of changes
      made to the data by the same transaction but without using the given
      cursor. While the result set is open, the same transaction may use
      statements such as INSERT or UPDATE, and change the data of the tables
      from which the result set data is derived. A cursor is SENSITIVE if it
      reflects those changes. It is INSENSITIVE if it ignores such changes. It
      is ASENSITIVE if behaviour is implementation dependent.</para>

      <para>The SQL default is ASENSITIVE, i.e., implantation
      dependent.</para>

      <para>In HyperSQL all cursors are INSENSITIVE. They do not reflect
      changes to the data made by other statements.</para>
    </section>

    <section xml:id="dac_jdbc_cursor_holdability">
      <title>Holdability</title>

      <para>A cursor is holdable if the result set is not automatically closed
      when the current transaction is committed. Holdability can be specified
      in the cursor declaration using the SQL qualifiers WITH HOLD or WITHOUT
      HOLD.</para>

      <para>In JDBC, holdability is specified using either of the following
      values for the Statement parameter: HOLD_CURSORS_OVER_COMMIT, or
      CLOSE_CURSORS_AT_COMMIT.</para>

      <para>The SQL default is WITHOUT HOLD.</para>

      <para>The JDBC default for HyperSQL result sets is WITH HOLD for
      read-only result sets and WITHOUT HOLD for updatable result sets.</para>

      <para>If the holdability of a <classname>ResultSet</classname> is
      specified in a conflicting manner in the SQL statement and the JDBC
      <classname>Statement</classname> object, the JDBC setting takes
      precedence.</para>
    </section>

    <section xml:id="dac_jdbc_autocommit">
      <title>Autocommit</title>

      <para>The autocommit property of a connection is a feature of JDBC and
      ODBC and is not part of the SQL Standard. In autocommit mode, all
      transactional statements are followed by an implicit commit. In
      autocommit mode, all <classname>ResultSet</classname> objects are
      read-only and holdable.</para>
    </section>

    <section xml:id="dac_jdbc_overview">
      <title>JDBC Overview</title>

      <para>The JDBC settings, ResultSet.CONCUR_READONLY and
      ResultSet.CONCUR_UPDATABLE are the available alternatives for read-only
      or updatability. The default is ResultSet.CONCUR_READONLY.</para>

      <para>The JDBC settings, ResultSet.TYPE_FORWARD_ONLY,
      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.TYPE_SCROLL_SENSITIVE are
      the available alternatives for both scrollability (navigation) and
      sensitivity. HyperSQL does not support ResultSet.TYPE_SCROLL_SENSITIVE.
      The two other alternatives can be used for both updatable and read-only
      result sets.</para>

      <para>The JDBC settings ResultSet.CLOSE_CURSORS_AT_COMMIT and
      ResultSet.HOLD_CURSORS_OVER_COMMIT are the alternatives for the lifetime
      of the result set. The default is ResultSet.CLOSE_CURSORS_AT_COMMIT. The
      other setting can only be used for read-only result sets.</para>

      <para>Examples of creating statements for updatable result sets are
      given below:</para>

      <informalexample>
        <programlisting> Connection c = newConnection();
 Statement st;
 c.setAutoCommit(false);
 st = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 st = c.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_jdbc_parameters">
      <title>JDBC Parameters</title>

      <para>When a JDBC PreparedStatement or CallableStatement is used with an
      SQL statement that contains dynamic parameters, the data types of the
      parameters are resolved and determined by the engine when the statement
      is prepared. The SQL Standard has detailed rules to determine the data
      types and imposes limits on the maximum length or precision of the
      parameter. HyperSQL applies the standard rules with two exceptions for
      parameters with String and BigDecimal Java types. HyperSQL ignores the
      limits when the parameter value is set, and only enforces the necessary
      limits when the PreparedStatement is executed. In all other cases,
      parameter type limits are checked and enforced when the parameter is
      set.</para>

      <para>In the example below the <methodname>setString()</methodname>
      calls do not raise an exception, but one of the
      <methodname>execute()</methodname> statements does.</para>

      <informalexample>
        <programlisting> // table definition: CREATE TABLE T (NAME VARCHAR(12), ...)
 Connection c = newConnection();
 PreparedStatement st = c.prepareStatement("SELECT * FROM T WHERE NAME = ?");
 // type of the parameter is VARCHAR(12), which limits length to 12 characters
 st.setString(1, "Eyjafjallajokull"); // string is longer than type, but no exception is raised here
 set.execute(); // executes with no exception and does not find any rows

 // but if an UPDATE is attempted, an exception is raised
 st = c.prepareStatement("UPDATE T SET NAME = ? WHERE ID = 10");
 st.setString(1, "Eyjafjallajokull"); // string is longer than type, but no exception is raised here
 st.execute(); // exception is thrown when HyperSQL checks the value for update

</programlisting>
      </informalexample>

      <para>JDBC parameters can be set with any compatible type, as supported
      by the JDBC specification. For CLOB and BLOB types, you can use streams,
      or create instances of BLOB or CLOB before assigning them to the
      parameters. You can even use CLOB or BLOB objects returned from
      connections to other RDBMS servers. The
      <methodname>Connection.createBlob()</methodname> and
      <methodname>createClob()</methodname> methods can be used to create the
      new LOBs. For very large LOBs the stream methods are preferable as they
      use less memory.</para>

      <para>For array parameters, you can use a
      <classname>java.sql.Array</classname> object that contains the array
      elements before assigning to JDBC parameters. The
      <code>Connection.createArrayOf(...)</code> method can be used to create
      a new object, or you can use an Array returned from connections to other
      RDBMS servers. You can also use Java arrays of primitives to assign to
      the SQL array parameters.</para>

      <para>The above also applies to the methods of
      <classname>java.sql.ResultSet</classname> that are used for setting
      values in new and updated rows in updatable ResultSet objects.</para>

      <para>When the Java 8 version of HyperSQL jar is used, the setObject()
      methods of <classname>PreparedStatement</classname> and
      <classname>CallableStatement</classname> also accept objects of the new
      types introduced in Java 8 and listed below under JDBC Returned Values.
      The new Java 8 method, <methodname>getObject(int columnIndex,
      Class&lt;T&gt; type)</methodname>, can be used to retrieve the value of
      an OUT parameter from a <classname>CallableStatement</classname>.</para>
    </section>

    <section xml:id="dac_jdbc_data_change">
      <title>JDBC and Data Change Statements</title>

      <para>Data change statements, also called data manipulation statements
      (DML) such as INSERT, UPDATE, MERGE can be called with different
      <methodname>executeUpdate()</methodname> methods of java.sql.Statement
      and <classname>java.sql.PreparedStatement</classname>. Some of these
      methods allow you to specify how values for generated columns of the
      table are returned. These methods are documented in the JavaDoc for
      <classname>org.hsqldb.jdbc.JDBCStatement</classname> and
      <classname>org.hsqldb.jdbc.JDBCPreparedStatement</classname>. HyperSQL
      can return not just the generated columns, but any set of columns of the
      table. You can use this to retrieve the columns values that may be
      modified by a BEFORE TRIGGER on the table.</para>
    </section>

    <section xml:id="dac_jdbc_callable_statement">
      <title>JDBC Callable Statement</title>

      <para>The JDBC CallableStatement interface is used to call Java or SQL
      procedures that have been defined in the database. The SQL statement is
      in the form of CALL procedureName ( ... ) with constant value arguments
      or with parameter markers. Note that you must use a parameter marker for
      OUT and INOUT arguments of the procedure you are calling. The OUT
      arguments should not be set before executing the callable
      statement.</para>

      <para>After executing the statement, you can retrieve the OUT and INOUT
      parameters with the appropriate getXXX() method.</para>

      <para>Procedures can also return one or more result sets. You should
      call the <methodname>getResultSet()</methodname> and
      <methodname>getMoreResults()</methodname> methods to retrieve the result
      sets one by one.</para>

      <para>SQL functions can also return a table. You can call such functions
      the same way as procedures and retrieve the table as a ResultSet.</para>
    </section>

    <section xml:id="dac_jdbc_return_values">
      <title>JDBC Returned Values</title>

      <para>The methods of the JDBC ResultSet interface are used to return
      values and to convert value to different types as supported by the JDBC
      specification. Methods of JDBC CallableStatement that have the same
      signature are used to return values from procedure calls.</para>

      <para>When a CLOB and BLOB object is returned from a ResultSet, no data
      is transferred until the data is read by various methods of
      <classname>java.sql.CLOB</classname> and
      <classname>java.sql.BLOB</classname>. Data is streamed in large blocks
      to avoid excessive memory use.</para>

      <para>Array objects are returned as instances of
      <classname>java.sql.Array</classname>.</para>

      <para>When the Java 8 version of HyperSQL jar is used, the methods added
      in Java 8 become available and the behaviour of the
      <methodname>getObject(int columnIndex)</methodname> method for
      retrieving TIMESTAMP WITH TIME ZONE values changes. With Java 7 and
      older, this method returns a <classname>java.sql.Timestamp</classname>
      object. With Java 8 it returns a
      <classname>java.time.OffsetDateTime</classname> object which contains
      the time zone offset value as well as the other fields of the
      TIMESTAMP.</para>

      <para>A new method, <methodname>getObject(int columnIndex,
      Class&lt;T&gt; type)</methodname> is available in Java 8. With this
      method, you specify the required return type. The common types such as
      String, Integer, byte[] are supported, as well as new types that can be
      used for DATE, TIME, TIMESTAMP, and INTERVAL values. The table below
      shows which Java classes are the most appropriate for the specified SQL
      TYPES. In addition, you can use these Java types for values of SQL type
      that are not fully matched. For example,
      <classname>java.time.LocalDateTime</classname> can be used to retrieve a
      DATE value.</para>

      <informaltable>
        <tgroup cols="1">
          <tbody>
            <row>
              <entry><classname>java.util.UUID</classname> = UUID</entry>
            </row>

            <row>
              <entry><classname>java.time.LocalDate</classname> = DATE</entry>
            </row>

            <row>
              <entry><classname>java.sql.Date</classname> = DATE</entry>
            </row>

            <row>
              <entry><classname>java.time.LocalTime</classname> = TIME</entry>
            </row>

            <row>
              <entry><classname>java.sql.Time</classname> = TIME</entry>
            </row>

            <row>
              <entry><classname>java.time.LocalDateTime</classname> =
              TIMESTAMP</entry>
            </row>

            <row>
              <entry><classname>java.sql.Timestamp</classname> =
              TIMESTAMP</entry>
            </row>

            <row>
              <entry><classname>java.time.OffsetTime</classname> = TIME WITH
              TIME ZONE</entry>
            </row>

            <row>
              <entry><classname>java.time.OffsetDateTime</classname> =
              TIMESTAMP WITH TIME ZONE</entry>
            </row>

            <row>
              <entry><classname>java.time.Duration</classname> = INTERVAL
              MONTH, INTERVAL YEAR, INTERVAL YEAR TO MONTH</entry>
            </row>

            <row>
              <entry><classname>java.time.Period</classname> = INTERVAL
              SECOND, INTERVAL MINUTE, INTERVAL HOUR, INTERVAL DAY, and their
              range combinations</entry>
            </row>

            <row>
              <entry><classname>java.sql.Array</classname> = all ARRAY</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id="dac_declare_cursor">
      <title>Cursor Declaration</title>

      <para>The DECLARE CURSOR statement is used within an SQL PROCEDURE body.
      In the current version of HyperSQL, the cursor is used only to return a
      result set from the procedure. Therefore, the cursor must be declared
      WITH RETURN and can only be READ ONLY.</para>

      <indexterm significance="preferred" type="sql">
        <primary>DECLARE CURSOR</primary>
      </indexterm>

      <simpara><emphasis role="bold">DECLARE CURSOR</emphasis></simpara>

      <simpara><emphasis>declare cursor statement</emphasis></simpara>

      <para><literal>&lt;declare cursor&gt; ::= DECLARE &lt;cursor
      name&gt;</literal></para>

      <para><literal>[ { SENSITIVE | INSENSITIVE | ASENSITIVE } ] [ { SCROLL |
      NO SCROLL } ] </literal></para>

      <para><literal>CURSOR [ { WITH HOLD | WITHOUT HOLD } ] [ { WITH RETURN |
      WITHOUT RETURN } ]</literal></para>

      <para><literal>FOR &lt;query expression&gt;</literal></para>

      <para><literal>[ FOR { READ ONLY | UPDATE [ OF &lt;column name list&gt;
      ] } ]</literal></para>

      <para>The query expression is a SELECT statement or similar, and is
      discussed in the rest of this chapter. In the example below a cursor is
      declared for a SELECT statement. It is later opened to create the result
      set. The cursor is specified WITHOUT HOLD, so the result set is not kept
      after a commit. Use WITH HOLD to keep the result set. Note that you need
      to declare the cursor WITH RETURN as it is returned by the
      <classname>CallableStatement</classname>.</para>

      <informalexample>
        <programlisting> DECLARE thiscursor SCROLL CURSOR WITHOUT HOLD WITH RETURN FOR SELECT * FROM INFORMATION_SCHEMA.TABLES;
 --
 OPEN thiscursor;
</programlisting>
      </informalexample>
    </section>
  </section>

  <section xml:id="dac_syntax_elements">
    <title>Syntax Elements</title>

    <para>The syntax elements that can be used in data access and data change
    statements are described in this section. The SQL Standard has a very
    extensive set of definitions for these elements. The BNF definitions given
    here are sometimes simplified.</para>

    <section xml:id="dac_literals">
      <title>Literals</title>

      <para>Literals are used to express constant values. The general type of
      a literal is known by its format. The specific type is based on
      conventions.</para>

      <indexterm significance="preferred" type="sql">
        <primary>unicode escape elements</primary>
      </indexterm>

      <simpara><emphasis role="bold">unicode escape
      elements</emphasis></simpara>

      <simpara><emphasis>unicode escape elements</emphasis></simpara>

      <simpara><literal>&lt;Unicode escape specifier&gt; ::= [ UESCAPE
      &lt;quote&gt;&lt;Unicode escape character&gt;&lt;quote&gt; ]
      </literal></simpara>

      <simpara><literal>&lt;Unicode escape value&gt; ::= &lt;Unicode 4 digit
      escape value&gt; | &lt;Unicode 6 digit escape value&gt; | &lt;Unicode
      character escape value&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 4 digit escape value&gt; ::= &lt;Unicode
      escape
      character&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 6 digit escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;plus sign&gt;
      &lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode character escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;Unicode escape character&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode escape character&gt; ::= a single
      character other than a &lt;hexit&gt; (a-f, A-F, 0-9), &lt;plus sign&gt;,
      &lt;quote&gt;, &lt;double quote&gt;, or &lt;white
      space&gt;</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">character literal</emphasis></simpara>

      <simpara><emphasis>character literal</emphasis></simpara>

      <simpara><literal>&lt;character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ] &lt;quote&gt; [
      &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;introducer&gt; ::=
      &lt;underscore&gt;</literal></simpara>

      <simpara><literal>&lt;character representation&gt; ::= &lt;nonquote
      character&gt; | &lt;quote symbol&gt;</literal></simpara>

      <simpara><literal>&lt;nonquote character&gt; ::= any character apart
      from the quote symbol.</literal></simpara>

      <simpara><literal>&lt;quote symbol&gt; ::=
      &lt;quote&gt;&lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;national character string literal&gt; ::= N
      &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;Unicode character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ]
      U&lt;ampersand&gt;&lt;quote&gt; [ &lt;Unicode representation&gt;... ]
      &lt;quote&gt; [ { &lt;separator&gt; &lt;quote&gt; [ &lt;Unicode
      representation&gt;... ] &lt;quote&gt; }... ] &lt;Unicode escape
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode representation&gt; ::= &lt;character
      representation&gt; | &lt;Unicode escape value&gt;</literal></simpara>

      <simpara>The type of a character literal is CHARACTER. The length of the
      string literal is the character length of the type. If the quote
      character is used in a string, it is represented with two quote
      characters. Long literals can be divided into multiple quoted strings,
      separated with a space or end-of-line character.</simpara>

      <simpara>Unicode literals start with U&amp; and can contain ordinary
      characters and Unicode escapes. A Unicode escape begins with the
      backslash ( \ ) character and is followed by four hexadecimal characters
      which specify the character code. The Unicode escape character can be
      custom defined for a literal string by adding UESPACE as in one of the
      examples below.</simpara>

      <simpara>Example of character literals are given below:</simpara>

      <informalexample>
        <programlisting> 'a literal'  ' string seperated'  ' into parts'
 'a string''s literal form with quote character'
 U&amp;'Unicode string with Greek delta \0394 and phi \03a6 letters'
 U&amp;'Unicode string with forward slash // as custom escape character'UESCAPE'/'
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>binary literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">binary literal</emphasis></simpara>

      <simpara><emphasis>binary literal</emphasis></simpara>

      <simpara><literal>&lt;binary string literal&gt; ::= X &lt;quote&gt; [
      &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;... ] &lt;hexit&gt;
      [ &lt;space&gt;... ] }... ] &lt;quote&gt; [ { &lt;separator&gt;
      &lt;quote&gt; [ &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;...
      ] &lt;hexit&gt; [ &lt;space&gt;... ] }... ] &lt;quote&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;hexit&gt; ::= &lt;digit&gt; | A | B | C | D | E |
      F | a | b | c | d | e | f</literal></simpara>

      <simpara>The type of a binary literal is BINARY. The octet length of the
      binary literal is the length of the type. Case-insensitive hexadecimal
      characters are used in the binary string. Each pair of characters in the
      literal represents a byte in the binary string. Long literals can be
      divided into multiple quoted strings, separated with a space or
      end-of-line character.</simpara>

      <informalexample>
        <programlisting> X'1abACD34' 'Af'</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>bit literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">bit literal</emphasis></simpara>

      <simpara><emphasis>bit literal</emphasis></simpara>

      <simpara><literal>&lt;bit string literal&gt; ::= B &lt;quote&gt; [
      &lt;bit&gt; ... ] &lt;quote&gt; [ { &lt;separator&gt; &lt;quote&gt; [
      &lt;bit&gt;... ] &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;bit&gt; ::= 0 | 1</literal></simpara>

      <simpara>The type of a binary literal is BIT. The bit length of the bit
      literal is the length of the type. Digits 0 and 1 are used to represent
      the bits. Long literals can be divided into multiple quoted strings,
      separated with a space or end-of-line character.</simpara>

      <informalexample>
        <programlisting> B'10001001' '00010'</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>numeric literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric literal</emphasis></simpara>

      <simpara><emphasis>numeric literal</emphasis></simpara>

      <simpara><literal>&lt;signed numeric literal&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned numeric literal&gt; ::= &lt;exact numeric
      literal&gt; | &lt;approximate numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;exact numeric literal&gt; ::= &lt;unsigned
      integer&gt; [ &lt;period&gt; [ &lt;unsigned integer&gt; ] ] |
      &lt;period&gt; &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;sign&gt; ::= &lt;plus sign&gt; | &lt;minus
      sign&gt;</literal></simpara>

      <simpara><literal>&lt;approximate numeric literal&gt; ::=
      &lt;mantissa&gt; E &lt;exponent&gt;</literal></simpara>

      <simpara><literal>&lt;mantissa&gt; ::= &lt;exact numeric
      literal&gt;</literal></simpara>

      <simpara><literal>&lt;exponent&gt; ::= &lt;signed
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;signed integer&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned integer&gt; ::=
      &lt;digit&gt;...</literal></simpara>

      <simpara>The type of an exact numeric literal without a decimal point is
      INTEGER, BIGINT, or DECIMAL, depending on the value of the literal (the
      smallest type that can represent the value is the type).</simpara>

      <simpara>The type of an exact numeric literal with a decimal point is
      DECIMAL. The precision of a decimal literal is the total number of
      digits of the literal. The scale of the literal is the total number of
      digits to the right of the decimal point.</simpara>

      <simpara>The type of an approximate numeric literal is DOUBLE. An
      approximate numeric literal always includes the mantissa and exponent,
      separated by E.</simpara>

      <informalexample>
        <programlisting> 12
 34.35
 +12E-2
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>boolean literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean literal</emphasis></simpara>

      <simpara><emphasis>boolean literal</emphasis></simpara>

      <simpara><literal>&lt;boolean literal&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara>The boolean literal is one of the specified keywords.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime and interval literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime and interval
      literal</emphasis></simpara>

      <simpara><emphasis>datetime and interval literal</emphasis></simpara>

      <simpara><literal>&lt;datetime literal&gt; ::= &lt;date literal&gt; |
      &lt;time literal&gt; | &lt;timestamp literal&gt;</literal></simpara>

      <simpara><literal>&lt;date literal&gt; ::= DATE &lt;date
      string&gt;</literal></simpara>

      <simpara><literal>&lt;time literal&gt; ::= TIME &lt;time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp literal&gt; ::= TIMESTAMP &lt;timestamp
      string&gt;</literal></simpara>

      <simpara><literal>&lt;date string&gt; ::= &lt;quote&gt; &lt;unquoted
      date string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time string&gt; ::= &lt;quote&gt; &lt;unquoted
      time string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp string&gt; ::= &lt;quote&gt;
      &lt;unquoted timestamp string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time zone interval&gt; ::= &lt;sign&gt; &lt;hours
      value&gt; &lt;colon&gt; &lt;minutes value&gt;</literal></simpara>

      <simpara><literal>&lt;date value&gt; ::= &lt;years value&gt; &lt;minus
      sign&gt; &lt;months value&gt; &lt;minus sign&gt; &lt;days
      value&gt;</literal></simpara>

      <simpara><literal>&lt;time value&gt; ::= &lt;hours value&gt;
      &lt;colon&gt; &lt;minutes value&gt; &lt;colon&gt; &lt;seconds
      value&gt;</literal></simpara>

      <simpara><literal>&lt;interval literal&gt; ::= INTERVAL [ &lt;sign&gt; ]
      &lt;interval string&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval string&gt; ::= &lt;quote&gt; &lt;unquoted
      interval string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted date string&gt; ::= &lt;date
      value&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted time string&gt; ::= &lt;time value&gt; [
      &lt;time zone interval&gt; ]</literal></simpara>

      <simpara><literal>&lt;unquoted timestamp string&gt; ::= &lt;unquoted
      date string&gt; &lt;space&gt; &lt;unquoted time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted interval string&gt; ::= [ &lt;sign&gt; ]
      { &lt;year-month literal&gt; | &lt;day-time literal&gt;
      }</literal></simpara>

      <simpara><literal>&lt;year-month literal&gt; ::= &lt;years value&gt; [
      &lt;minus sign&gt; &lt;months value&gt; ] | &lt;months
      value&gt;</literal></simpara>

      <simpara><literal>&lt;day-time literal&gt; ::= &lt;day-time interval&gt;
      | &lt;time interval&gt;</literal></simpara>

      <simpara><literal>&lt;day-time interval&gt; ::= &lt;days value&gt; [
      &lt;space&gt; &lt;hours value&gt; [ &lt;colon&gt; &lt;minutes value&gt;
      [ &lt;colon&gt; &lt;seconds value&gt; ] ] ]</literal></simpara>

      <simpara><literal>&lt;time interval&gt; ::= &lt;hours value&gt; [
      &lt;colon&gt; &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] ] | &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] | &lt;seconds value&gt;</literal></simpara>

      <simpara><literal>&lt;years value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;months value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;days value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;hours value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;minutes value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;seconds value&gt; ::= &lt;seconds integer
      value&gt; [ &lt;period&gt; [ &lt;seconds fraction&gt; ]
      ]</literal></simpara>

      <simpara><literal>&lt;seconds integer value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;seconds fraction&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;datetime value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara>The type of a datetime or interval type is specified in the
      literal. The fractional second precision is the number of digits in the
      fractional part of the literal. Details are described in the <link
      endterm="sqlgeneral-title" xlink:href="#sqlgeneral-chapt"/>
      chapter</simpara>

      <informalexample>
        <programlisting> DATE '2008-08-08'
 TIME '20:08:08'
 TIMESTAMP '2008-08-08 20:08:08.235'

 INTERVAL '10' DAY
 INTERVAL -'08:08' MINUTE TO SECOND
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_sql_references">
      <title>References, etc.</title>

      <para>References are identifier chains, which can be a single
      identifiers or identifiers chains composed of single identifiers chained
      together with the period symbol.</para>

      <indexterm significance="preferred" type="sql">
        <primary>identifier chain</primary>
      </indexterm>

      <simpara><emphasis role="bold">identifier chain</emphasis></simpara>

      <simpara><emphasis>identifier chain</emphasis></simpara>

      <simpara><literal>&lt;identifier chain&gt; ::= &lt;identifier&gt; [ {
      &lt;period&gt; &lt;identifier&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;basic identifier chain&gt; ::= &lt;identifier
      chain&gt;</literal></simpara>

      <simpara>A period-separated chain of identifiers. The identifiers in an
      identifier chain can refer to database objects in a hierarchy. The
      possible hierarchies are as follows. In each hierarchy, elements from
      the start or the end can be missing, but the order of elements cannot be
      changed.</simpara>

      <simpara>catalog, schema, database object</simpara>

      <simpara>catalog, schema, table, column</simpara>

      <simpara>correlation name, column</simpara>

      <simpara>Examples of identifier chain are given below:</simpara>

      <informalexample>
        <programlisting> SELECT MYCATALOG.MYSCHEMA.MYTABLE.MYCOL FROM MYCATALOG.MYSCHEMA.MYTABLE
 DROP TABLE MYCATALOG.MYSCHEMA.MYTABLE CASCADE
 ALTER SEQUENCE MYCATALOG.MYSCHEMA.MYSEQUENCE RESTART WITH 100
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>column reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">column reference</emphasis></simpara>

      <simpara><emphasis>column reference</emphasis></simpara>

      <simpara><literal>&lt;column reference&gt; ::= &lt;basic identifier
      chain&gt; | MODULE &lt;period&gt; &lt;qualified identifier&gt;
      &lt;period&gt; &lt;column name&gt;</literal></simpara>

      <simpara>Reference a column or a routine variable.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SQL parameter reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">SQL parameter
      reference</emphasis></simpara>

      <simpara><emphasis>SQL parameter reference</emphasis></simpara>

      <simpara><literal>&lt;SQL parameter reference&gt; ::= &lt;basic
      identifier chain&gt;</literal></simpara>

      <simpara>Reference an SQL routine parameter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>contextually typed value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">contextually typed value
      specification</emphasis></simpara>

      <simpara><emphasis>contextually typed value
      specification</emphasis></simpara>

      <simpara><literal>&lt;contextually typed value specification&gt; ::=
      &lt;null specification&gt; | &lt;default
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;null specification&gt; ::=
      NULL</literal></simpara>

      <simpara><literal>&lt;default specification&gt; ::=
      DEFAULT</literal></simpara>

      <simpara>Specify a value whose data type or value is inferred from its
      context.</simpara>

      <simpara>DEFAULT is used for assignments to table columns that have a
      default value, or to table columns that are generated either as an
      IDENTITY value or as an expression.</simpara>

      <simpara>NULL can be used only in a context where the type of the value
      is known. For example, a NULL can be assigned to a column of the table
      in an INSERT or UPDATE statement, because the type of the column is
      known. But if NULL is used in a SELECT list, it must be used in a CAST
      statement.</simpara>
    </section>

    <section xml:id="dac_value_expression">
      <title>Value Expression</title>

      <para>Value expression is a general name for all expressions that return
      a value. Different types of expressions are allowed in different
      contexts.</para>

      <indexterm significance="preferred" type="sql">
        <primary>value expression primary</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression
      primary</emphasis></simpara>

      <simpara><emphasis>value expression primary</emphasis></simpara>

      <simpara><literal>&lt;value expression primary&gt; ::= &lt;parenthesized
      value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized value expression&gt; ::= &lt;left
      paren&gt; &lt;value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;nonparenthesized value expression primary&gt; ::=
      &lt;unsigned value specification&gt; | &lt;column reference&gt; |
      &lt;set function specification&gt; | &lt;scalar subquery&gt; | &lt;case
      expression&gt; | &lt;cast specification&gt; | &lt;next value
      expression&gt; | &lt;current value expression&gt; | &lt;routine
      invocation&gt;</literal></simpara>

      <simpara>Specify a value that is syntactically self-delimited.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">value specification</emphasis></simpara>

      <simpara><emphasis>value specification</emphasis></simpara>

      <simpara><literal>&lt;value specification&gt; ::= &lt;literal&gt; |
      &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned value specification&gt; ::= &lt;unsigned
      literal&gt; | &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;target specification&gt; ::= &lt;host parameter
      specification&gt; | &lt;SQL parameter reference&gt; | &lt;column
      reference&gt; | &lt;dynamic parameter
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;simple target specification&gt; ::= &lt;host
      parameter specification&gt; | &lt;SQL parameter reference&gt; |
      &lt;column reference&gt; | &lt;embedded variable
      name&gt;</literal></simpara>

      <simpara><literal>&lt;host parameter specification&gt; ::= &lt;host
      parameter name&gt; [ &lt;indicator parameter&gt; ]</literal></simpara>

      <simpara><literal>&lt;dynamic parameter specification&gt; ::=
      &lt;question mark&gt;</literal></simpara>

      <simpara>Specify one or more values, host parameters, SQL parameters,
      dynamic parameters, or host variables.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>row value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">row value expression</emphasis></simpara>

      <simpara><emphasis>row value expression</emphasis></simpara>

      <simpara><literal>&lt;row value expression&gt; ::= &lt;row value special
      case&gt; | &lt;explicit row value constructor&gt; </literal></simpara>

      <simpara><literal>&lt;row value predicand&gt; ::= &lt;row value special
      case&gt; | &lt;row value constructor predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value special case&gt; ::=
      &lt;nonparenthesized value expression primary&gt;</literal></simpara>

      <simpara><literal>&lt;explicit row value constructor&gt; ::= &lt;left
      paren&gt; &lt;row value constructor element&gt; &lt;comma&gt; &lt;row
      value constructor element list&gt; &lt;right paren&gt;
      |</literal></simpara>

      <simpara><literal> ROW &lt;left paren&gt; &lt;row value constructor
      element list&gt; &lt;right paren&gt; | &lt;row
      subquery&gt;</literal></simpara>

      <simpara>Specify a row consisting of one or more elements. A comma
      separated list of expressions, enclosed in brackets, with the optional
      keyword ROW. In SQL, a row containing a single element can often be used
      where a single value is expected.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>set function specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">set function
      specification</emphasis></simpara>

      <simpara><emphasis>set function specification</emphasis></simpara>

      <simpara><literal>&lt;set function specification&gt; ::= &lt;aggregate
      function&gt; | &lt;grouping operation&gt;</literal></simpara>

      <simpara><literal>&lt;grouping operation&gt; ::= GROUPING &lt;left
      paren&gt; &lt;column reference&gt; [ { &lt;comma&gt; &lt;column
      reference&gt; }... ] &lt;right paren&gt;</literal></simpara>

      <simpara>Specify an integer value formed by bits denoting the presence
      of the column in the current row of the result of GROUPING SETS.
      HyperSQL supports <literal>&lt;grouping operation&gt;</literal> from
      version 2.5.1.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>COALESCE expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">COALESCE</emphasis></simpara>

      <simpara><emphasis>coalesce expression</emphasis></simpara>

      <simpara><literal>&lt;coalesce expression&gt; := COALESCE &lt;left
      paren&gt; &lt;value expression&gt; { &lt;comma&gt; &lt;value
      expression&gt; }... &lt;right paren&gt;</literal></simpara>

      <simpara>Replace null values with another value. The coalesce expression
      has two or more instances of &lt;value expression&gt;. If the first
      &lt;value expression&gt; evaluates to a non-null value, it is returned
      as the result of the coalesce expression. If it is null, the next
      <literal>&lt;value expression&gt;</literal> is evaluated and if it
      evaluates to a non-non value, it is returned, and so on.</simpara>

      <simpara>The type of the return value of a COALESCE expression is the
      aggregate type of the types of all the <literal>&lt;value
      expression&gt;</literal> instances. Therefore, any value returned is
      implicitly cast to this type. HyperSQL also features built-in functions
      with similar functionality.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">NULLIF</emphasis></simpara>

      <simpara><emphasis>nullif expression</emphasis></simpara>

      <simpara><literal>&lt;nullif expression&gt; := NULLIF &lt;left paren&gt;
      &lt;value expression&gt; &lt;comma&gt; &lt;value expression&gt;
      &lt;right paren&gt;</literal></simpara>

      <simpara>Return NULL if two values are equal. If the result of the first
      <literal>&lt;value expression&gt;</literal> is not equal to the result
      of the second, then it is returned, otherwise NULL is returned. The type
      of the return value is the type of the first <literal>&lt;value
      expression&gt;</literal>.</simpara>

      <informalexample>
        <programlisting> SELECT i, NULLIF(n, 'not defined') FROM t</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>case expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">CASE</emphasis></simpara>

      <simpara><emphasis>case specification</emphasis></simpara>

      <simpara><literal>&lt;case specification&gt; ::= &lt;simple case&gt; |
      &lt;searched case&gt;</literal></simpara>

      <simpara><literal>&lt;simple case&gt; ::= CASE &lt;case operand&gt;
      &lt;simple when clause&gt;... [ &lt;else clause&gt; ]
      END</literal></simpara>

      <simpara><literal>&lt;searched case&gt; ::= CASE &lt;searched when
      clause&gt;... [ &lt;else clause&gt; ] END</literal></simpara>

      <simpara><literal>&lt;simple when clause&gt; ::= WHEN &lt;when operand
      list&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;searched when clause&gt; ::= WHEN &lt;search
      condition&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;else clause&gt; ::= ELSE
      &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;case operand&gt; ::= &lt;row value predicand&gt; |
      &lt;overlaps predicate part 1&gt;</literal></simpara>

      <simpara><literal>&lt;when operand list&gt; ::= &lt;when operand&gt; [ {
      &lt;comma&gt; &lt;when operand&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;when operand&gt; ::= &lt;row value predicand&gt; |
      &lt;comparison predicate part 2&gt; | &lt;between predicate part 2&gt; |
      &lt;in predicate part 2&gt; | &lt;character like predicate part 2&gt; |
      &lt;octet like predicate part 2&gt; | &lt;similar predicate part 2&gt; |
      &lt;regex like predicate part 2&gt; | &lt;null predicate part 2&gt; |
      &lt;quantified comparison predicate part 2&gt; | &lt;match predicate
      part 2&gt; | &lt;overlaps predicate part 2&gt; | &lt;distinct predicate
      part 2&gt;</literal></simpara>

      <simpara><literal>&lt;result&gt; ::= &lt;result expression&gt; |
      NULL</literal></simpara>

      <simpara><literal>&lt;result expression&gt; ::= &lt;value
      expression&gt;</literal></simpara>

      <simpara>Specify a conditional value. The result of a case expression is
      always a value. All the values introduced with THEN must be of the same
      type or convertible to the same type. The WHEN clause of CASE can be
      used in two different forms. The first form starts with a variable and
      the WHEN clauses follow, either as possible values for the variable, or
      as conditions. The second form does not start with a variable and each
      WHEN is followed by a self-contained conditional expression which can
      use any variables.</simpara>

      <simpara>Some simple examples of the CASE expression are given below.
      The first two examples return 'Britain', 'Germany', or 'Other country'
      depending on the value of dial code. The third example uses IN and
      smaller-than predicates.</simpara>

      <informalexample>
        <programlisting> CASE dialcode WHEN 44 THEN 'Britain' WHEN 49 THEN 'Germany' ELSE 'Other country' END
 CASE WHEN dialcode=44 THEN 'Britain' WHEN dialcode=49 THEN 'Germany' WHEN dialcode &lt; 0 THEN 'bad dial code' ELSE 'Other country' END
 CASE dialcode WHEN IN (44,49,30) THEN 'Europe' WHEN IN (86,91,92) THEN 'Asia' WHEN &lt; 0 THEN 'bad dial code' ELSE 'Other continent' END
</programlisting>
      </informalexample>

      <simpara>The case statement can be far more complex and involve several
      conditions.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CAST</primary>
      </indexterm>

      <simpara><emphasis role="bold">CAST</emphasis></simpara>

      <simpara><emphasis>cast specification</emphasis></simpara>

      <simpara><literal>&lt;cast specification&gt; ::= CAST &lt;left paren&gt;
      &lt;cast operand&gt; AS &lt;cast target&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;cast operand&gt; ::= &lt;value expression&gt; |
      &lt;implicitly typed value specification&gt;</literal></simpara>

      <simpara><literal>&lt;cast target&gt; ::= &lt;domain name&gt; | &lt;data
      type&gt;</literal></simpara>

      <simpara>Specify a data conversion. Data conversion takes place
      automatically among variants of a general type. For example, numeric
      values are freely converted from one type to another in
      expressions.</simpara>

      <simpara>Explicit type conversion is necessary in two cases. One case is
      to determine the type of a NULL value. The other case is to force
      conversion for special purposes. Values of data types can be cast to a
      character type. The exception is BINARY and OTHER types. The result of
      the cast is the literal expression of the value. Conversely, a value of
      a character type can be converted to another type if the character value
      is a literal representation of the value in the target type. Special
      conversions are possible between numeric and interval types, which are
      described in the section covering interval types.</simpara>

      <simpara>The examples below show examples of cast with their
      result:</simpara>

      <informalexample>
        <programlisting> CAST (NULL AS TIMESTAMP)
 CAST ('   199  ' AS INTEGER) = 199
 CAST ('tRue ' AS BOOLEAN) = TRUE
 CAST (INTERVAL '2' DAY AS INTEGER) = 2
 CAST ('1992-04-21' AS DATE) = DATE '1992-04-21'
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>NEXT VALUE FOR</primary>
      </indexterm>

      <simpara><emphasis role="bold">NEXT VALUE FOR</emphasis></simpara>

      <simpara><emphasis>next value expression</emphasis></simpara>

      <simpara><literal>&lt;next value expression&gt; ::= NEXT VALUE FOR
      &lt;sequence generator name&gt;</literal></simpara>

      <simpara>Return the next value of a sequence generator. This expression
      can be used as a select list element in queries, or in assignments to
      table columns in data change statements. If the expression is used more
      than once in a single row that is being evaluated, the same value is
      returned for each invocation. After evaluation of the particular row is
      complete, the sequence generator will return a different value from the
      old value. The new value is generated by the sequence generator by
      adding the increment to the last value it generated. In SQL syntax
      compatibility modes, variants of this expression in different SQL
      dialects are supported. In the example below the expression is used in
      an insert statement:</simpara>

      <informalexample>
        <programlisting>INSERT INTO MYTABLE(COL1, COL2) VALUES 2, NEXT VALUE FOR MYSEQUENCE
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>CURRENT VALUE FOR</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURRENT VALUE FOR</emphasis></simpara>

      <simpara><emphasis>current value expression</emphasis></simpara>

      <simpara><literal>&lt;current value expression&gt; ::= CURRENT VALUE FOR
      &lt;sequence generator name&gt;</literal></simpara>

      <simpara>Return the latest value that was returned by the NEXT VALUE FOR
      expression for a sequence generator in this session. In the example
      below, the value that was generated by the sequence for the first
      insert, is reused for the second insert:</simpara>

      <informalexample>
        <programlisting> INSERT INTO MYTABLE(COL1, COL2) VALUES 2, NEXT VALUE FOR MYSEQUENCE;
 INSERT INTO CHILDTABLE(COL1, COL2) VALUES 10, CURRENT VALUE FOR MYSEQUENCE;
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression</emphasis></simpara>

      <simpara><emphasis>value expression</emphasis></simpara>

      <simpara><literal>&lt;value expression&gt; ::= &lt;numeric value
      expression&gt; | &lt;string value expression&gt; | &lt;datetime value
      expression&gt; | &lt;interval value expression&gt; | &lt;boolean value
      expression&gt; | &lt;row value expression&gt;</literal></simpara>

      <simpara>An expression that returns a value. The value can be a single
      value, or a row consisting more than one value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      expression</emphasis></simpara>

      <simpara><emphasis>numeric value expression</emphasis></simpara>

      <simpara><literal>&lt;numeric value expression&gt; ::= &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;plus sign&gt; &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;minus sign&gt;
      &lt;term&gt;</literal></simpara>

      <simpara><literal>&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;factor&gt; | &lt;term&gt; &lt;solidus&gt;
      &lt;factor&gt;</literal></simpara>

      <simpara><literal>&lt;factor&gt; ::= [ &lt;sign&gt; ] &lt;numeric
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;numeric primary&gt; ::= &lt;value expression
      primary&gt; | &lt;numeric value function&gt;</literal></simpara>

      <simpara>Specify a numeric value. The BNF indicates that
      <literal>&lt;asterisk&gt;</literal> and
      <literal>&lt;solidus&gt;</literal> (the operators for multiplication and
      division) have precedence over <literal>&lt;minus sign&gt;</literal> and
      <literal>&lt;plus sign&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      function</emphasis></simpara>

      <simpara><emphasis>numeric value function</emphasis></simpara>

      <simpara><literal>&lt;numeric value function&gt; ::= &lt;position
      expression&gt; | &lt;extract expression&gt; | &lt;length expression&gt;
      ...</literal></simpara>

      <simpara>Specify a function yielding a value of type numeric. The
      supported numeric value functions are listed and described in the <link
      endterm="builtinfunctions-title" xlink:href="#builtinfunctions-chapt"/>
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>string value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">string value
      expression</emphasis></simpara>

      <simpara><emphasis>string value expression</emphasis></simpara>

      <simpara><literal>&lt;string value expression&gt; ::= &lt;string
      concatenation&gt; | &lt;string factor&gt;</literal></simpara>

      <simpara><literal>&lt;string factor&gt; ::= &lt;value expression
      primary&gt; | &lt;string value function&gt;</literal></simpara>

      <simpara><literal>&lt;string concatenation&gt; ::= &lt;string value
      expression&gt; &lt;concatenation operator&gt; &lt;string
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;concatenation operator&gt; ::=
      ||</literal></simpara>

      <simpara>Specify a character string value, a binary string value, or a
      bit string value. The BNF indicates that a string value expression can
      be formed by concatenation of two or more <literal>&lt;value expression
      primary&gt;</literal>. The types of the <literal>&lt;value expression
      primary&gt;</literal> elements must be compatible, that is, all must be
      string, or binary or bit string values.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">character value
      function</emphasis></simpara>

      <simpara><emphasis>string value function</emphasis></simpara>

      <simpara><literal>&lt;string value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function that returns a character string or binary
      string. The supported character value functions are listed and described
      in the <link endterm="builtinfunctions-title"
      xlink:href="#builtinfunctions-chapt"/> chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime value
      expression</emphasis></simpara>

      <simpara><emphasis>datetime value expression</emphasis></simpara>

      <simpara><literal>&lt;datetime value expression&gt; ::= &lt;datetime
      term&gt; | &lt;interval value expression&gt; &lt;plus sign&gt;
      &lt;datetime term&gt; | &lt;datetime value expression&gt; &lt;plus
      sign&gt; &lt;interval term&gt; | &lt;datetime value expression&gt;
      &lt;minus sign&gt; &lt;interval term&gt;</literal></simpara>

      <simpara><literal>&lt;datetime term&gt; ::= &lt;datetime
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;datetime factor&gt; ::= &lt;datetime primary&gt; [
      &lt;time zone&gt; ]</literal></simpara>

      <simpara><literal>&lt;datetime primary&gt; ::= &lt;value expression
      primary&gt; | &lt;datetime value function&gt;</literal></simpara>

      <simpara><literal>&lt;time zone&gt; ::= AT &lt;time zone
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;time zone specifier&gt; ::= LOCAL | TIME ZONE
      &lt;interval primary&gt;</literal></simpara>

      <simpara>Specify a datetime value. Details are described in the <link
      endterm="sqlgeneral-title" xlink:href="#sqlgeneral-chapt"/>
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime value
      function</emphasis></simpara>

      <simpara><emphasis>datetime value function</emphasis></simpara>

      <simpara><literal>&lt;datetime value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function that returns a datetime value. The supported
      datetime value functions are listed and described in the <link
      endterm="builtinfunctions-title" xlink:arcrole=""
      xlink:href="#builtinfunctions-chapt"/> chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval term</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval term</emphasis></simpara>

      <simpara><emphasis>interval value expression</emphasis></simpara>

      <simpara><literal>&lt;interval value expression&gt; ::= &lt;interval
      term&gt; | &lt;interval value expression 1&gt; &lt;plus sign&gt;
      &lt;interval term 1&gt; | &lt;interval value expression 1&gt; &lt;minus
      sign&gt; &lt;interval term 1&gt; | &lt;left paren&gt; &lt;datetime value
      expression&gt; &lt;minus sign&gt; &lt;datetime term&gt; &lt;right
      paren&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval term&gt; ::= &lt;interval factor&gt; |
      &lt;interval term 2&gt; &lt;asterisk&gt; &lt;factor&gt; | &lt;interval
      term 2&gt; &lt;solidus&gt; &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;interval factor&gt;</literal></simpara>

      <simpara><literal>&lt;interval factor&gt; ::= [ &lt;sign&gt; ]
      &lt;interval primary&gt;</literal></simpara>

      <simpara><literal>&lt;interval primary&gt; ::= &lt;value expression
      primary&gt; [ &lt;interval qualifier&gt; ] | &lt;interval value
      function&gt;</literal></simpara>

      <simpara><literal>&lt;interval value expression 1&gt; ::= &lt;interval
      value expression&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 1&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 2&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara>Specify an interval value. Details are described in the <link
      endterm="sqlgeneral-title" xlink:href="#sqlgeneral-chapt"/>
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval absolute value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval absolute value
      function</emphasis></simpara>

      <simpara><emphasis>interval value function</emphasis></simpara>

      <simpara><literal>&lt;interval value function&gt; ::= &lt;interval
      absolute value function&gt;</literal></simpara>

      <simpara><literal>&lt;interval absolute value function&gt; ::= ABS
      &lt;left paren&gt; &lt;interval value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a function that returns the absolute value of an
      interval. If the interval is negative, it is negated, otherwise the
      original value is returned.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>boolean value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean value
      expression</emphasis></simpara>

      <simpara><emphasis>boolean value expression</emphasis></simpara>

      <simpara><literal>&lt;boolean value expression&gt; ::= &lt;boolean
      term&gt; | &lt;boolean value expression&gt; OR &lt;boolean
      term&gt;</literal></simpara>

      <simpara><literal>&lt;boolean term&gt; ::= &lt;boolean factor&gt; |
      &lt;boolean term&gt; AND &lt;boolean factor&gt;</literal></simpara>

      <simpara><literal>&lt;boolean factor&gt; ::= [ NOT ] &lt;boolean
      test&gt;</literal></simpara>

      <simpara><literal>&lt;boolean test&gt; ::= &lt;boolean primary&gt; [ IS
      [ NOT ] &lt;truth value&gt; ]</literal></simpara>

      <simpara><literal>&lt;truth value&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara><literal>&lt;boolean primary&gt; ::= &lt;predicate&gt; |
      &lt;boolean predicand&gt;</literal></simpara>

      <simpara><literal>&lt;boolean predicand&gt; ::= &lt;parenthesized
      boolean value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized boolean value expression&gt; ::=
      &lt;left paren&gt; &lt;boolean value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a boolean value.</simpara>
    </section>

    <section xml:id="dac_sql_predicates">
      <title>Predicates</title>

      <simpara>Predicates are conditions and evaluate to a boolean value. Some
      predicates have two sides. The left side of the predicate, the
      <literal>&lt;row value predicand&gt;</literal>, is the common element of
      all two-sided predicates. This element is a generalisation of both
      <literal>&lt;value expression&gt;</literal>, which is a scalar, and of
      <literal>&lt;explicit row value constructor&gt;</literal>, which is a
      row. The two sides of a predicate can be split in CASE expressions where
      the <literal>&lt;row value predicand&gt;</literal> is part of multiple
      predicates.</simpara>

      <simpara>In the following example, a column of the table is the left
      side of two predicates in a CASE expression.</simpara>

      <informalexample>
        <programlisting>SELECT CASE city WHEN 'Oslo' THEN 'Scandinavia' WHEN IN ('Dallas', 'Boston') THEN 'America' ELSE '?' END FROM customer
</programlisting>
      </informalexample>

      <simpara>The number of fields in all <literal>&lt;row value
      predicand&gt;</literal> used in predicates must be the same and the
      types of the fields in the same position must be compatible for
      comparison. If either of these conditions does not hold, an exception is
      raised. The number of fields in a row is called the
      <glossterm>degree</glossterm>.</simpara>

      <simpara>In many types of predicates (but not all of them), if the
      <literal>&lt;row value predicand&gt;</literal> evaluates to NULL, the
      result of the predicate is UNKNOWN. If the <literal>&lt;row value
      predicand&gt;</literal> has more than one element, and one or more of
      the fields evaluate to NULL, the result depends on the particular
      predicate.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>comparison predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">comparison predicand</emphasis></simpara>

      <simpara><emphasis>comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;comparison predicate&gt; ::= &lt;row value
      predicand&gt; &lt;comp op&gt; &lt;row value
      predicand&gt;</literal></simpara>

      <simpara><literal>&lt;comp op&gt; ::= &lt;equals operator&gt; | &lt;not
      equals operator&gt; | &lt;less than operator&gt; | &lt;greater than
      operator&gt; | &lt;less than or equals operator&gt; | &lt;greater than
      or equals operator&gt;</literal></simpara>

      <simpara>Specify a comparison of two row values. If either
      <literal>&lt;row value predicand&gt;</literal> evaluates to NULL, the
      result of <literal>&lt;comparison predicate&gt;</literal> is UNKNOWN.
      Otherwise, the result is TRUE, FALSE or UNKNOWN.</simpara>

      <simpara>If the <glossterm>degree</glossterm> of <literal>&lt;row value
      predicand&gt;</literal> is larger than one, comparison is performed
      between each field and the corresponding field in the other
      <literal>&lt;row value predicand&gt;</literal> from left to right, one
      by one.</simpara>

      <simpara>When comparing two elements, if either field is NULL then the
      result is UNKNOWN.</simpara>

      <simpara>For <literal>&lt;equals operator&gt;</literal>, if the result
      of comparison is TRUE for all field, the result of the predicate is
      TRUE. If the result of comparison is FALSE for one field, the result of
      predicate is FALSE. Otherwise the result is UNKNOWN.</simpara>

      <simpara>The <literal>&lt;not equals operator&gt;</literal> is
      translated to <literal>NOT (&lt;row value predicand&gt; = &lt;row value
      predicand&gt;)</literal>.</simpara>

      <simpara>The <literal>&lt;less than or equals operator&gt;</literal> is
      translated to <literal>(&lt;row value predicand&gt; = &lt;row value
      predicand&gt;) OR (&lt;row value predicand&gt; &lt; &lt;row value
      predicand&gt;)</literal>. The <literal>&lt;greater than or equals
      operator&gt;</literal> is translated similarly.</simpara>

      <simpara>For the <literal>&lt;less than operator&gt;</literal> and
      <literal>&lt;greater than operator&gt;</literal>, if two fields at a
      given position are equal, then comparison continues to the next field.
      Otherwise, the result of the last performed comparison is returned as
      the result of the predicate. This means that if the first field is NULL,
      the result is always UNKNOWN.</simpara>

      <simpara>The logic that governs NULL values and UNKNOWN result is as
      follows: Suppose the NULL values were substituted by arbitrary real
      values. If substitution cannot change the result of the predicate, then
      the result is TRUE or FALSE, based on the existing non-NULL values,
      otherwise the result of the predicate is UNKNOWN.</simpara>

      <simpara>The examples of comparison given below use literals, but the
      literals actually represent the result of evaluation of some
      expression.</simpara>

      <informalexample>
        <programlisting> ((1, 2, 3, 4) = (1, 2, 3, 4)) IS TRUE
 ((1, 2, 3, 4) = (1, 2, 3, 5)) IS FALSE
 ((1, 2, 3, 4) &lt; (1, 2, 3, 4)) IS FALSE
 ((1, 2, 3, 4) &lt; (1, 2, 3, 5)) IS TRUE
 ((NULL, 1, NULL) = (NULL, 1, NULL)) IS UNKNOWN  
 ((NULL, 1, NULL) = (NULL, 2, NULL)) IS FALSE  
 ((NULL, 1, NULL) &lt;&gt; (NULL, 2, NULL)) IS TRUE  
 ((NULL, 1, 2) &lt;all operators&gt; (NULL, 1, 2)) IS UNKNOWN
 ((1, NULL, ...) &lt; (1, 2, ...)) IS UNKNOWN  
 ((1, NULL, ...) &lt; (2, NULL, ...)) IS TRUE
 ((2, NULL, ...) &lt; (1, NULL, ...)) IS FALSE
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>BETWEEN predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">BETWEEN</emphasis></simpara>

      <simpara><emphasis>between predicate</emphasis></simpara>

      <simpara><literal>&lt;between predicate&gt; ::= &lt;row value
      predicand&gt; &lt;between predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;between predicate part 2&gt; ::= [ NOT ] BETWEEN [
      ASYMMETRIC | SYMMETRIC ] &lt;row value predicand&gt; AND &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a range comparison. The default is ASYMMETRIC. The
      expression <literal>X BETWEEN Y AND Z</literal> is equivalent to
      <literal>(X &gt;= Y AND X &lt;= Z)</literal>. Therefore, if Y &gt; Z,
      the BETWEEN expression is never true. The expression <literal>X BETWEEN
      SYMMETRIC Y AND Z</literal> is equivalent to <literal>(X &gt;= Y AND X
      &lt;= Z) OR (X &gt;= Z AND X &lt;= Y)</literal>. The expression
      <literal>Z NOT BETWEEN ...</literal> is equivalent to <literal>NOT (Z
      BETWEEN ...)</literal>. If any of the three <literal>&lt;row value
      predicand&gt;</literal> evaluates to NULL, the result is
      UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IN predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IN</emphasis></simpara>

      <simpara><emphasis>in predicate</emphasis></simpara>

      <simpara><literal>&lt;in predicate&gt; ::= &lt;row value predicand&gt; [
      NOT ] IN &lt;in predicate value&gt;</literal></simpara>

      <simpara><literal>&lt;in predicate value&gt; ::= &lt;table subquery&gt;
      | &lt;left paren&gt; &lt;in value list&gt; &lt;right paren&gt;
      </literal></simpara>

      <simpara><literal>| &lt;left paren&gt; UNNEST &lt;left paren&gt;
      &lt;array value expression&gt; &lt;right paren&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;in value list&gt; ::= &lt;row value expression&gt;
      [ { &lt;comma&gt; &lt;row value expression&gt; }...
      ]</literal></simpara>

      <simpara>Specify a quantified comparison. The expression <literal>X NOT
      IN Y is</literal> equivalent to <literal>NOT (X IN Y)</literal>. The
      <literal>( &lt;in value list&gt; )</literal> is converted into a table
      with one or more rows. The expression <literal>X IN Y</literal> is
      equivalent to <literal>X = ANY Y</literal>, which is a
      <literal>&lt;quantified comparison predicate&gt;</literal>.</simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, the result is FALSE. Otherwise the <literal>&lt;row value
      predicand&gt;</literal> is compared one by one with each row of the
      <literal>&lt;table subquery&gt;</literal>.</simpara>

      <simpara>If the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN.</simpara>

      <simpara>HyperSQL supports an extension to the SQL Standard to allow an
      array to be used in the &lt;in predicate value&gt;. This is intended to
      be used with prepared statements where a variable length array of values
      can be used as the parameter value for each call. The example below
      shows how this is used in SQL. The JDBC code must create a new
      <literal>java.sql.Array</literal> object that contains the values and
      set the parameter with this array.</simpara>

      <informalexample>
        <programlisting> SELECT * FROM customer WHERE firstname IN ( UNNEST(?) )

 Connection conn;
 PreparedStatement ps;
 // conn and ps are instantiated here
 Array arr = conn.createArrayOf("INTEGER", new Integer[] {1, 2, 3});
 ps.setArray(1, arr);
 ResultSet rs = ps.executeQuery();
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>LIKE predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">LIKE</emphasis></simpara>

      <simpara><emphasis>like predicate</emphasis></simpara>

      <simpara><literal>&lt;like predicate&gt; ::= &lt;character like
      predicate&gt; | &lt;octet like predicate&gt;</literal></simpara>

      <simpara><literal>&lt;character like predicate&gt; ::= &lt;row value
      predicand&gt; [ NOT ] LIKE &lt;character pattern&gt; [ ESCAPE &lt;escape
      character&gt; ]</literal></simpara>

      <simpara><literal>&lt;character pattern&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape character&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;octet like predicate&gt; ::= &lt;row value
      predicand&gt; [ NOT ] LIKE &lt;octet pattern&gt; [ ESCAPE &lt;escape
      octet&gt; ]</literal></simpara>

      <simpara><literal>&lt;octet pattern&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape octet&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara>Specify a pattern-match comparison for character or binary
      strings. The <literal>&lt;row value predicand&gt;</literal> is always a
      <literal>&lt;string value expression&gt;</literal> of character or
      binary type. The <literal>&lt;character pattern&gt;</literal> or
      <literal>&lt;octet pattern&gt;</literal> is a <literal>&lt;string value
      expression&gt;</literal> in which the underscore and percent characters
      have special meanings. The underscore means match any one character,
      while the percent means match a sequence of zero or more characters. The
      <literal>&lt;escape character&gt;</literal> or <literal>&lt;escape
      octet&gt;</literal> is also a <literal>&lt;string value
      expression&gt;</literal> that evaluates to a string of exactly one
      character length. If the underscore or the percent is required as normal
      characters in the pattern, the specified <literal>&lt;escape
      character&gt;</literal> or <literal>&lt;escape octet&gt;</literal> can
      be used in the pattern before the underscore or the percent. The
      <literal>&lt;row value predicand&gt;</literal> is compared with the
      <literal>&lt;character pattern&gt;</literal> and the result of
      comparison is returned. If any of the expressions in the predicate
      evaluates to NULL, the result of the predicate is UNKNOWN. The
      expression <literal>A NOT LIKE B</literal> is equivalent to <literal>NOT
      (A LIKE B)</literal>. If the length of the escape is not 1 or it is used
      in the pattern not immediately before an underscore or a percent
      character, an exception is raised.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IS NULL predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IS NULL</emphasis></simpara>

      <simpara><emphasis>null predicate</emphasis></simpara>

      <simpara><literal>&lt;null predicate&gt; ::= &lt;row value predicand&gt;
      IS [ NOT ] NULL</literal></simpara>

      <simpara>Specify a test for a null value. The expression <literal>X IS
      NOT NULL</literal> is NOT equivalent to <literal>NOT (X IS
      NULL)</literal>if the degree of the <literal>&lt;row value
      predicand&gt;</literal> is larger than 1. The rules are: If all fields
      are null, <literal>X IS NULL</literal> is TRUE and <literal>X IS NOT
      NULL</literal> is FALSE. If only some fields are null, both <literal>X
      IS NULL</literal> and <literal>X IS NOT NULL</literal> are FALSE. If all
      fields are not null, <literal>X IS NULL</literal> is FALSE and
      <literal>X IS NOT NULL</literal> is TRUE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALL and ANY predicates</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALL and ANY</emphasis></simpara>

      <simpara><emphasis>quantified comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;quantified comparison predicate&gt; ::= &lt;row
      value predicand&gt; &lt;comp op&gt; &lt;quantifier&gt; &lt;table
      subquery&gt;</literal></simpara>

      <simpara><literal>&lt;quantifier&gt; ::= &lt;all&gt; |
      &lt;some&gt;</literal></simpara>

      <simpara><literal>&lt;all&gt; ::= ALL</literal></simpara>

      <simpara><literal>&lt;some&gt; ::= SOME | ANY</literal></simpara>

      <simpara>Specify a quantified comparison. For a quantified comparison,
      the <literal>&lt;row value predicand&gt;</literal> is compared one by
      one with each row of the <literal>&lt;table sub
      query&gt;</literal>.</simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, then if <literal>ALL</literal> is specified the result is TRUE,
      but if <literal>SOME</literal> or <literal>ANY</literal> is specified
      the result is FALSE.</simpara>

      <simpara>If <literal>ALL</literal> is specified, if the comparison is
      TRUE for all rows, the result of the predicate is TRUE. If the
      comparison is FALSE for at least one row, the result is FALSE. Otherwise
      the result is UNKNOWN.</simpara>

      <simpara>If <literal>SOME</literal> or <literal>ANY</literal> is
      specified, if the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN. Note that the IN predicate is
      equivalent to the SOME or ANY predicate using the <literal>&lt;equals
      operator&gt;</literal>.</simpara>

      <simpara>In the examples below, the date of an invoice is compared to
      holidays in a given year. In the first example the invoice date must
      equal one of the holidays, in the second example it must be later than
      all holidays (later than the last holiday), in the third example it must
      be on or after some holiday (on or after the first holiday), and in the
      fourth example, it must be before all holidays (before the first
      holiday).</simpara>

      <informalexample>
        <programlisting> invoice_date = SOME (SELECT holiday_date FROM holidays)
 invoice_date &gt; ALL (SELECT holiday_date FROM holidays)
 invoice_date &gt;= ANY (SELECT holiday_date FROM holidays)
 invoice_date &lt; ALL (SELECT holiday_date FROM holidays)
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>EXISTS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">EXISTS</emphasis></simpara>

      <simpara><emphasis>exists predicate</emphasis></simpara>

      <simpara><literal>&lt;exists predicate&gt; ::= EXISTS &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for a non-empty set. If the evaluation of
      <literal>&lt;table subquery&gt;</literal> results in one or more rows,
      then the expression is TRUE, otherwise FALSE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>UNIQUE predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

      <simpara><emphasis>unique predicate</emphasis></simpara>

      <simpara><literal>&lt;unique predicate&gt; ::= UNIQUE &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for the absence of duplicate rows. The result of
      the test is either TRUE or FALSE (never UNKNOWN). The rows of the
      <literal>&lt;table subquery&gt;</literal> that contain one or more NULL
      values are not considered for this test. If the rest of the rows are
      distinct from each other, the result of the test is TRUE, otherwise it
      is FALSE. The distinctness of rows X and Y is tested with the predicate
      <literal>X IS DISTINCT FROM Y</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>MATCH predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">MATCH</emphasis></simpara>

      <simpara><emphasis>match predicate</emphasis></simpara>

      <simpara><literal>&lt;match predicate&gt; ::= &lt;row value
      predicand&gt; MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for matching rows. The default is MATCH SIMPLE
      without UNIQUE. The result of the test is either TRUE or FALSE (never
      UNKNOWN).</simpara>

      <simpara>The interpretation of NULL values is different from other
      predicates and quite counter-intuitive. If the <literal>&lt;row value
      predicand&gt;</literal> is NULL, or all of its fields are NULL, the
      result is TRUE.</simpara>

      <simpara>Otherwise, the <literal>&lt;row value predicand&gt;</literal>
      is compared with each row of the <literal>&lt;table
      subquery&gt;</literal>.</simpara>

      <simpara>If SIMPLE is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is TRUE. Otherwise if
      <literal>&lt;row value predicate&gt; </literal>is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches. Otherwise the result is FALSE.</simpara>

      <simpara>If PARTIAL is specified, if the non-null values
      <literal>&lt;row value predicate&gt; </literal>are equal to those in one
      or more rows of <literal>&lt;table subquery&gt;</literal> the result is
      TRUE if UNIQUE is not specified, or if UNIQUE is specified and only one
      row matches. Otherwise the result is FALSE.</simpara>

      <simpara>If FULL is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is FALSE. Otherwise if
      <literal>&lt;row value predicate&gt;</literal> is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches.</simpara>

      <simpara>Note that MATCH can also be used in FOREIGN KEY constraint
      definitions. The exact meaning is described in the <link
      endterm="databaseobjects-title" xlink:href="#databaseobjects-chapt"/>
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CONTAINS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">CONTAINS</emphasis></simpara>

      <simpara><emphasis>contains predicate</emphasis></simpara>

      <simpara><literal>&lt;contains predicate&gt; ::= PERIOD &lt;row value
      predicand&gt; CONTAINS PERIOD &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for two datetime periods. Each <literal>&lt;row
      value predicand&gt;</literal> must have two fields and the fields
      together represent a datetime period. So the predicates is always in the
      form <literal>PERIOD (X1, X2) CONTAINS PERIOD (Y1, Y2)</literal>. Fields
      in each period are always a datetime value of the same type (DATE or
      TIMESTAMP).</simpara>

      <simpara>All datetime values are converted to TIMESTAMP WITH TIME ZONE.
      The second datetime value must be after the first, otherwise a data
      error is returned.</simpara>

      <simpara>If the second period is fully within the first period, the
      result is TRUE. Otherwise it is false.</simpara>

      <simpara>If any of the values is NULL, the result is
      UNDEFINED.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>EQUALS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">EQUALS</emphasis></simpara>

      <simpara><emphasis>equals predicate</emphasis></simpara>

      <simpara><literal>&lt;equals predicate&gt; ::= PERIOD &lt;row value
      predicand&gt; EQUALS PERIOD &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for two datetime periods. The conversions and
      checks are applied the same way as with the CONTAINS predicate. If the
      two periods have the same begin and end datetime values the result is
      TRUE. Otherwise it is false.</simpara>

      <simpara>If any of the values is NULL, the result is
      UNDEFINED.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IS DISTINCT predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IS DISTINCT</emphasis></simpara>

      <simpara><emphasis>is distinct predicate</emphasis></simpara>

      <simpara><literal>&lt;distinct predicate&gt; ::= &lt;row value
      predicand&gt; IS [ NOT ] DISTINCT FROM &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test of whether two row values are distinct. The
      result of the test is either TRUE or FALSE (never UNKNOWN). The
      <glossterm>degree</glossterm> the two <literal>&lt;row value
      predicand&gt;</literal> must be the same. Each field of the first
      <literal>&lt;row value predicand&gt;</literal> is compared to the field
      of the second <literal>&lt;row value predicand&gt;</literal> at the same
      position. If one field is NULL and the other is not NULL, or if the
      elements are NOT equal, then the result of the expression is TRUE. If no
      comparison result is TRUE, then the result of the predicate is FALSE.
      The expression <literal>X IS NOT DISTINCT FROM Y</literal> is equivalent
      to <literal>NOT (X IS DISTINCT FORM Y)</literal>. The following check
      returns true if startdate is not equal to enddate. It also returns true
      if either startdate or enddate is NULL. It returns false in other
      cases.</simpara>

      <informalexample>
        <programlisting> startdate IS DISTINCT FROM enddate</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>OVERLAPS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">OVERLAPS</emphasis></simpara>

      <simpara><emphasis>overlaps predicate</emphasis></simpara>

      <simpara><literal>&lt;overlaps predicate&gt; ::= &lt;row value
      predicand&gt; OVERLAPS &lt;row value predicand&gt;</literal></simpara>

      <simpara><literal>&lt;overlaps predicate&gt; ::= PERIOD &lt;row value
      predicand&gt; OVERLAPS PERIOD &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>The OVERLAPS predicate tests for an overlap between two
      datetime periods. This predicate has two forms. The one without the
      PERIOD keywords is more relaxed in terms of valid periods.</simpara>

      <simpara>If there is there is any overlap between the two datetime
      periods, the result is TRUE. Otherwise it is false.</simpara>

      <simpara>If any of the values is NULL, the result is
      UNDEFINED.</simpara>

      <simpara>In the example below, the period is compared with a week long
      period ending yesterday.</simpara>

      <informalexample>
        <programlisting> (startdate, enddate) OVERLAPS (CURRENT_DATE - 7 DAY, CURRENT_DATE - 1 DAY)</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>PRECEDES predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">PRECEDES</emphasis></simpara>

      <simpara><emphasis>precedes predicate</emphasis></simpara>

      <simpara><literal>&lt;precedes predicate&gt; ::= PERIOD &lt;row value
      predicand&gt; [ IMMEDIATELY] PRECEDES PERIOD &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for two datetime periods. The conversions and
      checks are applied the same way as with the CONTAINS predicate. If the
      second period begins after the end of the first period, the result is
      TRUE. Otherwise it is false.</simpara>

      <simpara>If IMMEDIATELY is specified, the second period must follow
      immediately after the end of the first period. This means the end of the
      first period is the same point of time as the start of the second
      period.</simpara>

      <simpara>If any of the values is NULL, the result is
      UNDEFINED.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SUCCEEDS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">SUCCEEDS</emphasis></simpara>

      <simpara><emphasis>succeeds predicate</emphasis></simpara>

      <simpara><literal>&lt;succeeds predicate&gt; ::= PERIOD &lt;row value
      predicand&gt; [ IMMEDIATELY ] SUCCEEDS PEDIOD &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for two datetime periods with similar syntax to
      PRECEDES. If the first period begins after the end of the second period,
      the result is TRUE. Otherwise it is false.</simpara>

      <simpara>If IMMEDIATELY is specified, the first period must follow
      immediately after the end of the second period.</simpara>

      <simpara>If any of the values is NULL, the result is UNKNOWN.</simpara>

      <simpara>The example below shows a predicate that returns
      TRUE.</simpara>

      <informalexample>
        <programlisting>PERIOD (CURRENT_DATE - 7 DAY, CURRENT_DATE) IMMEDIATELY PRECEDES (CURRENT_DATE, CURRENT_DATE + 7 DAY)</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_aggregate_funcs">
      <title>Aggregate Functions</title>

      <indexterm significance="preferred" type="sql">
        <primary>aggregate function</primary>
      </indexterm>

      <simpara><emphasis role="bold">aggregate function</emphasis></simpara>

      <simpara><emphasis>aggregate function</emphasis></simpara>

      <simpara><literal>&lt;aggregate function&gt; ::= COUNT &lt;left
      paren&gt; &lt;asterisk&gt; &lt;right paren&gt; [ &lt;filter clause&gt; ]
      | &lt;general set function&gt; [ &lt;filter clause&gt; ] | &lt;array
      aggregate function&gt; [ &lt;filter clause&gt; ]</literal></simpara>

      <simpara><literal>&lt;general set function&gt; ::= &lt;set function
      type&gt; &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value
      expression&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;set function type&gt; ::= &lt;computational
      operation&gt;</literal></simpara>

      <simpara><literal>&lt;computational operation&gt; ::= AVG | MAX | MIN |
      SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP |
      VAR_POP | MEDIAN</literal></simpara>

      <simpara><literal>&lt;set quantifier&gt; ::= DISTINCT |
      ALL</literal></simpara>

      <simpara><literal>&lt;filter clause&gt; ::= FILTER &lt;left paren&gt;
      WHERE &lt;search condition&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;array aggregate function&gt; ::= ARRAY_AGG
      &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value expression&gt; [
      &lt;order by clause&gt; ] &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;group concat function&gt; ::= GROUP_CONCAT
      &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value expression&gt; [
      &lt;order by clause&gt; ] [ SEPARATOR &lt;separator&gt; ] &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;separator&gt; ::= &lt;character string
      literal&gt;</literal></simpara>

      <simpara>Specify a value computed from a collection of rows.</simpara>

      <simpara>An aggregate function is used exclusively in a
      <literal>&lt;query specification&gt;</literal> and its use transforms a
      normal query into an aggregate query returning a single row instead of
      the multiple rows that the original query returns. For example,
      <literal>SELECT acolumn &lt;table expression&gt;</literal> is a query
      that returns the value of acolumn for all the rows the satisfy the given
      condition. But <literal>SELECT MAX(acolumn) &lt;table
      expression&gt;</literal> returns only one row, containing the largest
      value in that column. The query <literal>SELECT COUNT(*) &lt;table
      expression&gt;</literal> returns the count of rows, while
      <literal>SELECT COUNT(acolumn) &lt;table expression&gt;</literal>
      returns the count of rows where <literal>acolumn IS NOT
      NULL</literal>.</simpara>

      <simpara>If the <literal>&lt;table expression&gt;</literal> is a grouped
      table (has a <code>GROUP BY</code> clause), the aggregate function
      returns the result of the <literal>COUNT</literal> or
      <literal>&lt;computational operation&gt;</literal> for each group. In
      this case the result has the same number of rows as the original grouped
      query. For example, <literal>SELECT SUM(acolumn) &lt;table
      expression&gt;</literal> when <literal>&lt;table
      expression&gt;</literal> has a <literal>GROUP BY</literal> clause,
      returns the sum of values for <literal>acolumn</literal> in each
      group.</simpara>

      <simpara>If all values are NULL, the aggregate function (except COUNT)
      returns NULL.</simpara>

      <simpara>The SUM operations can be performed on numeric and interval
      expressions only. AVG and MEDIAN can be performed on numeric, interval
      or datetime expressions. AVG returns the average value, while SUM
      returns the sum of all values. MEDIAN returns the middle value in the
      sorted list of values.</simpara>

      <simpara>MAX and MIN can be performed on all types of expressions and
      return the minimum or the maximum value.</simpara>

      <simpara><literal>COUNT(*)</literal> returns the count of all values,
      including nulls, while <literal>COUNT(&lt;value
      expression&gt;)</literal> returns the count of non-NULL values. COUNT
      with DISTINCT also accepts multiple arguments. In this usage the
      distinct combinations of the arguments are counted. Examples
      below:</simpara>

      <informalexample>
        <programlisting> SELECT COUNT(DISTINCT firstname, lastname) FROM customer
 SELECT COUNT(DISTINCT (firstname, lastname)) FROM customer
</programlisting>
      </informalexample>

      <simpara>The EVERY, ANY and SOME operations can be performed on boolean
      expressions only. EVERY returns TRUE if all the values are TRUE,
      otherwise FALSE. ANY and SOME are the same operation and return TRUE if
      one of the values is TRUE, otherwise it returns FALSE.</simpara>

      <simpara>The other operations perform the statistical functions
      STDDEV_POP, STDDEV_SAMP, VAR_SAMP, VAR_POP on numeric values. NULL
      values are ignored in calculations.</simpara>

      <simpara>User-defined aggregate functions can be defined and used
      instead of the built-in aggregate functions. Syntax and examples are
      given in the <link endterm="sqlroutines-title"
      xlink:href="#sqlroutines-chapt"/> chapter.</simpara>

      <simpara>The <code>&lt;filter clause&gt;</code> allows you to add a
      search condition. When the search condition evaluates to TRUE for a row,
      the row is included in aggregation. Otherwise the row is not included.
      In the example below a single query returns two different filtered
      counts:</simpara>

      <informalexample>
        <programlisting> SELECT COUNT(ITEM) FILTER (WHERE GENDER = 'F') AS "FEMALE COUNT", COUNT(ITEM) FILTER (WHERE GENDER = 'M') AS "MALE COUNT" FROM PEOPLE
</programlisting>
      </informalexample>

      <simpara>ARRAY_AGG is different from all other aggregate functions, as
      it does not ignore the NULL values. This set function returns an array
      that contains all the values, for different rows, for the
      <literal>&lt;value expression&gt;</literal>. For example, if the
      <literal>&lt;value expression&gt;</literal> is a column reference, the
      SUM function adds the values for all the row together, while the
      ARRAY_AGG function adds the value for each row as a separate element of
      the array. ARRAY_AGG can include an optional <literal>&lt;order by
      clause&gt;</literal>. If this is used, the elements of the returned
      array are sorted according to the <literal>&lt;order by
      clause&gt;</literal>, which can reference all the available columns of
      the query, not just the <literal>&lt;value expression&gt;</literal> that
      is used as the ARRAY_AGG argument. The <literal>&lt;order by
      clause&gt;</literal> can have multiple elements (columns) and each
      element can include NULLS LAST or DESC qualifiers. No
      <literal>&lt;separator&gt;</literal> is used with this
      function.</simpara>

      <simpara>GROUP_CONCAT is a specialised function derived from ARRAY_AGG.
      This function computes the array in the same way as ARRAY_AGG, removes
      all the NULL elements, then returns a string that is a concatenation of
      the elements of the array. If <literal>&lt;separator&gt;</literal> has
      been specified, it is used to separate the elements of the array.
      Otherwise the comma is used to separate the elements.</simpara>

      <simpara>The example below shows a grouped query with ARRAY_AGG and
      GROUP_CONCAT. The CUSTOMER table that is included for tests in the
      DatabaseManager GUI app is the source of the data.</simpara>

      <informalexample>
        <programlisting> SELECT LASTNAME, ARRAY_AGG(FIRSTNAME ORDER BY FIRSTNAME) FROM Customer GROUP BY LASTNAME

 LASTNAME  C2                                                         
 --------- ---------------------------------------------------------- 
 Steel     ARRAY['John','John','Laura','Robert']                      
 King      ARRAY['George','George','James','Julia','Robert','Robert'] 
 Sommer    ARRAY['Janet','Robert']                                    

 SELECT LASTNAME, GROUP_CONCAT(DISTINCT FIRSTNAME ORDER BY FIRSTNAME DESC SEPARATOR ' * ') FROM Customer  GROUP BY LASTNAME

 LASTNAME  C2                                                
 --------- ------------------------------------------------- 
 Steel     Robert * Laura * John                   
 King      Robert * Julia * James * George         
 Sommer    Robert * Janet</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_other_syntax_elements">
      <title>Other Syntax Elements</title>

      <indexterm significance="preferred" type="sql">
        <primary>search condition</primary>
      </indexterm>

      <simpara><emphasis role="bold">search condition</emphasis></simpara>

      <simpara><emphasis>search condition</emphasis></simpara>

      <simpara><literal>&lt;search condition&gt; ::= &lt;boolean value
      expression&gt;</literal></simpara>

      <simpara>Specify a condition that is TRUE, FALSE, or UNKNOWN. A search
      condition is often a predicate.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>PATH</primary>
      </indexterm>

      <simpara><emphasis role="bold">PATH</emphasis></simpara>

      <simpara><emphasis>path specification</emphasis></simpara>

      <simpara><literal>&lt;path specification&gt; ::= PATH &lt;schema name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;schema name list&gt; ::= &lt;schema name&gt; [ {
      &lt;comma&gt; &lt;schema name&gt; }... ]</literal></simpara>

      <simpara>Specify an order for searching for a user-defined SQL-invoked
      routine. This is not currently supported by HyperSQL.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>routine invocation</primary>
      </indexterm>

      <simpara><emphasis role="bold">routine invocation</emphasis></simpara>

      <simpara><emphasis>routine invocation</emphasis></simpara>

      <simpara><literal>&lt;routine invocation&gt; ::= &lt;routine name&gt;
      &lt;SQL argument list&gt;</literal></simpara>

      <simpara><literal>&lt;routine name&gt; ::= [ &lt;schema name&gt;
      &lt;period&gt; ] &lt;qualified identifier&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument list&gt; ::= &lt;left paren&gt; [
      &lt;SQL argument&gt; [ { &lt;comma&gt; &lt;SQL argument&gt; }... ] ]
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument&gt; ::= &lt;value expression&gt; |
      &lt;target specification&gt;</literal></simpara>

      <simpara>Invoke an SQL-invoked routine. Examples are given in the <link
      endterm="sqlroutines-title" xlink:href="#sqlroutines-chapt"/>
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>COLLATE</primary>
      </indexterm>

      <simpara><emphasis role="bold">COLLATE</emphasis></simpara>

      <simpara><emphasis>collate clause</emphasis></simpara>

      <simpara><literal>&lt;collate clause&gt; ::= COLLATE &lt;collation
      name&gt;</literal></simpara>

      <simpara>Specify a collation for a column or for an ORDER BY expression.
      This collation is used for comparing the values of the column in
      different rows. Comparison can happen during the execution of SELECT,
      UPDATE or DELETE statements, when a UNIQUE constraint or index is
      defined on the column, or when the rows are sorted by an ORDER BY
      clause.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>constraint name definition</emphasis></simpara>

      <simpara><literal>&lt;constraint name definition&gt; ::= CONSTRAINT
      &lt;constraint name&gt;</literal></simpara>

      <simpara><literal>&lt;constraint characteristics&gt; ::= &lt;constraint
      check time&gt; [ [ NOT ] DEFERRABLE ] | [ NOT ] DEFERRABLE [
      &lt;constraint check time&gt; ]</literal></simpara>

      <simpara><literal>&lt;constraint check time&gt; ::= INITIALLY DEFERRED |
      INITIALLY IMMEDIATE</literal></simpara>

      <simpara>Specify the name of a constraint and its characteristics. This
      is an optional element of CONSTRAINT definition, not yet supported by
      HyperSQL.</simpara>
    </section>
  </section>

  <section xml:id="dac_data_access_statements">
    <title>Data Access Statements</title>

    <para>HyperSQL fully supports all of SQL-92 data access statements, plus
    most of the additions from SQL:2011. Due to time constraints, the current
    version of this Guide does not cover the subject fully. You are advised to
    consult an SQL book such as the O'Reilly title, "SQL and Relational
    Theory" by C. J. Date.</para>

    <para>Database queries are data access statements. The most commonly used
    data access statement is the SELECT statement, but there are other
    statements that perform a similar role. Data access statements access
    tables and return result tables. The returned result tables are falsely
    called result sets, as they are not necessarily sets of rows, but
    multisets of rows.</para>

    <para>Result tables are formed by performing the following operations on
    base tables and views. These operations are loosely based on Relational
    Algebra.</para>

    <para><glossterm>JOIN</glossterm> operations</para>

    <para><glossterm>SET</glossterm> and <glossterm>MULTISET</glossterm>
    operations</para>

    <para><glossterm>SELECTION</glossterm></para>

    <para><glossterm>PROJECTION</glossterm></para>

    <para><glossterm>COMPUTING</glossterm></para>

    <para><glossterm>COLUMN NAMING</glossterm></para>

    <para><glossterm>GROUPING</glossterm> and
    <glossterm>AGGREGATION</glossterm></para>

    <para><glossterm>SELECTION AFTER GROUPING OR
    AGGREGATION</glossterm></para>

    <para><glossterm>SET and MULTISET (COLLECTION)
    OPERATIONS</glossterm></para>

    <para><glossterm>ORDERING</glossterm></para>

    <para><glossterm>SLICING</glossterm></para>

    <para>Conceptually, the operations are performed one by one in the above
    order if they apply to the given data access statement. In the example
    below a simple select statement is made more complex by adding various
    operations.</para>

    <para><informalexample>
        <programlisting> CREATE TABLE atable (a INT, b INT, c INT, d INT, e INT, f INT);
 /* in the next SELECT, no join is performed and no further operation takes place */
 SELECT * FROM atable
 /* in the next SELECT, selection is performed by the WHERE clause, with no further action */
 SELECT * FROM atable WHERE a + b = c
 /* in the next SELECT, projection is performed after the other operations */
 SELECT d, e, f FROM atable WHERE a + b = c
 /* in the next SELECT, computation is performed after projection */
 SELECT (d + e) / f FROM atable WHERE a + b = c
 /* in the next two SELECT statements, column naming is performed in different ways*/
 SELECT (a + e) / f AS calc, f AS div FROM atable WHERE a + b = c
 SELECT dcol, ecol, fcol FROM atable(acol, bcol, ccol, dcol, ecol, fcol) WHERE acol + bcol = ccol
 /* in the next SELECT, both grouping and aggregation is performed */
 SELECT d, e, SUM(f) FROM atable GROUP BY d, e
 /* in the next SELECT, selection is performed after grouping and aggregation is performed */
 SELECT d, e, SUM(f) FROM atable GROUP BY d, e HAVING SUM(f) &gt; 10
 /* in the next SELECT, a UNION is performed on two selects from the same table */
 SELECT d, e, f FROM atable WHERE d = 3 UNION SELECT a, b, c FROM atable WHERE a = 30
 /* in the next SELECT, ordering is performed */
 SELECT (a + e) / f AS calc, f AS div FROM atable WHERE a + b = c ORDER BY calc DESC, div NULLS LAST
 /* in the next SELECT, slicing is performed after ordering */
 SELECT * FROM atable WHERE a + b = c ORDER BY a FETCH 5 ROWS ONLY

</programlisting>
      </informalexample>The following sections discuss various types of tables
    and operations involved in data access statements.</para>

    <section xml:id="dac_sql_select_statement">
      <title>Select Statement</title>

      <para>The SELECT statement itself does not cover all types of data
      access statements, which may combine multiple SELECT statements. The
      <literal>&lt;query specification&gt;</literal> is the most common data
      access statement and begins with the SELECT keyword.</para>

      <indexterm significance="preferred" type="sql">
        <primary>SELECT</primary>
      </indexterm>

      <simpara><emphasis role="bold">SELECT STATEMENT</emphasis></simpara>

      <simpara><emphasis>select statement (general)</emphasis></simpara>

      <para>Users generally refer to the SELECT statement when they mean a
      <literal>&lt;query specification&gt;</literal> or <literal>&lt;query
      expression&gt;</literal>. If a statement begins with SELECT and has no
      UNION or other set operations, then it is a <literal>&lt;query
      specification&gt;</literal>. Otherwise it is a <literal>&lt;query
      expression&gt;</literal>.</para>
    </section>

    <section xml:id="dac_table">
      <title>Table</title>

      <para>In data access statements, a table can be a database table (or
      view) or an ephemeral table formed for the duration of the query. Some
      types of table are <literal>&lt;table primary&gt;</literal> and can
      participate in joins without the use of extra parentheses. The BNF in
      the Table Primary section below lists different types of &lt;table
      primary&gt;:</para>

      <para>Tables can also be formed by specifying the values that are
      contained in them:</para>

      <simpara><literal>&lt;table value constructor&gt; ::= VALUES &lt;row
      value expression list&gt;</literal></simpara>

      <simpara><literal>&lt;row value expression list&gt; ::= &lt;table row
      value expression&gt; [ { &lt;comma&gt; &lt;table row value
      expression&gt; }... ]</literal></simpara>

      <simpara>In the example below a table with two rows and 3 columns is
      constructed out of some values:</simpara>

      <informalexample>
        <programlisting> VALUES (12, 14, null), (10, 11, CURRENT_DATE)</programlisting>
      </informalexample>

      <simpara>When a table is used directly in a UNION or similar operation,
      the keyword TABLE is used with the name:</simpara>

      <simpara><literal>&lt;explicit table&gt; ::= TABLE &lt;table or query
      name&gt;</literal></simpara>

      <simpara>In the examples below, all rows of the two tables are included
      in the union. The keyword TABLE is used in the first example. The two
      examples below are equivalent.</simpara>

      <informalexample>
        <programlisting> TABLE atable UNION TABLE anothertable
 SELECT * FROM atable UNION SELECT * FROM anothertable
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_subquery">
      <title>Subquery</title>

      <para>A subquery is simply a query expression in brackets. A query
      expression is usually a complete SELECT statement and is discussed in
      the rest of this chapter. A scalar subquery returns one row with one
      column. A row subquery returns one row with one or more columns. A table
      subquery returns zero or more rows with one or more columns. The
      distinction between different forms of subquery is syntactic. Different
      forms are allowed in different contexts. If a scalar subquery or a row
      subquery return more than one row, an exception is raised. If a scalar
      or row subquery returns no row, it is usually treated as returning a
      NULL. Depending on the context, this has different consequences.</para>

      <para><literal>&lt;scalar subquery&gt; ::= &lt;subquery&gt;
      </literal></para>

      <para><literal>&lt;row subquery&gt; ::= &lt;subquery&gt;
      </literal></para>

      <para><literal>&lt;table subquery&gt; ::= &lt;subquery&gt;
      </literal></para>

      <para><literal>&lt;subquery&gt; ::= &lt;left paren&gt; &lt;query
      expression&gt; &lt;right paren&gt;</literal></para>
    </section>

    <section xml:id="dac_query_specification">
      <title>Query Specification</title>

      <para>A query specification is also known as a SELECT statement. It is
      the most common form of <literal>&lt;derived table&gt;</literal> . A
      <literal>&lt;table expression&gt;</literal> is a base table, a view or
      any form of allowed derived table. The SELECT statement performs
      projection, naming, computing, or aggregation on the rows of the
      <literal>&lt;table expression&gt;</literal> .</para>

      <simpara><literal>&lt;query specification&gt; ::= SELECT [ DISTINCT |
      ALL ] &lt;select list&gt; &lt;table expression&gt;</literal></simpara>

      <simpara><literal>&lt;select list&gt; ::= &lt;asterisk&gt; | &lt;select
      sublist&gt; [ { &lt;comma&gt; &lt;select sublist&gt; }... ]
      </literal></simpara>

      <simpara><literal>&lt;select sublist&gt; ::= &lt;derived column&gt; |
      &lt;qualified asterisk&gt; </literal></simpara>

      <simpara><literal>&lt;qualified asterisk&gt; ::= &lt;asterisked
      identifier chain&gt; &lt;period&gt; &lt;asterisk&gt;</literal></simpara>

      <simpara><literal>&lt;asterisked identifier chain&gt; ::= &lt;asterisked
      identifier&gt; [ { &lt;period&gt; &lt;asterisked identifier&gt; }... ]
      </literal></simpara>

      <simpara><literal>&lt;asterisked identifier&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;derived column&gt; ::= &lt;value expression&gt; [
      &lt;as clause&gt; ] </literal></simpara>

      <simpara><literal>&lt;as clause&gt; ::= [ AS ] &lt;column name&gt;
      </literal></simpara>

      <para>The qualifier DISTINCT or ALL apply to the results of the SELECT
      statement after all other operations have been performed. ALL simply
      returns the rows, while DISTINCT compares the rows and removes the
      duplicate ones.</para>

      <para>Projection is performed by the <literal>&lt;select
      list&gt;</literal>.</para>

      <para>A single <literal>&lt;asterisk&gt;</literal> means all columns of
      the <literal>&lt;table expression&gt;</literal> are included, in the
      same order as they appear in the <literal>&lt;table
      expression&gt;</literal>. An asterisk qualified by a table name means
      all the columns of the qualifier table name are included. If an
      unqualified asterisk is used, then no other items are allowed in the
      <literal>&lt;select list&gt;</literal>. When the <literal>&lt;table
      expression&gt;</literal> is the direct result of NATURAL or USING joins,
      the use of <literal>&lt;asterisk&gt;</literal> includes the columns used
      for the join before the other columns. A qualified asterisk does not
      cover the join columns.</para>

      <para>A derived column is a <literal>&lt;value expression&gt;</literal>,
      optionally named with the <literal>&lt;as clause&gt;</literal>. A
      <literal>&lt;value expression&gt;</literal> can be many things. Common
      types include: the name of a column in the <literal>&lt;table
      expression&gt;</literal>; an expression based on different columns or
      constant values; a function call; an aggregate function; a CASE WHEN
      expression.</para>
    </section>

    <section xml:id="dac_table_expression">
      <title>Table Expression</title>

      <para>A table expression is part of the SELECT statement and consists of
      the FROM clause with optional other clauses that performs selection (of
      rows) and grouping from the table(s) in the FROM clause.</para>

      <simpara><literal>&lt;table expression&gt; ::= &lt;from clause&gt; [
      &lt;where clause&gt; ] [ &lt;group by clause&gt; ] [ &lt;having
      clause&gt; ]</literal></simpara>

      <para><literal>&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ {
      &lt;comma&gt; &lt;table reference&gt; }... ]</literal></para>

      <simpara><literal>&lt;table reference&gt; ::= &lt;table primary&gt; |
      &lt;joined table&gt; </literal></simpara>

      <simpara><literal>&lt;table primary&gt; ::= &lt;table or query name&gt;
      [ &lt;query system time period specification&gt; ] [ [ AS ]
      &lt;correlation name&gt; [ &lt;left paren&gt; &lt;derived column
      list&gt; &lt;right paren&gt; ] ] </literal></simpara>

      <simpara><literal>| &lt;derived table&gt; [ AS ] &lt;correlation
      name&gt; [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right
      paren&gt; ] </literal></simpara>

      <simpara><literal>| &lt;lateral derived table&gt; [ AS ] &lt;correlation
      name&gt; [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right
      paren&gt; ] </literal></simpara>

      <simpara><literal>| &lt;collection derived table&gt; [ AS ]
      &lt;correlation name&gt; [ &lt;left paren&gt; &lt;derived column
      list&gt; &lt;right paren&gt; ] </literal></simpara>

      <simpara><literal>| &lt;table function derived table&gt; [ AS ]
      &lt;correlation name&gt; [ &lt;left paren&gt; &lt;derived column
      list&gt; &lt;right paren&gt; ] </literal></simpara>

      <simpara><literal>| &lt;parenthesized joined table&gt; [ AS ]
      &lt;correlation name&gt; [ &lt;left paren&gt; &lt;derived column
      list&gt; &lt;right paren&gt; ] </literal></simpara>

      <simpara><literal>&lt;where clause&gt; ::= WHERE &lt;boolean value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;group by clause&gt; ::= GROUP BY [ &lt;set
      quantifier&gt; ] &lt;grouping element&gt; [ { &lt;comma&gt; &lt;grouping
      element&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;having clause&gt; ::= HAVING &lt;boolean value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;query system time period specification&gt; ::= FOR
      SYSTEM_TIME AS OF &lt;point in time 1&gt;</literal></simpara>

      <simpara><literal>| FOR SYSTEM_TIME BETWEEN [ SYMMETRIC ] &lt;point in
      time 1&gt; AND &lt;point in time 2&gt; </literal></simpara>

      <simpara><literal>| FOR SYSTEM_TIME FROM &lt;point in time 1&gt; TO
      &lt;point in time 2&gt;</literal></simpara>

      <para>The <literal>&lt;from clause&gt;</literal> contains one or more
      <literal>&lt;table reference&gt;</literal> separated by commas. A table
      reference is often a table or view name or a joined table.</para>

      <para>The <literal>&lt;where clause&gt;</literal> filters the rows of
      the table in the &lt;from clause&gt; and removes the rows for which the
      search condition is not TRUE.</para>

      <para>Table primary refers to different forms of table reference in the
      FROM clause.</para>

      <section xml:id="dac_table_primary">
        <title>Table or Query Name</title>

        <para>The simplest form of reference is simply a name. This is the
        name of a table, a view, a transition table in a trigger definition,
        or a query name specified in the WITH clause of a query
        expression.</para>

        <para><literal>&lt;table or query name&gt; ::= &lt;table name&gt; |
        &lt;transition table name&gt; | &lt;query name&gt;</literal></para>
      </section>

      <section>
        <title>System Time Period</title>

        <para>The <literal>&lt;query system time period
        specification&gt;</literal> can be used after the name of a
        system-versioned table to query historic data in the table. Without
        this clause, only the current rows of the table are returned and
        historic rows are ignored. The first example below shows a list of
        customers as of a year ago. The second example also shows any changes
        made to the email column over the previous year.</para>

        <informalexample>
          <programlisting>SELECT firstname, lastname, email FROM customer FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP - 1 YEAR

SELECT DISTINCT firstname, lastname, email FROM customer FOR SYSTEM_TIME FROM CURRENT_TIMESTAMP - 2 YEAR TO CURRENT_TIMESTAMP - 1 YEAR
</programlisting>
        </informalexample>
      </section>

      <section xml:id="dac_derived_table">
        <title>Derived Table</title>

        <indexterm significance="preferred" type="sql">
          <primary>derived table</primary>
        </indexterm>

        <simpara><emphasis role="bold">derived table</emphasis></simpara>

        <para>A query expression that is enclosed in parentheses and returns
        from zero to many rows is a <literal>&lt;table subquery&gt;</literal>.
        In a <literal>&lt;derived table&gt;</literal> the query expression is
        self contained and cannot reference the columns of other table
        references. This is the traditional and most common form of use of a
        <literal>&lt;table subquery&gt;</literal>.</para>

        <para><literal>&lt;derived table&gt; ::= &lt;table
        subquery&gt;</literal></para>
      </section>

      <section xml:id="dac_lateral">
        <title>Lateral</title>

        <indexterm significance="preferred" type="sql">
          <primary>LATERAL</primary>
        </indexterm>

        <simpara><emphasis role="bold">LATERAL</emphasis></simpara>

        <para>When the word LATERAL is used before a <literal>&lt;table
        subquery&gt;</literal>, it means the query expression can reference
        the columns of other table references that go before it.</para>

        <para><literal>&lt;lateral derived table&gt; ::= LATERAL &lt;table
        subquery&gt;</literal></para>

        <para>The use of <literal>&lt;lateral derived table&gt;</literal>
        completely transforms the way a query is written. For example, the two
        queries below are equivalent, but with different forms. The query with
        LATERAL is evaluated separately for each row of the first table that
        satisfies the WHERE condition. The example below uses the tables that
        are created and populated in DatabaseManagerSwing with the "Insert
        test data" menu option. The first query uses a scalar subquery to
        compute the sum of invoice values for each customer. The second query
        is equivalent and uses a join with a LATERAL table.</para>

        <informalexample>
          <programlisting>SELECT firstname, lastname, (SELECT SUM(total) FROM invoice WHERE customerid = customer.id) s FROM customer

SELECT firstname, lastname, a.c FROM customer, LATERAL(SELECT SUM(total) FROM invoice WHERE customerid = customer.id) a (c)
</programlisting>
        </informalexample>
      </section>

      <section xml:id="dac_unnest">
        <title>UNNEST</title>

        <indexterm significance="preferred" type="sql">
          <primary>UNNEST</primary>
        </indexterm>

        <simpara><emphasis role="bold">UNNEST</emphasis></simpara>

        <para>UNNEST is similar to LATERAL, but instead of a query expression,
        one or more expressions that return an array are used. These
        expressions are converted into a table which has one column for each
        expression and contains the elements of the array. If WITH ORDINALITY
        is used, an extra column that contains the index of each element is
        added to this table. The number of rows in the table equals the length
        of the largest arrays. The smaller arrays are padded with NULL values.
        If an &lt;array value expression&gt; evaluates to NULL, an empty array
        is used in its place. The array expression can contain references to
        any column of the table references preceding the current table
        reference.</para>

        <para><literal>&lt;collection derived table&gt; ::= UNNEST &lt;left
        paren&gt; &lt;array value expression&gt;, ... &lt;right paren&gt; [
        WITH ORDINALITY ]</literal></para>

        <para>The <literal>&lt;array value expression&gt;</literal> can be the
        result of a function call. If the arguments of the function call are
        values from the tables on the left of the UNNEST, then the function is
        called for each row of table.</para>

        <para>In the first example below, UNNEST is used with the built
        in-function SEQUENCE_ARRAY to build a table containing dates for the
        last seven days and their ordinal position. In the second example, a
        select statement returns costs for the last seven days . In the third
        example, the WITH clause turns the two selects into named subqueries
        which are used in a SELECT statement that uses a LEFT join.</para>

        <informalexample>
          <programlisting> SELECT * FROM UNNEST(SEQUENCE_ARRAY(CURRENT_DATE - 7 DAY, CURRENT_DATE - 1 DAY, 1 DAY)) WITH ORDINALITY AS T(D, I)  

 D          I 
 ---------- - 
 2010-07-25 1 
 2010-07-26 2 
 2010-07-27 3 
 2010-07-28 4 
 2010-07-29 5 
 2010-07-30 6 
 2010-07-31 7 

 CREATE TABLE expenses (item_date DATE, cost DECIMAL(8,2))
 --
 SELECT item_date, SUM(cost) AS total FROM expenses WHERE item_date &gt;= CURRENT_DATE - 7 DAY GROUP BY item_date

 ITEM_DATE  TOTAL      
 ---------- ------ 
 2010-07-27 100.12 
 2010-07-29 50.45  

 WITH costs(item_date, total) AS (SELECT item_date, SUM(cost) FROM expenses WHERE item_date &gt;= CURRENT_DATE - 7 DAY GROUP BY item_date),
 dates(d, i) AS (SELECT * FROM UNNEST(SEQUENCE_ARRAY(CURRENT_DATE - 7 DAY, CURRENT_DATE - 1 DAY, 1 DAY)) WITH ORDINALITY)   
 SELECT i, d, total FROM dates LEFT OUTER JOIN costs ON dates.d = costs.item_date

 I D          TOTAL      
 - ---------- ------ 
 1 2010-07-25 (null) 
 2 2010-07-26 (null) 
 3 2010-07-27 100.12 
 4 2010-07-28 (null) 
 5 2010-07-29 50.45  
 6 2010-07-30 (null) 
 7 2010-07-31 (null) 

</programlisting>
        </informalexample>
      </section>

      <section xml:id="dac_table_function">
        <title>Table Function Derived Table</title>

        <indexterm significance="preferred" type="sql">
          <primary>Table Function Derived Table</primary>
        </indexterm>

        <simpara><emphasis role="bold">Table Function Derived
        Table</emphasis></simpara>

        <para>When TABLE is used in this context, the <literal>&lt;collection
        value expression&gt;</literal> must be the result of a function call
        to a built-in function or user-defined function that returns an array
        or a table. When the function returns an array, this array is
        converted into a table, similar to the way UNNEST operates. When the
        function returns a table, the result is a MULTISET and is used as
        is.</para>

        <para><literal>&lt;table function derived table&gt; ::= TABLE &lt;left
        paren&gt; &lt;collection value expression&gt; &lt;right
        paren&gt;</literal></para>
      </section>

      <section xml:id="dac_parens_j_table">
        <title>Parenthesized Joined Table</title>

        <para>A parenthesized joined table is simply a joined table contained
        in parentheses. Joined tables are discussed below.</para>

        <para><literal>&lt;parenthesized joined table&gt; ::= &lt;left
        paren&gt; &lt;parenthesized joined table&gt; &lt;right paren&gt; |
        &lt;left paren&gt; &lt;joined table&gt; &lt;right
        paren&gt;</literal></para>
      </section>

      <section xml:id="dac_col_name_list">
        <title>Column Name List</title>

        <indexterm significance="preferred" type="sql">
          <primary>column name list</primary>
        </indexterm>

        <simpara><emphasis role="bold">column name list</emphasis></simpara>

        <para>The column list that is specified for the table reference must
        contain names that are unique within the list</para>

        <para><literal>&lt;derived column list&gt; ::= &lt;column name
        list&gt;</literal></para>

        <para><literal>&lt;column name list&gt; ::= &lt;column name&gt; [ {
        &lt;comma&gt; &lt;column name&gt; }... ] </literal></para>
      </section>
    </section>

    <section xml:id="dac_joined_table">
      <title>Joined Table</title>

      <para>Joins are operators with two table as the operands, resulting in a
      third table, called joined table. All join operators are evaluated left
      to right, therefore, with multiple joins, the table resulting from the
      first join operator becomes an operand of the next join operator.
      Parentheses can be used to group sequences of joined tables and change
      the evaluation order. So if more than two tables are joined together
      with join operators, the end result is also a joined table. There are
      different types of join, each producing the result table in a different
      way.</para>

      <para><literal>&lt;joined table&gt; ::= &lt;cross join&gt; |
      &lt;qualified join&gt; | &lt;natural join&gt;</literal></para>

      <para><literal>&lt;cross join&gt; ::= &lt;table reference&gt; CROSS JOIN
      &lt;table factor&gt; </literal></para>

      <para><literal>&lt;qualified join&gt; ::= &lt;table reference&gt; | [
      &lt;join type&gt; ] JOIN &lt;table reference&gt; &lt;join
      specification&gt;</literal></para>

      <para><literal>&lt;natural join&gt; ::= &lt;table reference&gt; NATURAL
      [ &lt;join type&gt; ] JOIN &lt;table factor&gt;</literal></para>

      <para><literal>&lt;join specification&gt; ::= &lt;join condition&gt; |
      &lt;named columns join&gt;</literal></para>

      <para><literal>&lt;join condition&gt; ::= ON &lt;search
      condition&gt;</literal></para>

      <para><literal>&lt;named columns join&gt; ::= USING &lt;left paren&gt;
      &lt;join column list&gt; &lt;right paren&gt;</literal></para>

      <para><literal>&lt;join type&gt; ::= INNER | &lt;outer join type&gt; [
      OUTER ] </literal></para>

      <para><literal>&lt;outer join type&gt; ::= LEFT | RIGHT |
      FULL</literal></para>

      <para><literal>&lt;join column list&gt; ::= &lt;column name
      list&gt;</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>CROSS JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">CROSS JOIN</emphasis></simpara>

      <para>The simplest form of join is CROSS JOIN. The CROSS JOIN of two
      tables is a table that has all the columns of the first table, followed
      by all the columns of the second table, in the original order. Each row
      of the first table is combined with each row of the second table to fill
      the rows of the new table. If the rows of each table form a set, then
      the rows of the CROSS JOIN table form the Cartesian product of the rows
      of the two table operands.</para>

      <para>Conditions are not allowed as part of a cross join, which is
      simply <literal>A CROSS JOIN B</literal>. Any conditions in a WHERE
      clause are later applied to the table resulting from the cross
      join.</para>

      <para>Tables in the FROM CLAUSE separated with commas, are equivalent to
      cross joins between the tables. Two joined tables separated with a
      comma, such as <literal>A, B</literal>, is equivalent to (A) CROSS JOIN
      (B), which means the joined tables A and B are populated separately
      before they are joined.</para>

      <para>CROSS JOIN is not is not generally very useful, as it returns
      large result tables unless WHERE conditions are used.</para>

      <indexterm significance="preferred" type="sql">
        <primary>UNION JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNION JOIN</emphasis></simpara>

      <para>The UNION JOIN has limited use in queries. The result table has
      the same columns as that of CROSS JOIN. Each row of the first table is
      extended to the right with nulls and added to the new table. Each row of
      the second table is extended to the left with nulls and added to the new
      table. The UNION JOIN is expressed as <literal>A UNION JOIN B</literal>.
      This should not be confused with <literal>A UNION B</literal>, which is
      a set operation. Union join is for special applications and is not
      commonly used.</para>

      <indexterm significance="preferred" type="sql">
        <primary>JOIN with condition</primary>
      </indexterm>

      <simpara><emphasis role="bold">JOIN ... ON</emphasis></simpara>

      <para>The condition join is similar to CROSS JOIN, but a condition is
      tested for each row of the new table and the row is created only if the
      condition is true. This form of join is expressed as <literal>A JOIN B
      ON (&lt;search condition&gt;)</literal>.</para>

      <para>Equijoin is a condition join in which the search condition is an
      equality condition between on or more pairs of columns from the two
      table. Equijoin is the most commonly used type of join.</para>

      <informalexample>
        <programlisting>SELECT a.*, b.* FROM a INNER JOIN b ON a.col_one = b.col_two
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>JOIN USING</primary>
      </indexterm>

      <simpara><emphasis role="bold">JOIN ... USING</emphasis></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>NATURAL JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">NATURAL JOIN</emphasis></simpara>

      <para>Joins with USING or NATURAL keywords are similar to an equijoin
      but they cannot be replaced simply with an equijoin. The new table is
      formed with the specified or implied shared columns of the two tables,
      followed by the rest of the columns from each table. In NATURAL JOIN,
      the shared columns are all the column pairs that have the same name in
      the first and second table. In JOIN USING, only columns names that are
      specified by the USING clause are shared. The joins are expressed as
      <literal>A NATURAL JOIN B</literal>, and <literal>A JOIN B USING
      (&lt;comma separated column name list&gt;)</literal>.</para>

      <para>The columns of the joined table are formed by the following
      procedures: In JOIN ... USING the shared columns are added to the joined
      table in the same order as they appear in the column name list. In
      NATURAL JOIN the shared columns are added to the joined table in the
      same order as they appear in the first table. In both forms of join, the
      non-shared columns of the first table are added in the order they appear
      in the first table, finally the non-shared columns of the second table
      are added in the order they appear in the second table.</para>

      <para>The type of each shared column of the joined table is based on the
      type of the columns in the original tables. If the original types are
      not exactly the same, the type of the shared column is formed by type
      aggregation. Type aggregations selects a type that can represent values
      of both aggregated types. Simple type aggregation picks one of the
      types. For example, SMALLINT and INTEGER, results in INTEGER, or
      VARCHAR(10) and VARCHAR(20) results in VARCHAR(20). More complex type
      aggregation inherits properties from both types. For example DECIMAL(8)
      and DECIMAL (6,2) results in DECIMAL (8,2).</para>

      <para>In the examples below, the rows are joined exactly the same way,
      but the first query contains a.col_two and b.col_two together with all
      the rest of the columns of both tables, while the second query returns
      only one copy of col_two.</para>

      <informalexample>
        <programlisting> SELECT * FROM a INNER JOIN b ON a.col_two = b.col_two
 SELECT * FROM a INNER JOIN b USING (col_two)
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>OUTER JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">OUTER JOIN</emphasis></simpara>

      <para>LEFT, RIGHT and FULL OUTER JOIN</para>

      <para>The three qualifiers can be added to all types of JOIN except
      CROSS JOIN and UNION JOIN. First the new table is populated with the
      rows from the original join. If LEFT is specified, all the rows from the
      first table that did not make it into the new table are extended to the
      right with nulls and added to the table. If RIGHT is specified, all the
      rows from the second table that did not make it into the new table are
      extended to the left with nulls and added to the table. If FULL is
      specified, the addition of leftover rows is performed from both the
      first and the second table. These forms are expressed by prefixing the
      join specification with the given keyword. For example, <literal>A LEFT
      OUTER JOIN B ON (&lt;search condition&gt;)</literal> or <literal>A
      NATURAL FULL OUTER JOIN B</literal> or <literal>A FULL OUTER JOIN B
      USING (&lt;comma separated column name list&gt;)</literal>.</para>

      <informalexample>
        <programlisting> SELECT a.*, b.* FROM a LEFT OUTER JOIN b ON a.col_one = b.col_two
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_selection">
      <title>Selection</title>

      <para>Despite the name, selection has nothing to do with the list of
      columns in a SELECT statement. In fact, it refers to the search
      condition used to limit the rows that from a result table (selection of
      rows, not columns). In SQL, simple selection is expressed with a WHERE
      condition appended to a single table or a joined table. In some cases,
      this method of selection is the only method available; for example in
      DELETE and UPDATE statements. But when it is possible to perform the
      selection with join conditions, this is the better method, as it results
      in a clearer expression of the query.</para>
    </section>

    <section xml:id="dac_projection">
      <title>Projection</title>

      <para>Projection is selection of the columns from a simple or joined
      table to form a result table. Explicit projection is performed in the
      SELECT statement by specifying the select column list. Some form of
      projection is also performed in JOIN ... USING and NATURAL JOIN.</para>

      <para>The joined table has columns that are formed according to the
      rules mentioned above. But in many cases, not all the columns are
      necessary for the intended operation. If the statement is in the form,
      SELECT * FROM &lt;joined table&gt;, then all the columns of &lt;joined
      table&gt; are returned. But normally, the columns to be returned are
      specified after the SELECT keyword, separated from each other with
      commas.</para>
    </section>

    <section xml:id="dac_computed_columns">
      <title>Computed Columns</title>

      <para>In the select list, it is possible to use expressions that
      reference any columns of &lt;joined table&gt;. Each of these expressions
      forms a computed column. It is computed for each row of the result
      table, using the values of the columns of the &lt;joined table&gt; for
      that row.</para>
    </section>

    <section xml:id="dac_naming">
      <title>Naming</title>

      <para>Naming is used to hide the original names of tables or table
      columns and to replace them with new names in the scope of the query.
      Naming is also used for defining names for computed columns.</para>

      <para>Without explicit naming, the name of a column is a predefined
      name. If the column is a column of a table, or is a named parameter, the
      name is of the table column or parameter is used. Otherwise it is
      generated by the database engine. HyperSQL generates column names such
      as C1, C2, etc. As generated naming is implementation defined according
      to the SQL Standard, it is better to explicitly name the computed and
      derived columns in your applications.</para>

      <indexterm significance="preferred" type="sql">
        <primary>naming in joined table</primary>
      </indexterm>

      <simpara><emphasis role="bold">Naming in Joined
      Table</emphasis></simpara>

      <para>Naming is performed by adding a new name after a table's real name
      and by adding a list of column names after the new table name. Both
      table naming and column naming are optional, but table naming is
      required for column naming. The expression <literal>A [AS] X (&lt;comma
      separated column name list&gt;)</literal> means table A is used in the
      query expression as table X and its columns are named as in the given
      list. The original name A, or its original column names, are not visible
      in the scope of the query. The BNF is given below. The
      <literal>&lt;correlation name&gt;</literal> can be the same or different
      from the name of the table. The <literal>&lt;derived column
      list&gt;</literal> is a comma separated list of column names. The degree
      of this list must be equal to the degree of the table. The column names
      in the list must be distinct. They can be the same or different from the
      names of the table's columns.</para>

      <para><literal>&lt;table or query name&gt; [ [ AS ] &lt;correlation
      name&gt; [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right
      paren&gt; ] ]</literal></para>

      <simpara>In the examples below, the columns of the original tables are
      named (a, b, c, d, e, f). The two queries are equivalent. In the second
      query, the table and its columns are renamed and the new names are used
      in the WHERE clauses:</simpara>

      <informalexample>
        <programlisting> CREATE TABLE atable (a INT, b INT, c INT, d INT, e INT, f INT);
 SELECT d, e, f FROM atable WHERE a + b = c
 SELECT x, y, z FROM atable AS t (u, v, w, x, y, z)  WHERE u + v = w</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>naming in select list</primary>
      </indexterm>

      <simpara><emphasis role="bold">Naming in Select
      List</emphasis></simpara>

      <para>Naming in the SELECT list logically takes place after naming in
      the joined table. The new names for columns are not visible in the
      immediate query expression or query expression. They become visible in
      the ORDER BY clause and in the result table that is returned to the
      user. Or if the query expression is used as a derived table in an
      enclosing query expression.</para>

      <para>In the example below, the query is on the same table but with
      column renaming in the Select list. The new names are used in the ORDER
      BY clause:</para>

      <informalexample>
        <programlisting> SELECT x + y AS xysum, y + z AS yzsum FROM atable AS t (u, v, w, x, y, z)  WHERE u + v = w ORDER BY xysum, yzsum</programlisting>
      </informalexample>

      <para>If the names <literal>xysum</literal> or <literal>yzsum</literal>
      are not used, the computed columns cannot be referenced in the ORDER BY
      list.</para>

      <indexterm significance="preferred" type="sql">
        <primary>name resolution</primary>
      </indexterm>

      <simpara><emphasis role="bold">Name Resolution</emphasis></simpara>

      <simpara>In a joined table, if a column name appears in tables on both
      sides then any reference to the name must use the table name in order to
      specify which table is being referred to.</simpara>
    </section>

    <section xml:id="dac_grouping_operations">
      <title>Grouping Operations</title>

      <indexterm significance="preferred" type="sql">
        <primary>GROUPING OPERATIONS</primary>
      </indexterm>

      <simpara><emphasis role="bold">Grouping Operations</emphasis></simpara>

      <para>Grouping results in the elimination of duplicate rows. A grouping
      operation is performed after the operations discussed above. A simple
      form of grouping is performed by the use of DISTINCT after SELECT. This
      eliminates all the duplicate rows (rows that have the same value in each
      of their columns when compared to another row). The other form of
      grouping is performed with the GROUP BY clause. This form is usually
      used together with aggregation.</para>

      <indexterm significance="preferred" type="sql">
        <primary>GROUP BY</primary>
      </indexterm>

      <simpara><emphasis role="bold">GROUP BY</emphasis></simpara>

      <simpara><literal>&lt;group by clause&gt; ::= GROUP BY [ &lt;set
      quantifier&gt; ] &lt;grouping element&gt; [ { &lt;comma&gt; &lt;grouping
      element&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;grouping element&gt; ::= &lt;ordinary grouping
      set&gt; | &lt;rollup list&gt; | &lt;cube list&gt; | &lt;grouping sets
      specification&gt; | &lt;empty grouping set&gt;</literal></simpara>

      <simpara><literal>&lt;ordinary grouping set&gt; ::= &lt;grouping column
      reference&gt; | &lt;left paren&gt; &lt;grouping column reference
      list&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;grouping column reference list&gt; ::=
      &lt;grouping column reference&gt; [ { &lt;comma&gt; &lt;grouping column
      reference&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;grouping column reference&gt; ::= &lt;column
      reference&gt; [ &lt;collate clause&gt; ] </literal></simpara>

      <simpara><literal>&lt;rollup list&gt; ::= ROLLUP &lt;left paren&gt;
      &lt;ordinary grouping set list&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;ordinary grouping set list&gt; ::= &lt;ordinary
      grouping set&gt; [ { &lt;comma&gt; &lt;ordinary grouping set&gt; }... ]
      </literal></simpara>

      <simpara><literal>&lt;cube list&gt; ::= CUBE &lt;left paren&gt;
      &lt;ordinary grouping set list&gt; &lt;right paren&gt;
      </literal></simpara>

      <simpara><literal>&lt;grouping sets specification&gt; ::= GROUPING SETS
      &lt;left paren&gt; &lt;grouping set list&gt; &lt;right paren&gt;
      </literal></simpara>

      <simpara><literal>&lt;grouping set list&gt; ::= &lt;grouping set&gt; [ {
      &lt;comma&gt; &lt;grouping set&gt; }... ] </literal></simpara>

      <simpara><literal>&lt;grouping set&gt; ::= &lt;ordinary grouping set&gt;
      | &lt;rollup list&gt; | &lt;cube list&gt; | &lt;grouping sets
      specification&gt; | &lt;empty grouping set&gt; </literal></simpara>

      <simpara><literal>&lt;empty grouping set&gt; ::= &lt;left paren&gt;
      &lt;right paren&gt;</literal></simpara>

      <para>An ordinary <literal>&lt;group by clause&gt;</literal> is a comma
      separated list of columns of the table formed by the <literal>&lt;from
      clause&gt;</literal> or expressions based on the columns. This is the
      most common usage and can be described as <literal>GROUP BY &lt;column
      reference&gt; [ { &lt;comma&gt; &lt;grouping column reference&gt; }...
      ]</literal>.</para>

      <para>When a <literal>&lt;group by clause&gt;</literal> is used, only
      the columns used in the <literal>&lt;group by clause&gt;</literal> or
      expressions used there, can be used in the <literal>&lt;select
      list&gt;</literal>, together with any <literal>&lt;aggregate
      function&gt;</literal> on other columns. In other words, the column
      names or expressions listed in the GROUP BY clause dictate what can be
      used in the <literal>&lt;select list&gt;</literal>. After the rows of
      the table formed by the <literal>&lt;from clause&gt;</literal> and the
      <literal>&lt;where clause&gt;</literal> are finalised, the grouping
      operation groups together the rows that have the same values in the
      columns of the <literal>&lt;group by clause&gt;</literal>. Then any
      <literal>&lt;aggregate function&gt;</literal> in the <literal>&lt;select
      list&gt;</literal> is performed on each group, and for each group, a row
      is formed that contains the values of the columns of the
      <literal>&lt;group by clause&gt;</literal> and the values returned from
      each <literal>&lt;aggregate function&gt;</literal>.</para>

      <para>When the type of <literal>&lt;column reference&gt;</literal> is
      character string, the <literal>&lt;collate clause&gt;</literal> can be
      used to specify the collation used for grouping the rows. For example, a
      collation that is not case sensitive can be used, or a collation for a
      different language than the original collation of the column.</para>

      <para>The first example below shows a simple GROUP BY, while in the
      second example, has a HAVING condition.<informalexample>
          <programlisting> CREATE TABLE REVENUE(CHANNEL VARCHAR(20), YEAR INTEGER, COUNTRY VARCHAR(2), PROVINCE VARCHAR(20), SALES INTEGER);
 SELECT CHANNEL, YEAR, COUNTRY, SUM(SALES) FROM REVENUE GROUP BY CHANNEL, YEAR, COUNTRY;
 SELECT CHANNEL, YEAR, COUNTRY, SUM(SALES) FROM REVENUE GROUP BY CHANNEL, YEAR, COUNTRY HAVING SUM(SALES) &gt; 50000;
</programlisting>
        </informalexample></para>

      <para>An extended <literal>&lt;group by clause&gt;</literal> may
      comprise elements such as GROUPING SETS, ROLLUP, CUBE and the empty
      grouping set. These syntax elements are expanded and then simplified
      into a list of parenthesized column elements, which result in multiple
      grouping operations. HyperSQL version 2.5.1 supports all the syntax
      listed above. The example below uses ROLLUP for grouping.</para>

      <informalexample>
        <programlisting> SELECT CHANNEL, YEAR, COUNTRY, SUM(SALES) AS S
 FROM REVENUE 
 GROUP BY ROLLUP(CHANNEL, YEAR, COUNTRY);
</programlisting>
      </informalexample>

      <para>The ROLLUP is translated into 4 groupings: (channel, year,
      country), (channel, year), (channel), (). The result set will contain
      the rows as grouped by (channel, year, country), then rows as grouped by
      (channel, year) with the country column replaced by null, then rows as
      grouped by (channel) only, with year and country columns replaced by
      null, then a single row representing the () empty group with all three
      columns replaced by null.</para>

      <informalexample>
        <programlisting>CHANNEL      YEAR   COUNTRY S       
------------ ------ ------- ------- 
INTERNET     2009   GB      25000   
INTERNET     2009   US      275000  
INTERNET     2010   GB      45000   
INTERNET     2010   US      500000  
DIRECT SALES 2009   GB      162000  
DIRECT SALES 2009   US      1602500 
DIRECT SALES 2010   GB      181000  
DIRECT SALES 2010   US      1833000 
INTERNET     2009   (null)  300000  
INTERNET     2010   (null)  545000  
DIRECT SALES 2009   (null)  1764500 
DIRECT SALES 2010   (null)  2014000 
INTERNET     (null) (null)  845000  
DIRECT SALES (null) (null)  3778500 
(null)       (null) (null)  4623500 
</programlisting>
      </informalexample>

      <para>If CUBE is used instead of ROLLUP, other permutations of the three
      columns are added to those produced by ROLLUP. These include (channel,
      country), (year, country), (year) and (country).</para>

      <para>The optional &lt;set quantifier&gt; is either ALL or DISTINCT and
      defaults to ALL. When GROUPING SETS is used and multiple sets are
      specified and some duplicate groups are created as a result, use of
      DISTINCT eliminates the duplicate groups.</para>

      <para>Note any ordering of the rows returned by GROUP BY in incidental.
      You need to use ORDER BY for the ordering you require.</para>

      <indexterm significance="preferred" type="sql">
        <primary>HAVING</primary>
      </indexterm>

      <simpara><emphasis role="bold">HAVING</emphasis></simpara>

      <para>A <literal>&lt;having clause&gt;</literal> filters the rows of the
      table that is formed after applying the <literal>&lt;group by
      clause&gt;</literal> using its search condition. The search condition
      must be an expression based on the expressions in the GROUP BY list or
      the aggregate functions used.</para>

      <indexterm significance="preferred" type="sql">
        <primary>DISTINCT</primary>
      </indexterm>

      <simpara><emphasis role="bold">DISTINCT</emphasis></simpara>

      <simpara><literal>SELECT DISTINCT</literal></simpara>

      <para>When the keyword DISTINCT is used after SELECT, it works as a
      shortcut replacement for a simple GROUP BY clause. The expressions in
      the SELECT list are used directly as the <literal>&lt;group by
      clause&gt;</literal>. The following examples of SELECT DISTINCT and
      SELECT with GROUP BY are equivalent.</para>

      <informalexample>
        <programlisting> SELECT DISTINCT d, e + f FROM atable WHERE a + b = c
 SELECT d, e + f FROM atable WHERE a + b = c GROUP BY d, e + f
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_aggregation">
      <title>Aggregation</title>

      <para>Aggregation is an operation that computes a single value from the
      values of a column over several rows. The operation is performed with an
      aggregate function. The simplest form of aggregation is counting,
      performed by the COUNT function.</para>

      <para>Other common aggregate functions return the maximum, minimum and
      average value among the values in different rows. Aggregate functions
      were discussed earlier in this chapter.</para>
    </section>

    <section xml:id="dac_set_operations">
      <title>Set Operations</title>

      <indexterm significance="preferred" type="sql">
        <primary>SET OPERATIONS</primary>
      </indexterm>

      <simpara><emphasis role="bold">Set and Multiset
      Operations</emphasis></simpara>

      <para>While join operations generally result in laterally expanded
      tables, SET and COLLECTION operations are performed on two tables that
      have the same degree and result in a table of the same degree. The SET
      operations are UNION, INTERSECT and EXCEPT (difference). When each of
      these operations is performed on two tables, the collection of rows in
      each table and in the result is reduced to a set of rows, by eliminating
      duplicates. The set operations are then performed on the two tables,
      resulting in the new table which itself is a set of rows. Collection
      operations are similar but the tables are not reduced to sets before or
      after the operation and the result is not necessarily a set, but a
      collection of rows.</para>

      <para>The set operations on two tables A and B are: <literal>A UNION
      [DISTINCT] B</literal>, <literal>A INTERSECT [DISTINCT] B</literal> and
      <literal>A EXCEPT [DISTINCT] B</literal>. The result table is formed in
      the following way: The UNION operation adds all the rows from A and B
      into the new table, but avoids copying duplicate rows. The INTERSECT
      operation copies only those rows from each table that also exist in the
      other table, but avoids copying duplicate rows. The EXCEPT operation
      copies those rows from the first table which do not exist in the second
      table, but avoids copying duplicate rows.</para>

      <para>The collection operations are similar to the set operations, but
      can return duplicate rows. They are: <literal>A UNION ALL B</literal>,
      <literal>A INTERSECT ALL B</literal> and <literal>A EXCEPT ALL
      B</literal>. The UNION ALL operation adds all the rows from A and B into
      the new table. The INTERSECT operation copies only those rows from each
      table that also exist in the other table. If n copies of a rows exists
      in one table, and m copies in the other table, the number of copies in
      the result table is the smaller of n and m. The EXCEPT operation copies
      those rows from the first table which do not exist in the second table.
      If n copies of a row exist in the first table and m copies in the second
      table the number of copies in the result table is n-m, or if n &lt; m,
      then zero.</para>
    </section>

    <section xml:id="dac_with_clause">
      <title>With Clause and Recursive Queries</title>

      <para>The optional WITH clause can be used in a query expression. The
      WITH clause lists one or more named ephemeral tables that can be
      referenced in the query expression body. The ephemeral tables are
      created and populated before the rest of the query expression is
      executed. Their contents do not change during the execution of the
      <literal>&lt;query expression body&gt;</literal> that follows the WITH
      clause.</para>

      <para><literal>&lt;with clause&gt; ::= WITH [ RECURSIVE ] &lt;with
      list&gt;</literal></para>

      <para><literal>&lt;with list&gt; ::= &lt;with list element&gt; [ {
      &lt;comma&gt; &lt;with list element&gt; }... ] </literal></para>

      <para><literal>&lt;with list element&gt; ::= &lt;query name&gt; [
      &lt;left paren&gt; &lt;with column list&gt; &lt;right paren&gt; ] AS
      &lt;left paren&gt; &lt;query expression&gt; &lt;right paren&gt;
      </literal></para>

      <para><literal>&lt;with column list&gt; ::= &lt;column name
      list&gt;</literal></para>

      <para>An example of the use of the WITH clause is given above under
      UNNEST. The <literal>&lt;query expression&gt;</literal> in the WITH
      clause is evaluated and its result table can be referenced in the body
      of the main <literal>&lt;query expression body&gt;</literal> using the
      specified <literal>&lt;query name&gt;</literal>.</para>

      <para>When RECURSIVE is used, the <literal>&lt;with column
      list&gt;</literal> must be defined. The RECURSIVE keyword changes the
      way the <literal>&lt;with list&gt;</literal> is interpreted. The
      <literal>&lt;query expression&gt;</literal> contained in the
      <literal>&lt;with list element&gt;</literal> must be the UNION or UNION
      ALL of two &lt;query expression body&gt; elements (VALUES or SELECT
      statements). A working table is created and the left side SELECT of the
      UNION is evaluated only once and its result is copied to the working
      table. This result is also copied to the general result of the
      <literal>&lt;query expression&gt;</literal>. Iteration starts after this
      step. In each iteration, the right side SELECT is evaluated. The
      contents of the working table is used when the <literal>&lt;query
      name&gt;</literal> is referenced in the right side SELECT statement of
      the UNION. The result of this SELECT is then added to the previous
      general result of the <literal>&lt;query expression&gt;</literal> with
      UNION or UNION ALL. The working table is cleared and filled with the
      latest result. These operations are repeated again and again, until the
      latest result is empty and the general result of the <literal>&lt;query
      expression&gt;</literal> stops changing. The result of the
      <literal>&lt;with list element&gt;</literal> is now fully populated and
      is later used in the execution of the <literal>&lt;query expression
      body&gt;</literal> that follows the WITH clause.</para>

      <para>HyperSQL limits recursion to 256 rounds. If this is exceeded, an
      error is raised.</para>

      <para>From version 2.5.2, HyperSQL extends recursive query processing by
      allowing the use of RECURSIVE_TABLE to reference the current general
      result of the <literal>&lt;query expression&gt;</literal>. This table
      name can be used in subqueries with an IN predicate in order to reduce
      and limit the new result created in each iteration. </para>

      <para>A trivial example of a recursive query is given below. Note the
      first column GEN. For example, if each row of the table represents a
      member of a family of dogs, together with its parent, the first column
      of the result indicates the calculated generation of each dog, ranging
      from first to fourth generation.</para>

      <informalexample>
        <programlisting> CREATE TABLE pptree (pid INT, id INT, name VARCHAR(10));
 INSERT INTO pptree VALUES (NULL, 1, 'dizzi'),(1,2, 'fizzi'),
                           (1,3, 'gizzi'),(2,4, 'kizzi'),
                           (4,5, 'mizzi'),(3,6, 'pizzi'),
                           (3,7, 'tizzi');

 WITH RECURSIVE tree (gen, par, child, name) AS (
   VALUES(1, CAST(null as int), 1, 'dizzi')
   UNION
   SELECT gen + 1, pid, id, name FROM pptree, tree WHERE pid = child
   ) SELECT * FROM tree;

 GEN PAR    CHILD NAME  
 --- ------ ----- ----- 
 1   (null) 1     dizzi 
 2   1      2     fizzi 
 2   1      3     gizzi 
 3   2      4     kizzi 
 3   3      6     pizzi 
 3   3      7     tizzi 
 4   4      5     mizzi 
</programlisting>
      </informalexample>

      <para>If recursive queries become complex, they also become very
      difficult to develop and debug. HyperSQL provides an alternative to this
      with user-defined SQL functions which return tables. Functions can
      perform any complex, repetitive task with better control, using loops,
      variables and, if necessary, recursion.</para>

      <para>The query below computes the Fibonacci numbers up to 100 digits.
      The WHERE clause limits the iteration.</para>

      <informalexample>
        <programlisting> WITH RECURSIVE Fibonacci(N1, F1, N2, F2) AS (
   VALUES(0, CAST(0 AS DECIMAL(100)), 1, CAST(1 AS DECIMAL(100))
   UNION
   SELECT N1 + 1, F1 + F2, N1 +2, F1 + 2 * F2
   FROM Fibonacci p 
   WHERE N1 &lt; 100
 ) SELECT * FROM Fibonacci
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_query_expression">
      <title>Query Expression</title>

      <para>A query expression consists of an optional WITH clause and a query
      expression body. The optional WITH clause lists one or more named
      ephemeral tables that can be referenced, just like the database tables
      in the query expression body.</para>

      <para><literal>&lt;query expression&gt; ::= [ &lt;with clause&gt; ]
      &lt;query expression body&gt;</literal></para>

      <para>A query expression body refers to a table formed by using UNION
      and other set operations. The query expression body is evaluated from
      left to right and the INTERSECT operator has precedence over the UNION
      and EXCEPT operators. A simplified BNF is given below:</para>

      <simpara><literal>&lt;query expression body&gt; ::= &lt;query term&gt; |
      &lt;query expression body&gt; UNION | EXCEPT [ ALL | DISTINCT ] [
      &lt;corresponding spec&gt; ] &lt;query term&gt;</literal></simpara>

      <simpara><literal>&lt;query term&gt; ::= &lt;query primary&gt; |
      &lt;query term&gt; INTERSECT [ ALL | DISTINCT ] [ &lt;corresponding
      spec&gt; ] &lt;query term&gt;</literal></simpara>

      <simpara><literal>&lt;query primary&gt; ::= &lt;simple table&gt; |
      &lt;left paren&gt; &lt;query expression body&gt; [ &lt;order by
      clause&gt; ] [ &lt;result offset clause&gt; ] [ &lt;fetch first
      clause&gt; ] &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;simple table&gt; ::= &lt;query specification&gt; |
      &lt;table value constructor&gt; | &lt;explicit table&gt; &lt;explicit
      table&gt; ::= TABLE &lt;table or query name&gt;</literal></simpara>

      <para><literal>&lt;corresponding spec&gt; ::= CORRESPONDING [ BY
      &lt;left paren&gt; &lt;column name list&gt; &lt;right paren&gt;
      ]</literal></para>

      <para>A <literal>&lt;query term&gt;</literal> and a <literal>&lt;query
      primary&gt;</literal> can be a SELECT statement, an
      <literal>&lt;explicit table&gt;</literal>, or a <literal>&lt;table value
      constructor&gt;</literal>.</para>

      <para>The CORRESPONDING clause is optional. If it is not specified, then
      the <literal>&lt;query term&gt;</literal> and the <literal>&lt;query
      primary&gt;</literal> must have the same number of columns. If
      CORRESPONDING is specified, the two sides need not have the same number
      of columns. If no column list is used with CORRESPONDING, then all the
      column names that are common in the tables on two sides are used in the
      order in which they appear in the first table. If a columns list is
      used, it allows you to select only some columns of the tables on the
      left and right side to create the new table. In the example below the
      columns named u and v from the two SELECT statements are used to create
      the UNION table.</para>

      <para><informalexample>
          <programlisting> SELECT * FROM atable UNION CORRESPONDING BY (u, v) SELECT * FROM anothertable
</programlisting>
        </informalexample>The type of each column of the query expression is
      determined by combining the types of the corresponding columns from the
      two participating tables.</para>
    </section>

    <section xml:id="dac_ordering">
      <title>Ordering</title>

      <para>When the rows of the result table have been formed, it is possible
      to specify the order in which they are returned to the user. The ORDER
      BY clause is used to specify the columns used for ordering, and whether
      ascending or descending ordering is used. It can also specify whether
      NULL values are returned first or last.</para>

      <informalexample>
        <programlisting> SELECT x + y AS xysum, y + z AS yzsum FROM atable AS t (u, v, w, x, y, z)  WHERE u + v = w ORDER BY xysum NULLS LAST, yzsum NULLS FIRST</programlisting>
      </informalexample>

      <para>The ORDER BY clause specifies one or more <literal>&lt;value
      expressions&gt;</literal>. The list of rows is sorted according to the
      first <literal>&lt;value expression&gt;</literal>. When some rows are
      sorted equal then they are sorted according to the next
      <literal>&lt;value expression&gt;</literal> and so on.</para>

      <para><literal>&lt;order by clause&gt; ::= ORDER BY &lt;sort
      specification&gt; [ { &lt;comma&gt; &lt;sort specification&gt; }...
      ]</literal></para>

      <para><literal>&lt;sort specification&gt; ::= &lt;value expression&gt; [
      &lt;collate clause&gt; ] [ ASC | DESC ] [ NULLS FIRST | NULLS LAST
      ]</literal></para>

      <para>The defaults are ASC and NULLS FIRST. Two database properties SQL
      NULLS FIRST and SQL NULLS ORDER can be modified to change the default
      behaviour.</para>

      <para>A collation is used for columns of an ORDER BY expression that are
      of the type CHAR or VARCHAR. If a <literal>&lt;collate
      clause&gt;</literal> is not specified then the collation of the column,
      or the default collation of the database is used.</para>

      <para>The default collation for a database is ASCII, with lowercase
      letters sorted after all uppercase letters. The example below shows the
      effect of collation on an ordered list.</para>

      <para><informalexample>
          <programlisting> -- default collation collation for the database is ASCII
 SELECT id, lastname FROM customer ORDER BY lastname
 ID LASTNAME 
 -- -------- 
 40 Clancy   
 36 King     
 35 White    
 6  king

 -- a language collation is used, it treats king and King as adjacent entries
 SELECT id, lastname FROM customer ORDER BY lastname COLLATE "English"
 ID LASTNAME 
 -- -------- 
 40 Clancy   
 6  king     
 36 King     
 35 White
</programlisting>
        </informalexample>In the above example, if the LASTNAME column is
      itself defined in the table definition with <literal>COLLATE
      "English"</literal>, then the COLLATE clause is not necessary in the
      ORDER BY expression.</para>

      <para>An ORDER BY operation can sometimes be optimised by the engine
      when it can use the same index for accessing the table data and
      ordering. Optimisation can happen both with DESC + NULLS LAST and ASC +
      NULLS FIRST.</para>

      <indexterm significance="preferred" type="sql">
        <primary>sort specification list</primary>
      </indexterm>

      <simpara><emphasis role="bold">sort specification
      list</emphasis></simpara>

      <simpara><emphasis>sort specification list</emphasis></simpara>

      <simpara><literal>&lt;sort specification list&gt; ::= &lt;value
      expression&gt; [ASC | DESC] [NULLS FIRST | NULLS
      LAST]</literal></simpara>

      <simpara>Specify a sort order. A sort operation is performed on the
      result of a <literal>&lt;query expression&gt;</literal> or
      <literal>&lt;query specification&gt;</literal> and sorts the result
      according to one or more <literal>&lt;value expression&gt;</literal>.
      The <literal>&lt;value expression&gt;</literal> is usually a single
      column of the result, but in some cases it can be a column of the
      <literal>&lt;table expression&gt;</literal> that is not used in the
      select list. The default is ASC and NULLS FIRST.</simpara>
    </section>

    <section xml:id="dac_slicing">
      <title>Slicing</title>

      <para>A different form of limiting the rows can be performed on the
      result table after it has been formed according to all the other
      operations (selection, grouping, ordering etc.). This is specified by
      the FETCH ... ROWS and OFFSET clauses of a SELECT statement. In this
      form, the specified OFFSET rows are removed from start of the table,
      then up to the specified FETCH rows are kept and the rest of the rows
      are discarded.</para>

      <para><literal>&lt;result offset clause&gt; ::= OFFSET &lt;offset row
      count&gt; { ROW | ROWS }</literal></para>

      <para><literal>&lt;fetch first clause&gt; ::= FETCH { FIRST | NEXT } [
      &lt;fetch first row count&gt; ] { ROW | ROWS } ONLY [ USING INDEX
      ]</literal></para>

      <para><literal>&lt;limit clause&gt; ::= LIMIT &lt;fetch first row
      count&gt; [ USING INDEX ]</literal></para>

      <para>A slicing operation takes the result set that has been already
      processed and ordered. It then discards the specified number of rows
      from the start of the result set and returns the specified number of
      rows after the discarded rows. The &lt;offset row count&gt; and
      &lt;fetch first row count&gt; can be constants, dynamic variables,
      routine parameters, or routine variables. The type of the constants must
      be INTEGER.</para>

      <informalexample>
        <programlisting> SELECT a, b FROM atable WHERE d &lt; 5 ORDER BY absum OFFSET 3 FETCH 2 ROWS ONLY 
 SELECT a, b FROM atable WHERE d &lt; 5 ORDER BY absum OFFSET 3 LIMIT 2 /* alternative keyword */ </programlisting>
      </informalexample>

      <para>When the FETCH keyword is used, the specified number of rows must
      be at least 1, otherwise an error is returned. This behaviour is
      consistent with the SQL Standard. When the LIMIT keyword is used, the
      specified number of rows can be zero, which means return all rows (no
      LIMIT). In MySQL and PostgreSQL syntax modes, zero limit means no rows
      (empty result).</para>

      <para>If there is an index on all the columns specified in the ORDER BY
      clause, it is normally used for slicing. In some queries, an index on
      another column may take precedence because it is used to process the
      WHERE condition. It is possible to add <literal>USING INDEX</literal> to
      the end of the slicing clause to force the use of the index for ordering
      and slicing, instead of the index for the WHERE condition.</para>
    </section>

    <section xml:id="dac_explain_plan">
      <title>Indexes Used in SELECT Statements</title>

      <para>A query expression, for example a SELECT statement, uses indexes
      for efficient data retrieval. The EXPLAIN PLAN statement lists the
      indexes used, together with other useful information about the
      query.</para>

      <indexterm significance="preferred" type="sql">
        <primary>EXPLAIN PLAN</primary>
      </indexterm>

      <simpara><emphasis role="bold">EXPLAIN PLAN</emphasis></simpara>

      <simpara><emphasis>explain plan</emphasis></simpara>

      <simpara><literal>&lt;explain plan&gt; ::= EXPLAIN PLAN FOR &lt;query
      expression&gt;</literal></simpara>

      <simpara>For example, <literal>EXPLAIN PLAN FOR SELECT * FROM REVENUE
      WHERE COUNTRY = 'UK' </literal>.</simpara>
    </section>
  </section>

  <section xml:id="dac_data_change_statements">
    <title>Data Change Statements</title>

    <section xml:id="dac_delete_statement">
      <title>Delete Statement</title>

      <indexterm significance="preferred" type="sql">
        <primary>DELETE FROM</primary>
      </indexterm>

      <simpara><emphasis role="bold">DELETE FROM</emphasis></simpara>

      <simpara><emphasis>delete statement: searched</emphasis></simpara>

      <simpara><literal>&lt;delete statement: searched&gt; ::= DELETE FROM
      &lt;target table&gt; [ [ AS ] &lt;correlation name&gt; ] [ WHERE
      &lt;search condition&gt; ][ LIMIT &lt;fetch first row count&gt;
      ]</literal></simpara>

      <simpara>Delete rows of a table. The search condition is a
      <literal>&lt;boolean value expression&gt;</literal> that is evaluated
      for each row of the table. If the condition is true, the row is deleted.
      If the condition is not specified, all the rows of the table are
      deleted. In fact, an implicit SELECT is performed in the form of
      <literal>SELECT * FROM &lt;target table&gt; [ WHERE &lt;search
      condition&gt;]</literal> and the selected rows are deleted. When used in
      JDBC, the number of rows returned by the implicit SELECT is returned as
      the update count.</simpara>

      <simpara>If there are FOREIGN KEY constraints on other tables that
      reference the subject table, and the FOREIGN KEY constraints have
      referential actions, then rows from those other tables that reference
      the deleted rows are either deleted, or updated, according to the
      specified referential actions.</simpara>

      <simpara>The LIMIT clause, or alternatively the ROWNUM() function in the
      WHERE clause, can be used to limit the number of rows that are deleted.
      This is useful when a very large number of rows needs to be deleted. In
      this situation, you can perform the operation is chunks and commit after
      each chunk to reduce memory usage and the total time of the
      operation.</simpara>

      <simpara>In the second example below the rows that have the maximum
      value for column A are deleted;</simpara>

      <informalexample>
        <programlisting> DELETE FROM T WHERE C &gt; 5
 DELETE FROM T AS TT WHERE TT.A = (SELECT MAX(A) FROM T)
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_truncate_statement">
      <title>Truncate Statement</title>

      <indexterm significance="preferred" type="sql">
        <primary>TRUNCATE TABLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">TRUNCATE TABLE</emphasis></simpara>

      <simpara><emphasis>truncate table statement</emphasis></simpara>

      <simpara><literal>&lt;truncate table statement&gt; ::= TRUNCATE TABLE
      &lt;target table&gt; [ &lt;identity column restart option&gt; ] [
      &lt;truncate options&gt; ]</literal></simpara>

      <simpara><literal>&lt;identity column restart option&gt; ::= CONTINUE
      IDENTITY | RESTART IDENTITY</literal></simpara>

      <simpara><literal>&lt;truncate options&gt; ::= AND COMMIT [ NO CHECK
      ]</literal></simpara>

      <simpara><literal>&lt;truncate table versioning statement&gt; ::=
      TRUNCATE TABLE &lt;target table&gt; VERSIONING TO { TIMESTAMP'YYYY-MM-DD
      HH:MM:SS' | CURRENT_TIMESTAMP }</literal></simpara>

      <simpara>Delete all rows of a table without firing its triggers. This
      statement can only be used on base tables (not views). If the table is
      referenced in a FOREIGN KEY constraint defined on another table, the
      statement causes an exception. Triggers defined on the table are not
      executed with this statement. The default for <literal>&lt;identity
      column restart option&gt;</literal> is <literal>CONTINUE
      IDENTITY</literal>. This means no change to the IDENTITY sequence of the
      table. If <literal>RESTART IDENTITY</literal> is specified, then the
      sequence is reset to its start value.</simpara>

      <simpara>TRUNCATE is faster than ordinary DELETE. The TRUNCATE statement
      is an SQL Standard data change statement; therefore it is performed
      under transaction control and can be rolled back if the connection is
      not in the auto-commit mode.</simpara>

      <simpara>HyperSQL also supports the optional AND COMMIT and NO CHECK
      options. If AND COMMIT is used, then the transaction is committed with
      the execution of the TRUNCATE statement. The action cannot be rolled
      back. If the additional NO CHECK option is also specified, then the
      TRUNCATE statement is executed even if the table is referenced in a
      FOREIGN KEY constraint defined on another, non-empty table. This form of
      TRUNCATE is faster than the default form and does not use much
      memory.</simpara>

      <simpara>The <literal>&lt;truncate table versioning
      statement&gt;</literal> is for removing old history rows from a
      system-versioned table. All history rows that expired before the given
      timestamp are removed. No current row is removed.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>TRUNCATE SCHEMA</primary>
      </indexterm>

      <simpara><emphasis role="bold">TRUNCATE SCHEMA</emphasis></simpara>

      <simpara><emphasis>truncate schema statement</emphasis></simpara>

      <simpara><literal>&lt;truncate schema statement&gt; ::= TRUNCATE SCHEMA
      &lt;target schema&gt; [ &lt;identity column restart option&gt; ] AND
      COMMIT [ NO CHECK ]</literal></simpara>

      <simpara>Performs the equivalent of a TRUNCATE TABLE ... AND COMMIT on
      all the table in the schema. If the additional NO CHECK option is also
      specified, then the TRUNCATE statement is executed even if any of the
      tables in the schema is referenced in a FOREIGN KEY constraint defined
      on a non-empty table in a different schema.</simpara>

      <simpara>If RESTART IDENTITY is specified, all table IDENTITY sequences
      and all SEQUENCE objects in the schema are reset to their start
      values.</simpara>

      <simpara>Use of this statement requires schema ownership or
      administrative privileges.</simpara>
    </section>

    <section xml:id="dac_insert_statement">
      <title>Insert Statement</title>

      <indexterm significance="preferred" type="sql">
        <primary>INSERT INTO</primary>
      </indexterm>

      <simpara><emphasis role="bold">INSERT INTO</emphasis></simpara>

      <simpara><emphasis>insert statement</emphasis></simpara>

      <simpara><literal>&lt;insert statement&gt; ::= INSERT INTO &lt;target
      table&gt; [ [ AS ] &lt;correlation name&gt; ] &lt;insert columns and
      source&gt;</literal></simpara>

      <simpara><literal>&lt;insert columns and source&gt; ::= &lt;from
      subquery&gt; | &lt;from constructor&gt; | &lt;from
      default&gt;</literal></simpara>

      <simpara><literal>&lt;from subquery&gt; ::= [ &lt;left paren&gt;
      &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override
      clause&gt; ] &lt;query expression&gt;</literal></simpara>

      <simpara><literal>&lt;from constructor&gt; ::= [ &lt;left paren&gt;
      &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override
      clause&gt; ] &lt;contextually typed table value
      constructor&gt;</literal></simpara>

      <simpara><literal>&lt;override clause&gt; ::= OVERRIDING USER VALUE |
      OVERRIDING SYSTEM VALUE</literal></simpara>

      <simpara><literal>&lt;from default&gt; ::= DEFAULT
      VALUES</literal></simpara>

      <simpara><literal>&lt;insert column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara>Insert new rows in a table. An INSERT statement inserts one or
      more rows into the table.</simpara>

      <simpara>The special form, <literal>INSERT INTO &lt;target table&gt;
      DEFAULT VALUES</literal> can be used with tables which have a default
      value for each column.</simpara>

      <simpara>With the other forms of INSERT, the optional
      <literal>(&lt;insert column list&gt;)</literal> specifies to which
      columns of the table the new values are assigned.</simpara>

      <simpara>In one form, the inserted values are from a <literal>&lt;query
      expression&gt;</literal> and all the rows that are returned by the
      <literal>&lt;query expression&gt;</literal> are inserted into the table.
      If the <literal>&lt;query expression&gt;</literal> returns no rows,
      nothing is inserted.</simpara>

      <simpara>In the other form, a comma separated list of values called
      <literal>&lt;contextually typed table value constructor&gt;</literal> is
      used to insert one or more rows into the table. This list is
      contextually typed, because the keywords NULL and DEFAULT can be used
      for the values that are assigned to each column of the table. In this
      form, the keyword DEFAULT means the default value of the column and can
      be used only if the target column has a default value or is an IDENTITY
      or GENERATED column of the table.</simpara>

      <simpara>The <literal>&lt;override clause&gt;</literal> must be used
      when a value is explicitly assigned to a column that has been defined as
      GENERATED ALWAYS AS IDENTITY. The OVERRIDING SYSTEM VALUE clause must be
      used to override the sequence value with the user-supplied values. For
      columns defined as GENERATED BY DEFAULT AS IDENTITY, there is no need to
      use OVERRIDING when the user provides values to be used for the insert.
      The OVERRIDING USER VALUE clause can be used with all types of GENERATED
      columns and means the values provided by the user are simply ignored and
      new values generated by the system are used instead. Two examples of
      table definition are given below.</simpara>

      <informalexample>
        <programlisting> CREATE TABLE t1 (id INTEGER GENERATED ALWAYS AS IDENTITY(START WITH 100), name VARCHAR(20) PRIMARY KEY)
 CREATE TABLE t2 (id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY, name VARCHAR(20))
</programlisting>
      </informalexample>

      <para>In both examples below, the value inserted for the id column is
      14. In the first example, it is necessary to use OVERRIDING SYSTEM VALUE
      when inserting into the id column of table t1 because the column has
      been defined as GENERATED ALWAYS. In the second example, no OVERRIDING
      clause is required for the insert into table t2 as its id column is
      defined as GENERATED BY DEFAULT. In both examples, if there is an
      existing row with that value as primary key, a constraint violation
      exception is thrown.</para>

      <informalexample>
        <programlisting> INSERT INTO t1 (id, name) OVERRIDING SYSTEM VALUE VALUES ( 14, 'Test Value')
 INSERT INTO t2 (id, name) VALUES ( 14, 'Test Value')
</programlisting>
      </informalexample>

      <simpara>In the examples below, OVERRIDING USER VALUE is used to let the
      system generate values for the id column. The generated values override
      the value 14 in the first example, and the existing values for the id
      column in the table in the second example.</simpara>

      <informalexample>
        <programlisting> INSERT INTO t1 (id, name) OVERRIDING USER VALUE VALUES ( 14, 'Another Test Value')
 INSERT INTO t1 (id, name) OVERRIDING USER VALUE (SELECT * FROM t1)
</programlisting>
      </informalexample>

      <simpara>An array can be inserted into a column of the array type by
      using literals, by specifying a parameter in a prepared statement or an
      existing array returned by query expression. The last example below
      inserts an array.</simpara>

      <simpara>The rows that are inserted into the table are checked against
      all the constraints that have been declared on the table. The whole
      INSERT operation fails if any row fails to inserted due to constraint
      violation. Examples:</simpara>

      <informalexample>
        <programlisting> CREATE TABLE T (A INTEGER GENERATED BY DEFAULT AS IDENTITY, B INTEGER DEFAULT 2)
 INSERT INTO T DEFAULT VALUES /* all columns of T have DEFAULT clauses */
 INSERT INTO T (SELECT * FROM Z) /* table Z has the same columns as table T */
 INSERT INTO T (A,B) VALUES ((1,2),(3,NULL), (DEFAULT,6)) /* three rows are inserted into table T */
 ALTER TABLE T ADD COLUMN D VARCHAR(10) ARRAY /* an ARRAY column is added */
 INSERT INTO T VALUES DEFAULT, 3, ARRAY['hot','cold']
</programlisting>
      </informalexample>

      <para>If the table contains an IDENTITY column, the value for this
      column for the last row inserted by a session can be retrieved using a
      call to the IDENTITY() function. This call returns the last value
      inserted by the calling session. When the insert statement is executed
      with a JDBC Statement or PreparedStatement method, the
      <methodname>getGeneratedKeys()</methodname> method of Statement can be
      used to retrieve not only the IDENTITY column, but also any GENERATED
      computed column, or any other column. The
      <methodname>getGeneratedKeys()</methodname> returns a ResultSet with one
      or more columns. This contains one row per inserted row, and can
      therefore return all the generated columns for a multi-row
      insert.</para>

      <para>There are three methods of specifying which generated keys should
      be returned. The first method does not specify the columns of the table.
      With this method, the returned ResultSet will have a column for each
      column of the table that is defined as GENERATED ... AS IDENTITY or
      GENERATED ... AS (&lt;expression&gt;). The two other methods require the
      user to specify which columns should be returned, either by column
      indexes, or by column names. With these methods, there is no restriction
      on which columns of the inserted values to be returned. This is
      especially useful when some columns have a default clause which is a
      function, or when there are BEFORE triggers on the table that may
      provide the inserted value for some of the columns.</para>

      <para>In MySQL syntax compatibility mode, HyperSQL supports INSERT
      IGNORE, REPLACE and ON DUPLICATE KEY UPDATE variations of the INSERT
      statement.</para>
    </section>

    <section xml:id="dac_update_statement">
      <title>Update Statement</title>

      <indexterm significance="preferred" type="sql">
        <primary>UPDATE</primary>
      </indexterm>

      <simpara><emphasis role="bold">UPDATE</emphasis></simpara>

      <simpara><emphasis>update statement: searched</emphasis></simpara>

      <simpara><literal>&lt;update statement: searched&gt; ::= UPDATE
      &lt;target table&gt; [ [ AS ] &lt;correlation name&gt; ] SET &lt;set
      clause list&gt; [ WHERE &lt;search condition&gt; ][ LIMIT &lt;fetch
      first row count&gt; ]</literal></simpara>

      <simpara>Update rows of a table. An UPDATE statement selects rows from
      the <literal>&lt;target table&gt;</literal> using an implicit SELECT
      statement formed in the following manner:</simpara>

      <simpara><literal>SELECT * FROM &lt;target table&gt; [ [ AS ]
      &lt;correlation name&gt; ] [ WHERE &lt;search condition&gt;
      ]</literal></simpara>

      <simpara>Then it applies the <literal>SET &lt;set clause
      list&gt;</literal> expression to each selected row.</simpara>

      <simpara>If the implicit SELECT returns no rows, no update takes place.
      When used in JDBC, the number of rows returned by the implicit SELECT is
      returned as the update count.</simpara>

      <simpara>If there are FOREIGN KEY constraints on other tables that
      reference the subject table, and the FOREIGN KEY constraints have
      referential actions, then rows from those other tables that reference
      the updated rows are updated, according to the specified referential
      actions.</simpara>

      <simpara>The rows that are updated are checked against all the
      constraints that have been declared on the table. The whole UPDATE
      operation fails if any row violates any constraint.</simpara>

      <simpara>The LIMIT clause, or alternatively the ROWNUM() function in the
      WHERE clause, can be used to limit the number of rows that are updated.
      This is useful when a very large number of rows needs to be updated. In
      this situation, you can perform the operation is chunks and commit after
      each chunk to reduce memory usage and the total time of the
      operation.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>set clause in UPDATE and MERGE statements</primary>
      </indexterm>

      <simpara><emphasis role="bold">set clause list</emphasis></simpara>

      <simpara><emphasis>set clause list</emphasis></simpara>

      <simpara><literal>&lt;set clause list&gt; ::= &lt;set clause&gt; [ {
      &lt;comma&gt; &lt;set clause&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;set clause&gt; ::= &lt;multiple column
      assignment&gt; | &lt;set target&gt; &lt;equals operator&gt; &lt;update
      source&gt;</literal></simpara>

      <simpara><literal>&lt;multiple column assignment&gt; ::= &lt;set target
      list&gt; &lt;equals operator&gt; &lt;assigned
      row&gt;</literal></simpara>

      <simpara><literal>&lt;set target list&gt; ::= &lt;left paren&gt; &lt;set
      target&gt; [ { &lt;comma&gt; &lt;set target&gt; }... ] &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;assigned row&gt; ::= &lt;contextually typed row
      value expression&gt;</literal></simpara>

      <simpara><literal>&lt;set target&gt; ::= &lt;column
      name&gt;</literal></simpara>

      <simpara><literal>&lt;update source&gt; ::= &lt;value expression&gt; |
      &lt;contextually typed value specification&gt;</literal></simpara>

      <simpara>Specify a list of assignments. This is used in UPDATE, MERGE
      and SET statements to assign values to a scalar or row target.</simpara>

      <simpara>Apart from setting a whole target to a value, a SET statement
      can set individual elements of an array to new values. The last example
      below shows this form of assignment to the array in the column named
      B.</simpara>

      <simpara>In the examples given below, UPDATE statements with single and
      multiple assignments are shown. Note in the third example, a SELECT
      statement is used to provide the update values for columns A and C,
      while the update value for column B is given separately. The SELECT
      statement must return exactly one row . In this example the SELECT
      statement refers to the existing value for column C in its search
      condition.</simpara>

      <informalexample>
        <programlisting> UPDATE T SET A = 5 WHERE ...
 UPDATE T SET (A, B) = (1, NULL) WHERE ...
 UPDATE T SET (A, C) = (SELECT X, Y FROM U WHERE Z = C), B = 10 WHERE ...
 UPDATE T SET A = 3, B[3] = 'warm'
</programlisting>
      </informalexample>
    </section>

    <section xml:id="dac_merge_statement">
      <title>Merge Statement</title>

      <indexterm significance="preferred" type="sql">
        <primary>MERGE INTO</primary>
      </indexterm>

      <simpara><emphasis role="bold">MERGE INTO</emphasis></simpara>

      <simpara><emphasis>merge statement</emphasis></simpara>

      <simpara><literal>&lt;merge statement&gt; ::= MERGE INTO &lt;target
      table&gt; [ [ AS ] &lt;merge correlation name&gt; ] USING &lt;table
      reference&gt; ON &lt;search condition&gt; &lt;merge operation
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;merge correlation name&gt; ::= &lt;correlation
      name&gt;</literal></simpara>

      <simpara><literal>&lt;merge operation specification&gt; ::= &lt;merge
      when clause&gt;...</literal></simpara>

      <simpara><literal>&lt;merge when clause&gt; ::= &lt;merge when matched
      clause&gt; | &lt;merge when not matched clause&gt;</literal></simpara>

      <simpara><literal>&lt;merge when matched clause&gt; ::= WHEN MATCHED [
      AND &lt;search condition&gt; ] THEN &lt;merge update or delete
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;merge when not matched clause&gt; ::= WHEN NOT
      MATCHED [ AND &lt;search condition&gt; ] THEN &lt;merge insert
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;merge update specification&gt; ::= UPDATE SET
      &lt;set clause list&gt;</literal></simpara>

      <simpara><literal>&lt;merge delete specification&gt; ::= DELETE
      </literal></simpara>

      <simpara><literal>&lt;merge insert specification&gt; ::= INSERT [
      &lt;left paren&gt; &lt;insert column list&gt; &lt;right paren&gt; ] [
      &lt;override clause&gt; ] VALUES &lt;merge insert value
      list&gt;</literal></simpara>

      <simpara><literal>&lt;merge insert value list&gt; ::= &lt;left paren&gt;
      &lt;merge insert value element&gt; [ { &lt;comma&gt; &lt;merge insert
      value element&gt; }... ] &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;merge insert value element&gt; ::= &lt;value
      expression&gt; | &lt;contextually typed value
      specification&gt;</literal></simpara>

      <simpara>Update rows, delete rows or insert new rows into the
      <literal>&lt;target table&gt;</literal>. The MERGE statement uses a
      second table, specified by <literal>&lt;table reference&gt;</literal>,
      to determine the rows to be updated or inserted. It is possible to use
      the statement only to update rows, to delete rows or to insert rows, but
      usually both update and insert are specified.</simpara>

      <simpara>The <literal>&lt;search condition&gt;</literal> matches each
      row of the <literal>&lt;table reference&gt;</literal> with each row of
      the <literal>&lt;target table&gt;</literal>. If the two rows match then
      the UPDATE clause is used to update the matching row of the target
      table. Those rows of <literal>&lt;table reference&gt;</literal> that
      have no matching rows are then used to insert new rows into the
      <literal>&lt;target table&gt;</literal>. Therefore, a MERGE statement
      can update or delete between 0 and all the rows of the
      <literal>&lt;target table&gt;</literal> and can insert between 0 and the
      number of the rows in <literal>&lt;table reference&gt;</literal> into
      the <literal>&lt;target table&gt;</literal>. If any row in the
      <literal>&lt;target table&gt;</literal> matches more than one row in
      <literal>&lt;table reference&gt;</literal> a cardinality error is
      raised. On the other hand, several rows in the <literal>&lt;target
      table&gt;</literal> can match a single row in <literal>&lt;table
      reference&gt;</literal> without any error. The constraints and
      referential actions specified on the database tables are enforced the
      same way as for an update, a delete and an insert statement.</simpara>

      <simpara>The optional <literal>&lt;search condition&gt;</literal> in
      each WHEN clause can be used to filter (reduce) the rows for the
      particular action.</simpara>

      <simpara>HyperSQL allows only one UPDATE, INSERT or DELETE operation in
      a MERGE statement. If both UPDATE and DELETE are used, the operations
      are performed in the order they appear in the MERGE statement. If the
      search conditions of both operations apply to the same row, only the
      first operation is performed.</simpara>

      <simpara>The MERGE statement can be used with only the WHEN NOT MATCHED
      clause as a conditional INSERT statement that inserts a row if no
      existing rows match a condition.</simpara>

      <simpara>In the first example below, the table originally contains two
      rows for different furniture. The <literal>&lt;table
      reference&gt;</literal> is the <literal>(VALUES(1, 'conference table'),
      (14, 'sofa'), (5, 'coffee table'))</literal> expression, which evaluates
      to a table with 3 rows. When the x value for a row matches an existing
      row, then the existing row is updated. When the x value does not match,
      the row is inserted. Therefore one row of table t is updated from
      'dining table' to 'conference table', and two rows are inserted into
      table t. The second example uses a SELECT statement as the source of the
      values for the MERGE.</simpara>

      <simpara>In the third example, a new row in inserted into the table only
      when the primary key for the new row does not exist. This example uses
      parameters and should be executed as a JDBC PreparedStatement. The
      parameter is cast as INTEGER because the MERGE statement does not
      determine the types of values in the USING clause.</simpara>

      <simpara>In the fourth example, existing rows that match are
      deleted.</simpara>

      <informalexample>
        <programlisting> CREATE TABLE t (id INT PRIMARY KEY, description VARCHAR(100))
 INSERT INTO t VALUES (1, 'dining table'), (2, 'deck chair')

 MERGE INTO t USING (VALUES(1, 'conference table'), (14, 'sofa'), (5, 'coffee table')) 
   AS vals(x,y) ON t.id = vals.x
   WHEN MATCHED THEN UPDATE SET t.description = vals.y
   WHEN NOT MATCHED THEN INSERT VALUES vals.x, vals.y

 MERGE INTO t USING (SELECT * FROM tt WHERE acol = 2) AS vals(x,y) ON t.id = vals.x
   WHEN MATCHED THEN UPDATE SET t.description = vals.y
   WHEN NOT MATCHED THEN INSERT VALUES vals.x, vals.y

 MERGE INTO t USING (VALUES(CAST(? AS INT))) AS vals(x) ON t.id = vals.x
   WHEN NOT MATCHED THEN INSERT VALUES vals.x, ?

 MERGE INTO t USING (SELECT * FROM tt WHERE acol = 2) AS vals(x,y) ON t.id = vals.x
   WHEN MATCHED THEN DELETE
   WHEN NOT MATCHED THEN INSERT VALUES vals.x, vals.y
</programlisting>
      </informalexample>
    </section>
  </section>

  <section xml:id="dac_diagnostics_state">
    <title>Diagnostics and State</title>

    <para>HyperSQL supports some SQL statements, expressions, functions, and
    Java methods that report on the most recently executed statement.</para>

    <para>The <literal>IDENTITY()</literal> function returns the last inserted
    identity value for the current session.</para>

    <para>The <literal>GET DIAGNOSTICS</literal> statement is supported to a
    limited extent. The built-in function <literal>DIAGNOSTICS()</literal> is
    an alternative. These are normally used in SQL/PSM routines to check the
    result of the last data update operation.</para>

    <indexterm significance="preferred" type="sql">
      <primary>GET DIAGNOSTICS</primary>
    </indexterm>

    <simpara><emphasis role="bold">GET DIAGNOSTICS</emphasis></simpara>

    <simpara><emphasis>get diagnostics statement</emphasis></simpara>

    <simpara><literal>&lt;get diagnostics statement&gt; ::= GET DIAGNOSTICS
    &lt;simple target value specification&gt; = ROW_COUNT</literal></simpara>

    <para>The <literal>&lt;simple target value specification&gt;</literal> is
    a session variable, or a routine variable or OUT parameter.</para>

    <para>The keyword <literal>ROW_COUNT</literal> specifies the row count
    returned by the last executed statement. For INSERT, UPDATE, DELETE and
    MERGE statements, this is the number of rows affected by the statement.
    This is the same value as returned by JDBC
    <literal>executeUpdate()</literal> methods. For all other statements, zero
    is returned.</para>

    <para>The value of <literal>ROW_COUNT</literal> is stored in the specified
    target.</para>

    <para>This statement is often used in CREATE PROCEDURE statements.</para>

    <para>In future versions, more options will be supported for diagnostics
    values.</para>
  </section>
</chapter>
