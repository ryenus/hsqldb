<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="dataaccess-title">Data Access and Change</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <pubdate>$Date$</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2009 Fred Toussi. Permission is granted to distribute
      this document without any alteration under the terms of the HSQLDB
      license. Additional permission is granted to the HSQL Development Group
      to distribute this document with or without alterations under the terms
      of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section>
    <title>Overview</title>

    <para>HyperSQL data access and data change statements are fully compatible
    with the latest SQL Standard. There are a few extensions and some
    relaxation or rules, but these do not affect statements that are written
    to the Standard syntax. There is full support for classic SQL, as
    specified by SQL-92, and many enhancements added in later versions of the
    standard.</para>
  </section>

  <section>
    <title>Syntax Elements</title>

    <para>The syntax elements that can be used in data access and data change
    statements are described in this section. The SQL Standard has a very
    extensive set of definitions for these elements. The BNF definitions given
    here are sometimes simplified.</para>

    <section>
      <title>Literals</title>

      <para>Literals are used to express constant values. The general type of
      a literal is known by its format. The specific type is based on
      conventions.</para>

      <indexterm significance="preferred" type="sql">
        <primary>unicode escape elements</primary>
      </indexterm>

      <simpara><emphasis role="bold">unicode escape
      elements</emphasis></simpara>

      <simpara><emphasis>unicode escape elements</emphasis></simpara>

      <simpara><literal>&lt;Unicode escape specifier&gt; ::= [ UESCAPE
      &lt;quote&gt;&lt;Unicode escape character&gt;&lt;quote&gt; ]
      </literal></simpara>

      <simpara><literal>&lt;Unicode escape value&gt; ::= &lt;Unicode 4 digit
      escape value&gt; | &lt;Unicode 6 digit escape value&gt; | &lt;Unicode
      character escape value&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 4 digit escape value&gt; ::= &lt;Unicode
      escape
      character&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 6 digit escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;plus sign&gt;
      &lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode character escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;Unicode escape character&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode escape character&gt; ::= !! See the Syntax
      Rules.</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">character literal</emphasis></simpara>

      <simpara><emphasis>character literal</emphasis></simpara>

      <simpara><literal>&lt;character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ] &lt;quote&gt; [
      &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;introducer&gt; ::=
      &lt;underscore&gt;</literal></simpara>

      <simpara><literal>&lt;character representation&gt; ::= &lt;nonquote
      character&gt; | &lt;quote symbol&gt;</literal></simpara>

      <simpara><literal>&lt;nonquote character&gt; ::= !! See the Syntax
      Rules.</literal></simpara>

      <simpara><literal>&lt;quote symbol&gt; ::=
      &lt;quote&gt;&lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;national character string literal&gt; ::= N
      &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;Unicode character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ]
      U&lt;ampersand&gt;&lt;quote&gt; [ &lt;Unicode representation&gt;... ]
      &lt;quote&gt; [ { &lt;separator&gt; &lt;quote&gt; [ &lt;Unicode
      representation&gt;... ] &lt;quote&gt; }... ] &lt;Unicode escape
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode representation&gt; ::= &lt;character
      representation&gt; | &lt;Unicode escape value&gt;</literal></simpara>

      <simpara>The type of a character literal is CHARACTER. The length of the
      string literal is the character length of the type. If the quote
      character is used in a string, it is represented with two quote
      characters. Long literals can be divided into multiple quoted strings,
      separated with a space or end-of-line character. Example of character
      literals are given below:</simpara>

      <programlisting>'a literal'  ' string seperated' ' into parts'
'a string''s literal form with double quote character'
U&amp;'Unicode string'
</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>binary literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">binary literal</emphasis></simpara>

      <simpara><emphasis>binary literal</emphasis></simpara>

      <simpara><literal>&lt;binary string literal&gt; ::= X &lt;quote&gt; [
      &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;... ] &lt;hexit&gt;
      [ &lt;space&gt;... ] }... ] &lt;quote&gt; [ { &lt;separator&gt;
      &lt;quote&gt; [ &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;...
      ] &lt;hexit&gt; [ &lt;space&gt;... ] }... ] &lt;quote&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;hexit&gt; ::= &lt;digit&gt; | A | B | C | D | E |
      F | a | b | c | d | e | f</literal></simpara>

      <simpara>The type of a binary literal is BINARY. The octet length of
      the binary literal is the length of the type. Case-insensitive
      hexadecimal charaters are used in the binary string. Each pair of
      characters in the literal represents a byte in the binary string. Long
      literals can be divided into multiple quoted strings, separated with a
      space or end-of-line character.</simpara>

      <programlisting>X'1abACD34' 'Af'</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>bit literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">bit literal</emphasis></simpara>

      <simpara><emphasis>bit literal</emphasis></simpara>

      <simpara><literal>&lt;bit string literal&gt; ::= B &lt;quote&gt; [
      &lt;bit&gt; ... ] &lt;quote&gt; [ { &lt;separator&gt; &lt;quote&gt; [
      &lt;bit&gt;... ] &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;bit&gt; ::= 0 | 1</literal></simpara>

      <simpara>The type of a binary literal is BIT. The bit length of the bit
      literal is the length of the type. Digits 0 and 1 are used to represent
      the bits. Long literals can be devided into multiple quoted strings,
      separated with a space or end-of-line character.</simpara>

      <programlisting>B'10001001' '00010'</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>numeric literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric literal</emphasis></simpara>

      <simpara><emphasis>numeric literal</emphasis></simpara>

      <simpara><literal>&lt;signed numeric literal&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned numeric literal&gt; ::= &lt;exact numeric
      literal&gt; | &lt;approximate numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;exact numeric literal&gt; ::= &lt;unsigned
      integer&gt; [ &lt;period&gt; [ &lt;unsigned integer&gt; ] ] |
      &lt;period&gt; &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;sign&gt; ::= &lt;plus sign&gt; | &lt;minus
      sign&gt;</literal></simpara>

      <simpara><literal>&lt;approximate numeric literal&gt; ::=
      &lt;mantissa&gt; E &lt;exponent&gt;</literal></simpara>

      <simpara><literal>&lt;mantissa&gt; ::= &lt;exact numeric
      literal&gt;</literal></simpara>

      <simpara><literal>&lt;exponent&gt; ::= &lt;signed
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;signed integer&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned integer&gt; ::=
      &lt;digit&gt;...</literal></simpara>

      <simpara>The type of an exact numeric literal without a decimal point is
      INTEGER, BIGINT, or DECIMAL, depending on the value of the literal (the
      smallest type that can represent the value is the type). The precision
      of a decimal literal is the number of digits of the literal. The type of
      an exact numeric literal with a decimal piont is DECIMAL. The precision
      and scale of the literal is used for the type. The type of an
      approximate numeric literal is DOUBLE.</simpara>

      <programlisting>12
34.35
+12E-2
</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>boolean literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean literal</emphasis></simpara>

      <simpara><emphasis>boolean literal</emphasis></simpara>

      <simpara><literal>&lt;boolean literal&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara>The boolean literal is one of the specified keywords.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime and interval literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime and interval
      literal</emphasis></simpara>

      <simpara><emphasis>datetime and interval literal</emphasis></simpara>

      <simpara><literal>&lt;datetime literal&gt; ::= &lt;date literal&gt; |
      &lt;time literal&gt; | &lt;timestamp literal&gt;</literal></simpara>

      <simpara><literal>&lt;date literal&gt; ::= DATE &lt;date
      string&gt;</literal></simpara>

      <simpara><literal>&lt;time literal&gt; ::= TIME &lt;time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp literal&gt; ::= TIMESTAMP &lt;timestamp
      string&gt;</literal></simpara>

      <simpara><literal>&lt;date string&gt; ::= &lt;quote&gt; &lt;unquoted
      date string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time string&gt; ::= &lt;quote&gt; &lt;unquoted
      time string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp string&gt; ::= &lt;quote&gt;
      &lt;unquoted timestamp string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time zone interval&gt; ::= &lt;sign&gt; &lt;hours
      value&gt; &lt;colon&gt; &lt;minutes value&gt;</literal></simpara>

      <simpara><literal>&lt;date value&gt; ::= &lt;years value&gt; &lt;minus
      sign&gt; &lt;months value&gt; &lt;minus sign&gt; &lt;days
      value&gt;</literal></simpara>

      <simpara><literal>&lt;time value&gt; ::= &lt;hours value&gt;
      &lt;colon&gt; &lt;minutes value&gt; &lt;colon&gt; &lt;seconds
      value&gt;</literal></simpara>

      <simpara><literal>&lt;interval literal&gt; ::= INTERVAL [ &lt;sign&gt; ]
      &lt;interval string&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval string&gt; ::= &lt;quote&gt; &lt;unquoted
      interval string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted date string&gt; ::= &lt;date
      value&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted time string&gt; ::= &lt;time value&gt; [
      &lt;time zone interval&gt; ]</literal></simpara>

      <simpara><literal>&lt;unquoted timestamp string&gt; ::= &lt;unquoted
      date string&gt; &lt;space&gt; &lt;unquoted time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted interval string&gt; ::= [ &lt;sign&gt; ]
      { &lt;year-month literal&gt; | &lt;day-time literal&gt;
      }</literal></simpara>

      <simpara><literal>&lt;year-month literal&gt; ::= &lt;years value&gt; [
      &lt;minus sign&gt; &lt;months value&gt; ] | &lt;months
      value&gt;</literal></simpara>

      <simpara><literal>&lt;day-time literal&gt; ::= &lt;day-time interval&gt;
      | &lt;time interval&gt;</literal></simpara>

      <simpara><literal>&lt;day-time interval&gt; ::= &lt;days value&gt; [
      &lt;space&gt; &lt;hours value&gt; [ &lt;colon&gt; &lt;minutes value&gt;
      [ &lt;colon&gt; &lt;seconds value&gt; ] ] ]</literal></simpara>

      <simpara><literal>&lt;time interval&gt; ::= &lt;hours value&gt; [
      &lt;colon&gt; &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] ] | &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] | &lt;seconds value&gt;</literal></simpara>

      <simpara><literal>&lt;years value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;months value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;days value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;hours value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;minutes value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;seconds value&gt; ::= &lt;seconds integer
      value&gt; [ &lt;period&gt; [ &lt;seconds fraction&gt; ]
      ]</literal></simpara>

      <simpara><literal>&lt;seconds integer value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;seconds fraction&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;datetime value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara>The type of a datetime or interval type is specified in the
      literal. The fractional second precision is is number of digits in the
      fractional part of the literal.</simpara>

      <programlisting>DATE '2008-08-08'
TIME '20:08:08'
TIMESTAMP '2008-08-08 20:08:08'

INTERVAL '10' DAY
INTERVAL -'08:08' MINUTE TO SECOND
</programlisting>
    </section>

    <section>
      <title>Basic Elements</title>

      <para>The basic elements are</para>

      <indexterm significance="preferred" type="sql">
        <primary>identifier chain</primary>
      </indexterm>

      <simpara><emphasis role="bold">identifier chain</emphasis></simpara>

      <simpara><emphasis>identifier chain</emphasis></simpara>

      <simpara><literal>&lt;identifier chain&gt; ::= &lt;identifier&gt; [ {
      &lt;period&gt; &lt;identifier&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;basic identifier chain&gt; ::= &lt;identifier
      chain&gt;</literal></simpara>

      <simpara>A period-separated chain of identifiers. The identifiers in an
      identifier chain can refer to database objects in a hierarchy. The
      possible hierarchies ars as follows. In each hierarchy, elements from
      the start or the end can be missing, but the order of elements cannot be
      changed.</simpara>

      <simpara>catalog, schema, database object</simpara>

      <simpara>catalog, schema, table, column</simpara>

      <simpara>correlation name, column</simpara>

      <simpara>If the first itentifier specifies a catalog, the negenrallly
      refer to database objects</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>column reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">column reference</emphasis></simpara>

      <simpara><emphasis>column reference</emphasis></simpara>

      <simpara><literal>&lt;column reference&gt; ::= &lt;basic identifier
      chain&gt; | MODULE &lt;period&gt; &lt;qualified identifier&gt;
      &lt;period&gt; &lt;column name&gt;</literal></simpara>

      <simpara>Reference a column.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SQL parameter reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">SQL parameter
      reference</emphasis></simpara>

      <simpara><emphasis>SQL parameter reference</emphasis></simpara>

      <simpara><literal>&lt;SQL parameter reference&gt; ::= &lt;basic
      identifier chain&gt;</literal></simpara>

      <simpara>Reference an SQL parameter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>contextually typed value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">contextually typed value
      specification</emphasis></simpara>

      <simpara><emphasis>contextually typed value
      specification</emphasis></simpara>

      <simpara><literal>&lt;contextually typed value specification&gt; ::=
      &lt;null specification&gt; | &lt;default
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;null specification&gt; ::=
      NULL</literal></simpara>

      <simpara><literal>&lt;default specification&gt; ::=
      DEFAULT</literal></simpara>

      <simpara>Specify a value whose data type is inferred from its context.
      DEFAULT is used for assignments to table columns that have a default
      value. NULL can be used only in a context where the type of the value is
      known. For example, a NULL can be assigned to a a column of the table in
      an INSERT or UPDATE statement, because the type of the column is known.
      But if NULL is used in a SELECT list, it must be used in a CAST
      statement.</simpara>
    </section>

    <section>
      <title>Value Expression</title>

      <indexterm significance="preferred" type="sql">
        <primary>value expression primary</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression
      primary</emphasis></simpara>

      <simpara><emphasis>value expression primary</emphasis></simpara>

      <simpara><literal>&lt;value expression primary&gt; ::= &lt;parenthesized
      value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized value expression&gt; ::= &lt;left
      paren&gt; &lt;value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;nonparenthesized value expression primary&gt; ::=
      &lt;unsigned value specification&gt; | &lt;column reference&gt; |
      &lt;set function specification&gt; | &lt;scalar subquery&gt; | &lt;case
      expression&gt; | &lt;cast specification&gt; | &lt;next value
      expression&gt; | &lt;routine invocation&gt;</literal></simpara>

      <simpara>Specify a value that is syntactically self-delimited.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">value specification</emphasis></simpara>

      <simpara><emphasis>value specification</emphasis></simpara>

      <simpara><literal>&lt;value specification&gt; ::= &lt;literal&gt; |
      &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned value specification&gt; ::= &lt;unsigned
      literal&gt; | &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;target specification&gt; ::= &lt;host parameter
      specification&gt; | &lt;SQL parameter reference&gt; | &lt;column
      reference&gt; | &lt;dynamic parameter
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;simple target specification&gt; ::= &lt;host
      parameter specification&gt; | &lt;SQL parameter reference&gt; |
      &lt;column reference&gt; | &lt;embedded variable
      name&gt;</literal></simpara>

      <simpara><literal>&lt;host parameter specification&gt; ::= &lt;host
      parameter name&gt; [ &lt;indicator parameter&gt; ]</literal></simpara>

      <simpara><literal>&lt;dynamic parameter specification&gt; ::=
      &lt;question mark&gt;</literal></simpara>

      <simpara>Specify one or more values, host parameters, SQL parameters,
      dynamic parameters, or host variables.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>row value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">row value expression</emphasis></simpara>

      <simpara><emphasis>row value expression</emphasis></simpara>

      <simpara><literal>&lt;row value expression&gt; ::= &lt;row value special
      case&gt; | &lt;explicit row value constructor&gt; </literal></simpara>

      <simpara><literal>&lt;row value predicand&gt; ::= &lt;row value special
      case&gt; | &lt;row value constructor predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value special case&gt; ::=
      &lt;nonparenthesized value expression primary&gt;</literal></simpara>

      <simpara><literal>&lt;explicit row value constructor&gt; ::= &lt;left
      paren&gt; &lt;row value constructor element&gt; &lt;comma&gt; &lt;row
      value constructor element list&gt; &lt;right paren&gt; | ROW &lt;left
      paren&gt; &lt;row value constructor element list&gt; &lt;right paren&gt;
      | &lt;row subquery&gt;</literal></simpara>

      <simpara>**</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>set function specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">set function
      specification</emphasis></simpara>

      <simpara><emphasis>set function specification</emphasis></simpara>

      <simpara><literal>&lt;set function specification&gt; ::= &lt;aggregate
      function&gt; | &lt;grouping operation&gt;</literal></simpara>

      <simpara><literal>&lt;grouping operation&gt; ::= GROUPING &lt;left
      paren&gt; &lt;column reference&gt; [ { &lt;comma&gt; &lt;column
      reference&gt; }... ] &lt;right paren&gt;</literal></simpara>

      <simpara>Specify a value derived by the application of a function to an
      argument.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>COALESCE expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">COALESCE</emphasis></simpara>

      <simpara><emphasis>coalesce expression</emphasis></simpara>

      <simpara><literal>&lt;coalesce expression&gt; := COALESCE &lt;left
      paren&gt; &lt;value expression&gt; { &lt;comma&gt; &lt;value
      expression&gt; }... &lt;right paren&gt;</literal></simpara>

      <simpara>Replace null values with another value. The coalesce expression
      has two or more instances of &lt;value expression&gt;. If the first
      &lt;value expression&gt; evaluates to a non-null value, it is returned
      as the result of the coalesce expression. If it is null, the next
      &lt;value expression&gt; is evaluated and if it evaluates to a non-non
      value, it is returned, and so on.</simpara>

      <simpara>The type of the return value of a COALESCE expression is the
      aggregate type of the types of all the &lt;value expression&gt;
      instances. Therefore, any value returned is implicitly cast to this
      type.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>NULLIF expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">NULLIF</emphasis></simpara>

      <simpara><emphasis>nullif expression</emphasis></simpara>

      <simpara><literal>&lt;nullif expression&gt; := NULLIF &lt;left paren&gt;
      &lt;value expression&gt; &lt;comma&gt; &lt;value expression&gt;
      &lt;right paren&gt;</literal></simpara>

      <simpara>Return NULL if two values are equal. If the result of the first
      <literal>&lt;value expression&gt;</literal> is not equal to the result
      of the second, then it is returned, otherwise NULL is returned. The type
      of the return value is the type of the first <literal>&lt;value
      expression&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>case expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">CASE</emphasis></simpara>

      <simpara><emphasis>case specification</emphasis></simpara>

      <simpara><literal>&lt;case specification&gt; ::= &lt;simple case&gt; |
      &lt;searched case&gt;</literal></simpara>

      <simpara><literal>&lt;simple case&gt; ::= CASE &lt;case operand&gt;
      &lt;simple when clause&gt;... [ &lt;else clause&gt; ]
      END</literal></simpara>

      <simpara><literal>&lt;searched case&gt; ::= CASE &lt;searched when
      clause&gt;... [ &lt;else clause&gt; ] END</literal></simpara>

      <simpara><literal>&lt;simple when clause&gt; ::= WHEN &lt;when operand
      list&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;searched when clause&gt; ::= WHEN &lt;search
      condition&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;else clause&gt; ::= ELSE
      &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;case operand&gt; ::= &lt;row value predicand&gt; |
      &lt;overlaps predicate part 1&gt;</literal></simpara>

      <simpara><literal>&lt;when operand list&gt; ::= &lt;when operand&gt; [ {
      &lt;comma&gt; &lt;when operand&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;when operand&gt; ::= &lt;row value predicand&gt; |
      &lt;comparison predicate part 2&gt; | &lt;between predicate part 2&gt; |
      &lt;in predicate part 2&gt; | &lt;character like predicate part 2&gt; |
      &lt;octet like predicate part 2&gt; | &lt;similar predicate part 2&gt; |
      &lt;regex like predicate part 2&gt; | &lt;null predicate part 2&gt; |
      &lt;quantified comparison predicate part 2&gt; | &lt;match predicate
      part 2&gt; | &lt;overlaps predicate part 2&gt; | &lt;distinct predicate
      part 2&gt;</literal></simpara>

      <simpara><literal>&lt;result&gt; ::= &lt;result expression&gt; |
      NULL</literal></simpara>

      <simpara><literal>&lt;result expression&gt; ::= &lt;value
      expression&gt;</literal></simpara>

      <simpara>Specify a conditional value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CAST</primary>
      </indexterm>

      <simpara><emphasis role="bold">CAST</emphasis></simpara>

      <simpara><emphasis>cast specification</emphasis></simpara>

      <simpara><literal>&lt;cast specification&gt; ::= CAST &lt;left paren&gt;
      &lt;cast operand&gt; AS &lt;cast target&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;cast operand&gt; ::= &lt;value expression&gt; |
      &lt;implicitly typed value specification&gt;</literal></simpara>

      <simpara><literal>&lt;cast target&gt; ::= &lt;domain name&gt; | &lt;data
      type&gt;</literal></simpara>

      <simpara>Specify a data conversion. Data conversion takes place
      automatically among variants of a general type. For example numeric
      values are freely converted from one type to another in
      expressions.</simpara>

      <simpara>Explicit type conversion is necessary in two cases. One case is
      to determine the type of a NULL value. The other case is to force
      conversion for special purposes. Values of data types can be cast to a
      character type. The exception is BINARY and OTHER types. The result of
      the cast is the literal expression of the value. Conversely, a value of
      a character type can be converted to another type if the character value
      is a literal representation of the value in the target type. Special
      conversions are possible between numeric and interval types, which are
      described in the section covering interval types.</simpara>

      <programlisting>CAST (NULL AS TIMESTAMP)
CAST ('   199  ' AS INTEGER) = 199
CAST ('tRue ' AS BOOLEAN) = TRUE
CAST (INTERVAL '2' DAY AS INTEGER) = 2
CAST ('1987-04-21' AS DATE) = DATE '1992-04-21'
</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>NEXT VALUE FOR</primary>
      </indexterm>

      <simpara><emphasis role="bold">NEXT VALUE FOR</emphasis></simpara>

      <simpara><emphasis>next value expression</emphasis></simpara>

      <simpara><literal>&lt;next value expression&gt; ::= NEXT VALUE FOR
      &lt;sequence generator name&gt;</literal></simpara>

      <simpara>Return the next value of a sequence generator. This expression
      can be used as a select list element in queries, or in assignments to
      table columns in data change statements. If the expression is used more
      than once in a single row that is being evaluated, the same value is
      returned for each invocation. After evaluation of the particular row is
      complete, the sequence generator will return a different value from the
      old value. The new value is generated by the sequence generator by
      adding the increment to the last value it generated.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression</emphasis></simpara>

      <simpara><emphasis>value expression</emphasis></simpara>

      <simpara><literal>&lt;value expression&gt; ::= &lt;numeric value
      expression&gt; | &lt;string value expression&gt; | &lt;datetime value
      expression&gt; | &lt;interval value expression&gt; | &lt;boolean value
      expression&gt; | &lt;row value expression&gt;</literal></simpara>

      <simpara>An expression that returns a value. The value can be a single
      value, or a row consisting more than one value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      expression</emphasis></simpara>

      <simpara><emphasis>numeric value expression</emphasis></simpara>

      <simpara><literal>&lt;numeric value expression&gt; ::= &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;plus sign&gt; &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;minus sign&gt;
      &lt;term&gt;</literal></simpara>

      <simpara><literal>&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;factor&gt; | &lt;term&gt; &lt;solidus&gt;
      &lt;factor&gt;</literal></simpara>

      <simpara><literal>&lt;factor&gt; ::= [ &lt;sign&gt; ] &lt;numeric
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;numeric primary&gt; ::= &lt;value expression
      primary&gt; | &lt;numeric value function&gt;</literal></simpara>

      <simpara>Specify a numeric value. The BNF indicates that
      <literal>&lt;asterisk&gt;</literal> and
      <literal>&lt;solidus&gt;</literal> (the operators for multiplication and
      division) have precedence over <literal>&lt;minus sign&gt;</literal> and
      <literal>&lt;plus sign&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      function</emphasis></simpara>

      <simpara><emphasis>numeric value function</emphasis></simpara>

      <simpara><literal>&lt;numeric value function&gt; ::= &lt;position
      expression&gt; | &lt;extract expression&gt; | &lt;length expression&gt;
      ...</literal></simpara>

      <simpara>Specify a function yielding a value of type numeric. The
      supported numeric value functions are listed and described in Built-In
      Functions chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>string value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">string value
      expression</emphasis></simpara>

      <simpara><emphasis>string value expression</emphasis></simpara>

      <simpara><literal>&lt;string value expression&gt; ::= &lt;string
      concatenation&gt; | &lt;string factor&gt;</literal></simpara>

      <simpara><literal>&lt;string factor&gt; ::= &lt;value expression
      primary&gt; | &lt;string value function&gt;</literal></simpara>

      <simpara><literal>&lt;string concatenation&gt; ::= &lt;string value
      expression&gt; &lt;concatenation operator&gt; &lt;string
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;concatenation operator&gt; ::=
      ||</literal></simpara>

      <simpara>Specify a character string value, a binary string value, or a
      bit string value. The BNF indicates that a string value expression can
      be formed by concatenation of two or more <literal>&lt;value expression
      primary&gt;</literal>. The types of the <literal>&lt;value expression
      primary&gt;</literal> elements must be compatible, that is, all must be
      string, or binary or bit string values.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">character value
      function</emphasis></simpara>

      <simpara><emphasis>string value function</emphasis></simpara>

      <simpara><literal>&lt;string value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function that returns a character string or binary
      string. The supported character value functions are listed and described
      in Built-In Functions chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime value
      expression</emphasis></simpara>

      <simpara><emphasis>datetime value expression</emphasis></simpara>

      <simpara><literal>&lt;datetime value expression&gt; ::= &lt;datetime
      term&gt; | &lt;interval value expression&gt; &lt;plus sign&gt;
      &lt;datetime term&gt; | &lt;datetime value expression&gt; &lt;plus
      sign&gt; &lt;interval term&gt; | &lt;datetime value expression&gt;
      &lt;minus sign&gt; &lt;interval term&gt;</literal></simpara>

      <simpara><literal>&lt;datetime term&gt; ::= &lt;datetime
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;datetime factor&gt; ::= &lt;datetime primary&gt; [
      &lt;time zone&gt; ]</literal></simpara>

      <simpara><literal>&lt;datetime primary&gt; ::= &lt;value expression
      primary&gt; | &lt;datetime value function&gt;</literal></simpara>

      <simpara><literal>&lt;time zone&gt; ::= AT &lt;time zone
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;time zone specifier&gt; ::= LOCAL | TIME ZONE
      &lt;interval primary&gt;</literal></simpara>

      <simpara>Specify a datetime value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime value
      function</emphasis></simpara>

      <simpara><emphasis>datetime value function</emphasis></simpara>

      <simpara><literal>&lt;datetime value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function that returns a datetime value. The supported
      datetime value functions are listed and described in Built-In Functions
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval term</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval term</emphasis></simpara>

      <simpara><emphasis>interval value expression</emphasis></simpara>

      <simpara><literal>&lt;interval value expression&gt; ::= &lt;interval
      term&gt; | &lt;interval value expression 1&gt; &lt;plus sign&gt;
      &lt;interval term 1&gt; | &lt;interval value expression 1&gt; &lt;minus
      sign&gt; &lt;interval term 1&gt; | &lt;left paren&gt; &lt;datetime value
      expression&gt; &lt;minus sign&gt; &lt;datetime term&gt; &lt;right
      paren&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval term&gt; ::= &lt;interval factor&gt; |
      &lt;interval term 2&gt; &lt;asterisk&gt; &lt;factor&gt; | &lt;interval
      term 2&gt; &lt;solidus&gt; &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;interval factor&gt;</literal></simpara>

      <simpara><literal>&lt;interval factor&gt; ::= [ &lt;sign&gt; ]
      &lt;interval primary&gt;</literal></simpara>

      <simpara><literal>&lt;interval primary&gt; ::= &lt;value expression
      primary&gt; [ &lt;interval qualifier&gt; ] | &lt;interval value
      function&gt;</literal></simpara>

      <simpara><literal>&lt;interval value expression 1&gt; ::= &lt;interval
      value expression&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 1&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 2&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara>Specify an interval value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval absolute value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval absolute value
      function</emphasis></simpara>

      <simpara><emphasis>interval value function</emphasis></simpara>

      <simpara><literal>&lt;interval value function&gt; ::= &lt;interval
      absolute value function&gt;</literal></simpara>

      <simpara><literal>&lt;interval absolute value function&gt; ::= ABS
      &lt;left paren&gt; &lt;interval value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a function that returns the absolute value of an
      interval. If the interval is neagive, it is negated, otherwise the
      original value is returned.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>boolean value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean value
      expression</emphasis></simpara>

      <simpara><emphasis>boolean value expression</emphasis></simpara>

      <simpara><literal>&lt;boolean value expression&gt; ::= &lt;boolean
      term&gt; | &lt;boolean value expression&gt; OR &lt;boolean
      term&gt;</literal></simpara>

      <simpara><literal>&lt;boolean term&gt; ::= &lt;boolean factor&gt; |
      &lt;boolean term&gt; AND &lt;boolean factor&gt;</literal></simpara>

      <simpara><literal>&lt;boolean factor&gt; ::= [ NOT ] &lt;boolean
      test&gt;</literal></simpara>

      <simpara><literal>&lt;boolean test&gt; ::= &lt;boolean primary&gt; [ IS
      [ NOT ] &lt;truth value&gt; ]</literal></simpara>

      <simpara><literal>&lt;truth value&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara><literal>&lt;boolean primary&gt; ::= &lt;predicate&gt; |
      &lt;boolean predicand&gt;</literal></simpara>

      <simpara><literal>&lt;boolean predicand&gt; ::= &lt;parenthesized
      boolean value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized boolean value expression&gt; ::=
      &lt;left paren&gt; &lt;boolean value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a boolean value.</simpara>
    </section>

    <section>
      <title>Predicates</title>

      <simpara>Predicates are conditions with two sides and evaluate to a
      boolean value. The <literal>&lt;row value predicand&gt;</literal> is the
      common element of all predicates. This element is a generalisation of
      both <literal>&lt;value expression&gt;</literal>, which is a scalar, and
      of <literal>&lt;explicit row value constructor&gt;</literal>, which is a
      row. The two sides of a predicate can be split in CASE statements where
      the <literal>&lt;row value predicand&gt;</literal> is part of multiple
      predicates.</simpara>

      <simpara>The number of fields in all <literal>&lt;row value
      predicand&gt;</literal> used in predicates must be the same and the
      types of the fields in the same position must be compatible for
      comparison. If either of these conditions does not hold, an exception is
      raised. The number of fields in a row is called the
      <glossterm>degree</glossterm>.</simpara>

      <simpara>In many predicates, if a <literal>&lt;row value
      predicand&gt;</literal> evaluates to NULL, the result of the predicate
      is UNKNOWN. If the <literal>&lt;row value predicand&gt;</literal> has
      more than one element, and one or more of the fields evaluate to NULL,
      the result depends on the particular predicate.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>comparison predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">comparison predicand</emphasis></simpara>

      <simpara><emphasis>comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;comparison predicate&gt; ::= &lt;row value
      predicand&gt; &lt;comparison predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;comparison predicate part 2&gt; ::= &lt;comp
      op&gt; &lt;row value predicand&gt;</literal></simpara>

      <simpara><literal>&lt;comp op&gt; ::= &lt;equals operator&gt; | &lt;not
      equals operator&gt; | &lt;less than operator&gt; | &lt;greater than
      operator&gt; | &lt;less than or equals operator&gt; | &lt;greater than
      or equals operator&gt;</literal></simpara>

      <simpara>Specify a comparison of two row values. If either
      <literal>&lt;row value predicand&gt;</literal> evaluates to NULL, the
      result of <literal>&lt;comparison predicate&gt;</literal> is UNKNOWN.
      Otherwise, the result is TRUE, FALSE or UNKNOWN.</simpara>

      <simpara>If the <glossterm>degree</glossterm> of <literal>&lt;row value
      predicand&gt;</literal> is larger than one, comparison is performed
      between each field and the corresponding field in the other
      <literal>&lt;row value predicand&gt;</literal> from left to right, one
      by one.</simpara>

      <simpara>When comparing two elements, if either field is NULL then the
      result is UNKNOWN.</simpara>

      <simpara>For <literal>&lt;equals operator&gt;</literal>, if the result
      of comparison is TRUE for all field, the result of the predicate is
      TRUE. If the result of comparison is FALSE for one field, the result of
      predicate is FALSE. Otherwise the result is UNKNOWN.</simpara>

      <simpara>The <literal>&lt;not equals operator&gt;</literal> is
      translated to <literal>NOT (&lt;row value predicand&gt; = &lt;row value
      predicand&gt;)</literal>.</simpara>

      <simpara>The <literal>&lt;less than or equals operator&gt;</literal> is
      translated to <literal>(&lt;row value predicand&gt; = &lt;row value
      predicand&gt;) OR (&lt;row value predicand&gt; &lt; &lt;row value
      predicand&gt;)</literal>. The <literal>&lt;greater than or equals
      operator&gt;</literal> is translated similarly.</simpara>

      <simpara>For the <literal>&lt;less than operator&gt;</literal> and
      <literal>&lt;greater than operator&gt;</literal>, if two fields at a
      given position are equal, then comparison continues to the next field.
      Otherwise, the result of the last performed comparison is returned as
      the result of the predicate. This means that if the first field is NULL,
      the result is always UNKNOWN.</simpara>

      <simpara>The logic that governs NULL values and UNKNOWN result is as
      follows: Suppose the NULL values were substituted by arbitrary real
      values. If substitution cannot change the result of the predicate, then
      the result is TRUE or FALSE, based on the existing non-NULL values,
      otherwise the result of the predicate is UNKNOWN.</simpara>

      <simpara>The examples of comparison given below use literals, but the
      literals actually represent the result of evaluation of some
      expression.</simpara>

      <programlisting>((1, 2, 3, 4) = (1, 2, 3, 4)) IS TRUE
((1, 2, 3, 4) = (1, 2, 3, 5)) IS FALSE
((1, 2, 3, 4) &lt; (1, 2, 3, 4)) IS FALSE
((1, 2, 3, 4) &lt; (1, 2, 3, 5)) IS TRUE
((NULL, 1, NULL) == (NULL, 1, NULL)) IS UNKNOWN  
((NULL, 1, NULL) = (NULL, 2, NULL)) IS FALSE  
((NULL, 1, NULL) &lt;&gt; (NULL, 2, NULL)) IS TRUE  
((NULL, 1, 2) &lt;all operators&gt; (NULL, 1, 2)) IS UNKNOWN
((1, NULL, ...) &lt; (1, 2, ...)) IS UNKNOWN  
((1, NULL, ...) &lt; (2, NULL, ...)) IS TRUE
((2, NULL, ...) &lt; (1, NULL, ...)) IS FALSE
</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>BETWEEN predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">BETWEEN</emphasis></simpara>

      <simpara><emphasis>between predicate</emphasis></simpara>

      <simpara><literal>&lt;between predicate&gt; ::= &lt;row value
      predicand&gt; &lt;between predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;between predicate part 2&gt; ::= [ NOT ] BETWEEN [
      ASYMMETRIC | SYMMETRIC ] &lt;row value predicand&gt; AND &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a range comparison. The default is ASYMMETRIC. The
      expression <literal>X BETWEEN Y AND Z</literal> is equivalent to
      <literal>(X &gt;= Y AND X &lt;= Z)</literal>. Therefore if Y &gt; Z, the
      BETWEEN expression is never true. The expression <literal>X BETWEEN
      SYMMETRIC Y AND Z</literal> is equivalent to <literal>(X &gt;= Y AND X
      &lt;= Z) OR (X &gt;= Z AND X &lt;= Y)</literal>. The expression
      <literal>Z NOT BETWEEN ...</literal> is equivalent to <literal>NOT (Z
      BETWEEN ...)</literal>. If any of the three <literal>&lt;row value
      predicand&gt;</literal> evaluates to NULL, the result is
      UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IN predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IN</emphasis></simpara>

      <simpara><emphasis>in predicate</emphasis></simpara>

      <simpara><literal>&lt;in predicate&gt; ::= &lt;row value predicand&gt;
      &lt;in predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;in predicate part 2&gt; ::= [ NOT ] IN &lt;in
      predicate value&gt;</literal></simpara>

      <simpara><literal>&lt;in predicate value&gt; ::= &lt;table subquery&gt;
      | &lt;left paren&gt; &lt;in value list&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;in value list&gt; ::= &lt;row value expression&gt;
      [ { &lt;comma&gt; &lt;row value expression&gt; }...
      ]</literal></simpara>

      <simpara>Specify a quantified comparison. The expression <literal>X NOT
      IN Y is</literal> equivalent to <literal>NOT (X IN Y)</literal>. The
      <literal>( &lt;in value list&gt; )</literal> is converted into a table
      with one or more rows. The expression <literal>X IN Y</literal> is
      equivalent to <literal>X = ANY Y</literal>, which is a
      <literal>&lt;quantified comparison predicate&gt;</literal>.</simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, the result is FALSE. Otherwise the <literal>&lt;row value
      predicand&gt;</literal> is compared one by one with each row of the
      <literal>&lt;table subquery&gt;</literal>.</simpara>

      <simpara>If the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>LIKE predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">LIKE</emphasis></simpara>

      <simpara><emphasis>like predicate</emphasis></simpara>

      <simpara><literal>&lt;like predicate&gt; ::= &lt;character like
      predicate&gt; | &lt;octet like predicate&gt;</literal></simpara>

      <simpara><literal>&lt;character like predicate&gt; ::= &lt;row value
      predicand&gt; &lt;character like predicate part
      2&gt;</literal></simpara>

      <simpara><literal>&lt;character like predicate part 2&gt; ::= [ NOT ]
      LIKE &lt;character pattern&gt; [ ESCAPE &lt;escape character&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;character pattern&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape character&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;octet like predicate&gt; ::= &lt;row value
      predicand&gt; &lt;octet like predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;octet like predicate part 2&gt; ::= [ NOT ] LIKE
      &lt;octet pattern&gt; [ ESCAPE &lt;escape octet&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;octet pattern&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape octet&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara>Specify a pattern-match comparison. The <literal>&lt;row value
      predicand&gt;</literal> is always a <literal>&lt;string value
      expression&gt;</literal> of character or binary type. The
      <literal>&lt;character pattern&gt;</literal> or <literal>&lt;octet
      pattern&gt;</literal> is a <literal>&lt;string value
      expression&gt;</literal> in which the underscore and percent characters
      have special meanings. The underscore means match any one character,
      while the percent means match a sequence of zero or more characters. The
      <literal>&lt;escape character&gt;</literal> or <literal>&lt;escape
      octet&gt;</literal> is also a <literal>&lt;string value
      expression&gt;</literal> that evaluates to a string of exactly one
      character length. If the underscore or the percent is required as normal
      characters in the pattern, the specified <literal>&lt;escape
      character&gt;</literal> or <literal>&lt;escape octet&gt;</literal> can
      be used in the pattern before the underscore or the percent. The
      <literal>&lt;row value predicand&gt;</literal> is compared with the
      <literal>&lt;character pattern&gt;</literal> and the result of
      comparison is returned. If any of the expressions in the predicate
      evaluates to NULL, the result of the predicate is UNKNOWN. The
      expression <literal>A NOT LIKE B</literal> is equivalent to <literal>NOT
      (A LIKE B)</literal>. If the length of the escape is not 1 or it is used
      in the pattern not immediately before an underscore or a percent
      character, an exception is raised.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IS NULL predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IS NULL</emphasis></simpara>

      <simpara><emphasis>null predicate</emphasis></simpara>

      <simpara><literal>&lt;null predicate&gt; ::= &lt;row value predicand&gt;
      &lt;null predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;null predicate part 2&gt; ::= IS [ NOT ]
      NULL</literal></simpara>

      <simpara>Specify a test for a null value. The expression <literal>X IS
      NOT NULL</literal> is NOT equivalent to <literal>NOT (X IS
      NULL)</literal>if the degree of the <literal>&lt;row value
      predicand&gt;</literal> is larger than 1. The rules are: If all fields
      are null, <literal>X IS NULL</literal> is TRUE and <literal>X IS NOT
      NULL</literal> is FALSE. If only some fields are null, both <literal>X
      IS NULL</literal> and <literal>X IS NOT NULL</literal> are FALSE. If all
      fields are not null, <literal>X IS NULL</literal> is FALSE and
      <literal>X IS NOT NULL</literal> is TRUE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALL and ANY predicates</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALL and ANY</emphasis></simpara>

      <simpara><emphasis>quantified comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;quantified comparison predicate&gt; ::= &lt;row
      value predicand&gt; &lt;quantified comparison predicate part
      2&gt;</literal></simpara>

      <simpara><literal>&lt;quantified comparison predicate part 2&gt; ::=
      &lt;comp op&gt; &lt;quantifier&gt; &lt;table
      subquery&gt;</literal></simpara>

      <simpara><literal>&lt;quantifier&gt; ::= &lt;all&gt; |
      &lt;some&gt;</literal></simpara>

      <simpara><literal>&lt;all&gt; ::= ALL</literal></simpara>

      <simpara><literal>&lt;some&gt; ::= SOME | ANY</literal></simpara>

      <simpara>Specify a quantified comparison. For a quantified comparison,
      the <literal>&lt;row value predicand&gt;</literal> is compared one by
      one with each row of the <literal>&lt;table sub
      query&gt;</literal>.</simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, then if <literal>ALL</literal> is specified the result is TRUE,
      but if <literal>SOME</literal> or <literal>ANY</literal> is specified
      the result is FALSE.</simpara>

      <simpara>If <literal>ALL</literal> is specified, if the comparison is
      TRUE for all rows, the result of the predicate is TRUE. If the
      comparison is FALSE for at least one row, the result is FALSE. Otherwise
      the result is UNKNOWN.</simpara>

      <simpara>If <literal>SOME</literal> or <literal>ANY</literal> is
      specified, if the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN. Note that the IN predicate is
      equivalent to the SOME or ANY predicate using the <literal>&lt;equals
      operator&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>EXISTS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">EXISTS</emphasis></simpara>

      <simpara><emphasis>exists predicate</emphasis></simpara>

      <simpara><literal>&lt;exists predicate&gt; ::= EXISTS &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for a non-empty set. If the evaluation of
      <literal>&lt;table subquery&gt;</literal> results in one or more rows,
      then the expression is TRUE, otherwise FALSE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>UNIQUE predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

      <simpara><emphasis>unique predicate</emphasis></simpara>

      <simpara><literal>&lt;unique predicate&gt; ::= UNIQUE &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for the absence of duplicate rows. The result of
      the test is either TRUE or FALSE (never UNKNOWN). The rows of the
      <literal>&lt;table subquery&gt;</literal> that contain one or more NULL
      values are not considered for this test. If the rest of the rows are
      distinct from each other, the result of the test is TRUE, otherwise it
      is FALSE. The distinctness of rows X and Y is tested with the predicate
      <literal>X IS DISTINCT FROM Y</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>MATCH predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">MATCH</emphasis></simpara>

      <simpara><emphasis>match predicate</emphasis></simpara>

      <simpara><literal>&lt;match predicate&gt; ::= &lt;row value
      predicand&gt; &lt;match predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;match predicate part 2&gt; ::= MATCH [ UNIQUE ] [
      SIMPLE | PARTIAL | FULL ] &lt;table subquery&gt;</literal></simpara>

      <simpara>Specify a test for matching rows. The default is MATCH SIMPLE
      without UNIQUE. The result of the test is either TRUE or FALSE (never
      UNKNOWN).</simpara>

      <simpara>The interpretation of NULL values is different from other
      predicates and quite counter-intuitive. If the <literal>&lt;row value
      predicand&gt;</literal> is NULL, or all of its fields are NULL, the
      result is TRUE.</simpara>

      <simpara>Otherwise, the <literal>&lt;row value predicand&gt;</literal>
      is compared with each row of the <literal>&lt;table
      subquery&gt;</literal>.</simpara>

      <simpara>If SIMPLE is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is TRUE. Otherwise if
      <literal>&lt;row value predicate&gt; </literal>is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches. Otherwise the result is FALSE.</simpara>

      <simpara>If PARTIAL is specified, if the non-null values
      <literal>&lt;row value predicate&gt; </literal>are equal to those in one
      or more rows of <literal>&lt;table subquery&gt;</literal> the result is
      TRUE if UNIQUE is not specified, or if UNIQUE is specified and only one
      row matches. Otherwise the result is FALSE.</simpara>

      <simpara>If FULL is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is FALSE. Otherwise if
      <literal>&lt;row value predicate&gt;</literal> is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>OVERLAPS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">OVERLAPS</emphasis></simpara>

      <simpara><emphasis>overlaps predicate</emphasis></simpara>

      <simpara><literal>&lt;overlaps predicate&gt; ::= &lt;overlaps predicate
      part 1&gt; &lt;overlaps predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;overlaps predicate part 1&gt; ::= &lt;row value
      predicand 1&gt;</literal></simpara>

      <simpara><literal>&lt;overlaps predicate part 2&gt; ::= OVERLAPS &lt;row
      value predicand 2&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 1&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 2&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for an overlap between two datetime periods.
      Each <literal>&lt;row value predicand&gt;</literal> must have two fields
      and the fields together represent a datetime period. So the predicates
      is always in the form <literal>(X1, X2) OVERLAPS (Y1, Y2)</literal>. The
      first field is always a datetime value, while the second field is either
      a datetime value or an interval value. If the second value is an
      interval value, it is replaced with the sum of the datetime value and
      itself, for example <literal>(X1, X1 + X2) OVERLAPS (Y1, Y1 + Y
      2)</literal>. If any of the values is NULL, the result is UNKNOWN. The
      expression is true if there is there is any overlap between the two
      datetime periods.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>IS DISTINCT predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">IS DISTINCT</emphasis></simpara>

      <simpara><emphasis>is distinct predicate</emphasis></simpara>

      <simpara><literal>&lt;distinct predicate&gt; ::= &lt;row value predicand
      3&gt; &lt;distinct predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;distinct predicate part 2&gt; ::= IS [ NOT ]
      DISTINCT FROM &lt;row value predicand 4&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 3&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 4&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test of whether two row values are distinct. The
      result of the test is either TRUE or FALSE (never UNKNOWN). The
      <glossterm>degree</glossterm> the two <literal>&lt;row value
      predicand&gt;</literal> must be the same. Each field of the first
      <literal>&lt;row value predicand&gt;</literal> is compared to the field
      of the second <literal>&lt;row value predicand&gt;</literal> at the same
      position. If one field is NULL and the other is not NULL, or if the
      elements are NOT equal, then the result of the expression is TRUE. If no
      comparison result is TRUE, then the result of the predicate is FALSE.
      The expression <literal>X IS NOT DISTINCT FROM Y</literal> is equivalent
      to <literal>NOT (X IS DISTINCT FORM Y)</literal>.</simpara>
    </section>

    <section>
      <title></title>

      <indexterm significance="preferred" type="sql">
        <primary>search condition</primary>
      </indexterm>

      <simpara><emphasis role="bold">search condition</emphasis></simpara>

      <simpara><emphasis>search condition</emphasis></simpara>

      <simpara><literal>&lt;search condition&gt; ::= &lt;boolean value
      expression&gt;</literal></simpara>

      <simpara>Specify a condition that is TRUE, FALSE, or UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>PATH</primary>
      </indexterm>

      <simpara><emphasis role="bold">PATH</emphasis></simpara>

      <simpara><emphasis>path specification</emphasis></simpara>

      <simpara><literal>&lt;path specification&gt; ::= PATH &lt;schema name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;schema name list&gt; ::= &lt;schema name&gt; [ {
      &lt;comma&gt; &lt;schema name&gt; }... ]</literal></simpara>

      <simpara>Specify an order for searching for an SQL-invoked
      routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>routine invocation</primary>
      </indexterm>

      <simpara><emphasis role="bold">routine invocation</emphasis></simpara>

      <simpara><emphasis>routine invocation</emphasis></simpara>

      <simpara><literal>&lt;routine invocation&gt; ::= &lt;routine name&gt;
      &lt;SQL argument list&gt;</literal></simpara>

      <simpara><literal>&lt;routine name&gt; ::= [ &lt;schema name&gt;
      &lt;period&gt; ] &lt;qualified identifier&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument list&gt; ::= &lt;left paren&gt; [
      &lt;SQL argument&gt; [ { &lt;comma&gt; &lt;SQL argument&gt; }... ] ]
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument&gt; ::= &lt;value expression&gt; |
      &lt;target specification&gt;</literal></simpara>

      <simpara>Invoke an SQL-invoked routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>COLLATE</primary>
      </indexterm>

      <simpara><emphasis role="bold">COLLATE</emphasis></simpara>

      <simpara><emphasis>collate clause</emphasis></simpara>

      <simpara><literal>&lt;collate clause&gt; ::= COLLATE &lt;collation
      name&gt;</literal></simpara>

      <simpara>Specify a default collation.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>constraint name definition</emphasis></simpara>

      <simpara><literal>&lt;constraint name definition&gt; ::= CONSTRAINT
      &lt;constraint name&gt;</literal></simpara>

      <simpara><literal>&lt;constraint characteristics&gt; ::= &lt;constraint
      check time&gt; [ [ NOT ] DEFERRABLE ] | [ NOT ] DEFERRABLE [
      &lt;constraint check time&gt; ]</literal></simpara>

      <simpara><literal>&lt;constraint check time&gt; ::= INITIALLY DEFERRED |
      INITIALLY IMMEDIATE</literal></simpara>

      <simpara>Specify the name of a constraint and its
      characteristics.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>aggregate function</primary>
      </indexterm>

      <simpara><emphasis role="bold">aggregate function</emphasis></simpara>

      <simpara><emphasis>aggregate function</emphasis></simpara>

      <simpara><literal>&lt;aggregate function&gt; ::= COUNT &lt;left
      paren&gt; &lt;asterisk&gt; &lt;right paren&gt; [ &lt;filter clause&gt; ]
      | &lt;general set function&gt; [ &lt;filter clause&gt; ]
      </literal></simpara>

      <simpara><literal>&lt;general set function&gt; ::= &lt;set function
      type&gt; &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value
      expression&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;set function type&gt; ::= &lt;computational
      operation&gt;</literal></simpara>

      <simpara><literal>&lt;computational operation&gt; ::= AVG | MAX | MIN |
      SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP |
      VAR_POP</literal></simpara>

      <simpara><literal>&lt;set quantifier&gt; ::= DISTINCT |
      ALL</literal></simpara>

      <simpara><literal>&lt;filter clause&gt; ::= FILTER &lt;left paren&gt;
      WHERE &lt;search condition&gt; &lt;right paren&gt;</literal></simpara>

      <simpara>Specify a value computed from a collection of rows. An
      aggretate function is used exclusively in a <literal>&lt;query
      specification&gt;</literal> and its use transforms a normal query into
      an aggregate query returning a single row instead of the group of
      multiple rows that the original query returns. For example,
      <literal>SELECT acolumn &lt;table expression&gt;</literal> is a query
      that returns the value of acolumn for all the rows the satisfy the given
      condition. But <literal>SELECT MAX(acolumn) &lt;table
      expression&gt;</literal> returns only one row, containing the largest
      value in that column. The query <literal>SELECT COUNT(*) &lt;table
      expression&gt;</literal> returns the count of rows, while
      <literal>SELECT COUNT(acolumn) &lt;table expression&gt;</literal>
      returns the count of rows where <literal>acolumn IS NOT
      NULL</literal>.</simpara>

      <simpara>If the <literal>&lt;table expression&gt;</literal> is a grouped
      table, the aggregate function returns the result of the
      <literal>COUNT</literal> or <literal>&lt;computational
      operation&gt;</literal> for each group. In this case the result has the
      same number of rows as the original query. For example <literal>SELECT
      SUM(acolumn) &lt;table expression&gt;</literal> when <literal>&lt;table
      expression&gt;</literal> has a <literal>GROUP BY</literal> clause,
      returns the sum of values for <literal>acolumn</literal> in each
      group.</simpara>

      <simpara>The AVG and SUM operations can be performed on numeric
      expressions only. AVG returns the average value, while SUM returns the
      sum of all non-null values. MAX and MIN return the minimum or the
      maximum value. If all values are NULL, the operations return NULL. The
      <literal>COUNT(*)</literal> operation returns the count of all values,
      while <literal>COUNT(&lt;value expression&gt;)</literal> returns the
      count of non-NULL values.</simpara>

      <simpara>The EVERY, ANY and SOME operations can be performed on boolean
      expressions only. EVERY returns TRUE if all the values are TRUE,
      otherwise FALSE. ANY and SOME are the same operation and return TRUE if
      one of the values is TRUE, otherwise it returns FALSE.</simpara>

      <simpara>The other operations perform the statistical functions on
      numeric values.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>sort specification list</primary>
      </indexterm>

      <simpara><emphasis role="bold">sort specification
      list</emphasis></simpara>

      <simpara><emphasis>sort specification list</emphasis></simpara>

      <simpara><literal>&lt;sort specification list&gt; ::= &lt;sort
      specification&gt; [ { &lt;comma&gt; &lt;sort specification&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;sort specification&gt; ::= &lt;sort key&gt; [
      &lt;ordering specification&gt; ] [ &lt;null ordering&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;sort key&gt; ::= &lt;value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;ordering specification&gt; ::= ASC |
      DESC</literal></simpara>

      <simpara><literal>&lt;null ordering&gt; ::= NULLS FIRST | NULLS
      LAST</literal></simpara>

      <simpara>Specify a sort order. A sort operation is performed on the
      result of a <literal>&lt;query expresssion&gt;</literal> or
      <literal>&lt;query specification&gt;</literal> and sorts the result
      according to one or more <literal>&lt;sort key&gt;</literal>
      expressions. The <literal>&lt;sort key&gt;</literal> is usually a single
      column of the result, but in some cases it can be a column of the
      <literal>&lt;table expression&gt;</literal> that is not used in the
      select list.</simpara>
    </section>
  </section>

  <section>
    <title>Data Access Statements</title>

    <para>Data access statements access tables and return result tables, which
    are falsely called result sets, as they are not necessarily sets of rows,
    but multisets of rows.</para>

    <para>Result tables are formed by performing the following operations on
    base tables and views:</para>

    <para><glossterm>JOIN</glossterm> operations</para>

    <para><glossterm>SET</glossterm> and <glossterm>MULTISET</glossterm>
    operations</para>

    <para><glossterm>SELECTION</glossterm></para>

    <para><glossterm>PROJECTION</glossterm></para>

    <para><glossterm>COLUMN NAMING</glossterm></para>

    <section>
      <title>Joined Table</title>

      <para>Joins are operators with two table as the operands, resulting in a
      third table, called joined table. All join operators are evaluated left
      to right, therefore, with multiple joins, the table resulting from the
      first join operator becomes an operand of the next join operator.
      Parentheses can be used to group sequences of joined tables and change
      the evaluation order. So if more than two tables are joined together
      with join operators, the end result is also a joined table.</para>

      <indexterm significance="preferred" type="sql">
        <primary>CROSS JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">CROSS JOIN</emphasis></simpara>

      <para>The simplest form of join is CROSS JOIN. The CROSS JOIN of two
      tables is a table that has all the columns of the first table, followed
      by all the columns of the second table, in the original order. Each row
      of the first table is combined with each row of the second table to fill
      the rows of the new table. If the rows of each table form a set, then
      the rows of the CROSS JOIN table form the cartesian product of the rows
      of the two table operands.</para>

      <para>The CROSS JOIN can be expressed in two forms. The first form is
      <literal>A CROSS JOIN B</literal>. The second form is <literal>A,
      B</literal>.</para>

      <indexterm significance="preferred" type="sql">
        <primary>UNION JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNION JOIN</emphasis></simpara>

      <para>The UNION JOIN has limited use in queries. The result table has
      the same columns as that of CROSS JOIN. Each row of the first table is
      extended to the right with nulls and added to the new table. Each row of
      the second table is extended to the left with nulls and added to the new
      table. The UNION JOIN is expressed as <literal>A UNION JOIN B</literal>.
      This should not be confused with <literal>A UNION B</literal>, which is
      a set operation.</para>

      <indexterm significance="preferred" type="sql">
        <primary>JOIN with condition</primary>
      </indexterm>

      <simpara><emphasis role="bold">JOIN ... ON</emphasis></simpara>

      <para>The condition join is similar to CROSS JOIN, but a condition is
      tested for each row of the new table and the row is created only if the
      condition is true. This form of join is expressed as <literal>A JOIN B
      ON (&lt;search condition&gt;)</literal>.</para>

      <para>Equijoin is a condition join in which the search condition is an
      equality condition between on or more pairs of columns from the two
      table.</para>

      <indexterm significance="preferred" type="sql">
        <primary>JOIN USING</primary>
      </indexterm>

      <simpara><emphasis role="bold">JOIN ... USING</emphasis></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>NATURAL JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">NATURAL JOIN</emphasis></simpara>

      <para>These joins are similar to an equijoin but they cannot be
      expressed simply with an equijoin. The new table is formed with the
      specified or implied shared columns of the two tables, followed by the
      rest of the columns from each table. In NATURAL JOIN, the shared columns
      are all the column pairs that have the same name in the first and second
      table. In JOIN USING, only columns names that are specified by the USING
      clause are shared. The joins are expressed as <literal>A NATURAL JOIN
      B</literal>, and <literal>A JOIN B USING (&lt;comma separated column
      name list&gt;)</literal>.</para>

      <para>The columns of the joined table are formed by the following
      prodecures: In JOIN ... USING the shared columns are added to the joined
      table in the same order as they appear in the column name list. In
      NATURAL JOIN the shared columns are added to the joined table in the
      same order as they appear in the first table. In bother forms of join,
      the non-shared columns of the first table are added in the order they
      appear in the first table, finally the non-shared columns of the second
      table are added in the order they appear in the second table.</para>

      <para>The type of each shared column of the joined table is based on the
      type of the columns in the original tables. If the original types are
      not exactly the same, the type of the shared column is formed by type
      aggregation. Type aggregations selects a type that can represent values
      of both aggregated types. Simple type aggregation picks one of the
      types. For example SMALLINT and INTEGER, results in INTEGER, or
      VARCHAR(10) and VARCHAR(20) results in VARCHAR(20). More complex type
      aggregation inherits properties from both types. For example DECIMAL(8)
      and DECIMAL (6,2) results in DECIMAL (8,2).</para>

      <indexterm significance="preferred" type="sql">
        <primary>OUTER JOIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">OUTER JOIN</emphasis></simpara>

      <para>LEFT, RIGHT and FULL OUTER JOIN</para>

      <para>The three qualifiers can be added to all types of JOIN apart from
      CROSS JOIN and UNION JOIN. First the new table is populated with the
      rows from the original join. If LEFT is specified, all the rows from the
      first table that did not make it into the new table are extended to the
      right with nulls and added to the table. If RIGHT is specified, all the
      rows from the second table that did not make it into the new table are
      extended to the left with nulls and added to the table. If FULL is
      specified, the addition of leftover rows is performed from both the
      first and the second table. These forms are expressed by prefixing the
      join specification with the given keyword. For example <literal>A LEFT
      OUTER JOIN B ON (&lt;search condition&gt;)</literal> or <literal>A
      NATURAL FULL OUTER JOIN B</literal> or <literal>A FULL OUTER JOIN B
      USING (&lt;comma separated column name list&gt;)</literal>.</para>
    </section>

    <section>
      <title>Selection</title>

      <para>Despite the name, selection has nothing to do with the list of
      columns in a SELECT statement. It in fact refers to the search condition
      used to limit the rows that from a result table (selection of rows, not
      columns). In SQL, simple selection is expressed with a WHERE condition
      appended to a single table or a joined table. In some cases, this method
      of selection is the only method available. But when it is possible to
      performed the selection with join conditions, this is the better method,
      as it results in a clearer expression of the query.</para>

      <para>A different form of selection can also be performed on the result
      table after it has been formed according to all the other operations.
      This form of selection is specified by the FETCH ... ROWS and OFFSET
      clauses of a SELECT statement. In this form, the specified OFFSET rows
      are removed from start of the table, then up to the specified FETCH rows
      are kept and the rest of the rows are discarded.</para>
    </section>

    <section>
      <title>Projection</title>

      <para>Projection is selection of the columns from a simple or joined
      table to form a result table. Explicit projection is performed in the
      SELECT statement by specifying the select column list. Some form of
      projection is also performed in JOIN ... USING and NATURAL JOIN.</para>
    </section>

    <section>
      <title>Naming</title>

      <para>Naming is used to hide the original names of tables or table
      columns and to replace them with new names in the scope of the query.
      Naming is also used for defining names for computed columns.</para>

      <indexterm significance="preferred" type="sql">
        <primary>naming in joined table</primary>
      </indexterm>

      <simpara><emphasis role="bold">Naming in Joined
      Table</emphasis></simpara>

      <para>Naming is performed by adding a new name after a table's real name
      and by adding a list of column names after the new table name. Both
      table naming and column naming are optional, but table naming is
      required for column naming. The expression <literal>A [AS] X (&lt;comma
      separated column name list&gt;)</literal> means table A is used in the
      query expression as table X and its columns are named as in the given
      list. The original name A, or its original column names, are not visible
      in the scope of the query. The BNF is given below. The
      <literal>&lt;correlation name&gt;</literal> can be the same or different
      from the name of the table. The <literal>&lt;derived column
      list&gt;</literal> is a comma separated list of column names. The degree
      of this list must be equal to the degree of the table. The column names
      in the list must be distinct. They can be the same or different from the
      names of the table's columns.</para>

      <para><literal>&lt;table or query name&gt; [ [ AS ] &lt;correlation
      name&gt; [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right
      paren&gt; ] ]</literal></para>

      <simpara>In the examples below, the columns of the original tables are
      named (a, b, c, d, e, f). The two queries are equivalent. In the second
      query, the table and its columns are renamed and the new names are used
      in the WHERE clauses:</simpara>

      <programlisting>SELECT d, e, f FROM atable WHERE a + b = c
SELECT x, y, z FROM atable AS t (u, v, w, x, y, z)  WHERE u + v = w</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>naming in select list</primary>
      </indexterm>

      <simpara><emphasis role="bold">Naming in Select
      List</emphasis></simpara>

      <para>Naming in the SELECT list logically takes place after naming in
      the joined table. The new names for columns are not visible in the
      immediate query expression or query expression. They become visible in
      the ORDER BY clause and in the result table that is returned to the
      user. Or if the query expression is used as a derived table in an
      enclosing query expression.</para>

      <para>In the example below, the query is on the same table but with
      column renaming in the Select list. The new names are used in the ORDER
      BY clause:</para>

      <programlisting>SELECT x + y AS xysum, y + z AS yzsum FROM atable AS t (u, v, w, x, y, z)  WHERE u + v = w ORDER BY xysum, yzsum</programlisting>

      <para>If the names <literal>xysum</literal> or <literal>yzsum</literal>
      are not used, the computed columns cannot be referenced in the ORDER BY
      list.</para>

      <indexterm significance="preferred" type="sql">
        <primary>name reslution</primary>
      </indexterm>

      <simpara><emphasis role="bold">Name Resolution</emphasis></simpara>

      <simpara>In a joined table, if a column name appears in</simpara>
    </section>

    <section>
      <title>Set Operations</title>

      <indexterm significance="preferred" type="sql">
        <primary>SET OPERATIONS</primary>
      </indexterm>

      <simpara><emphasis role="bold">Set and Multiset
      Operations</emphasis></simpara>

      <para>While join operations generally result in laterally expanded
      tables, SET and COLLECTION operations are performed on two tables that
      have the same degree and result in a table of the same degree. The SET
      operations are UNION, INTERSECT and EXCEPT (difference). When each of
      these operations is performed on two tables, the collection of rows in
      each table and in the result is reduced to a set of rows, by eliminating
      duplicates. The set operations are then performed on the two tables,
      resulting in the new table which itself is a set of rows. Collection
      operations are similar but the tables are not reduced to sets before or
      after the operation and the result is not necessarily a set, but a
      collection of rows.</para>

      <para>The set operations on two tables A and B are: <literal>A UNION
      [DISTINCT] B</literal>, <literal>A INTERSECT [DISTINCT] B</literal> and
      <literal>A EXCEPT [DISTINCT] B</literal>. The result table is formed in
      the following way: The UNION operation adds all the rows from A and B
      into the new table, but avoids copying duplicate rows. The INTERSET
      operation copies only those rows from each table that also exist in the
      other table, but avoids copying duplicate rows. The EXCEPT operation
      copies those rows from the first table which do not exist in the second
      table, but avoids copying duplicate rows.</para>

      <para>The collection operations are similar to the set operations. They
      are <literal>A UNION ALL B</literal>, <literal>A INTERSECT ALL
      B</literal> and <literal>A EXCEPT ALL B</literal>. The UNION ALL
      operation adds all the rows from A and B into the new table. The
      INTERSET operation copies only those rows from each table that also
      exist in the other table. If n copies of a rows exists in one table, and
      m copies in the other table, the number of copies in the result table is
      the smaller of n and m. The EXCEPT operation copies those rows from the
      first table which do not exist in the second table. If n copies of a row
      exist in the first table and m copies in the second table the number of
      copies in the result table is n-m, or if n &lt; m, then zero.</para>
    </section>
  </section>

  <section>
    <title>Data Change Statements</title>

    <indexterm significance="preferred" type="sql">
      <primary>DELETE FROM</primary>
    </indexterm>

    <simpara><emphasis role="bold">DELETE FROM</emphasis></simpara>

    <simpara><emphasis>delete statement: searched</emphasis></simpara>

    <simpara><literal>&lt;delete statement: searched&gt; ::= DELETE FROM
    &lt;target table&gt; [ [ AS ] &lt;correlation name&gt; ] [ WHERE
    &lt;search condition&gt; ]</literal></simpara>

    <simpara>Delete rows of a table. The search condition is a
    <literal>&lt;boolean value expression&gt;</literal> that is evaluated for
    each row of the table. If the condition is true, the row is deleted. If
    the condition is not specified, all the rows of the table are
    deleted.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>TRUNCATE TABLE</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRUNCATE TABLE</emphasis></simpara>

    <simpara><emphasis>truncate table statement</emphasis></simpara>

    <simpara><literal>&lt;truncate table statement&gt; ::= TRUNCATE TABLE
    &lt;target table&gt; [ &lt;identity column restart option&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;identity column restart option&gt; ::= CONTINUE
    IDENTITY | RESTART IDENTITY</literal></simpara>

    <simpara>Delete all rows of a base table without causing any triggered
    action. This statement can only be used on base tables (not views). If the
    table is referenced in a FOREIGN KEY constraint, the statement causes an
    exception. The default for <literal>&lt;identity column restart
    option&gt;</literal> is CONTINUE IDENTITY. This means no change to the
    IDENTITY sequence of the table. If RESTART IDENTITY is specified, then the
    sequence is reset to its start value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>INSERT INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">INSERT INTO</emphasis></simpara>

    <simpara><emphasis>insert statement</emphasis></simpara>

    <simpara><literal>&lt;insert statement&gt; ::= INSERT INTO &lt;insertion
    target&gt; &lt;insert columns and source&gt;</literal></simpara>

    <simpara><literal>&lt;insertion target&gt; ::= &lt;table
    name&gt;</literal></simpara>

    <simpara><literal>&lt;insert columns and source&gt; ::= &lt;from
    subquery&gt; | &lt;from constructor&gt; | &lt;from
    default&gt;</literal></simpara>

    <simpara><literal>&lt;from subquery&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;query expression&gt;</literal></simpara>

    <simpara><literal>&lt;from constructor&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;contextually typed table value constructor&gt;</literal></simpara>

    <simpara><literal>&lt;override clause&gt; ::= OVERRIDING USER VALUE |
    OVERRIDING SYSTEM VALUE</literal></simpara>

    <simpara><literal>&lt;from default&gt; ::= DEFAULT
    VALUES</literal></simpara>

    <simpara><literal>&lt;insert column list&gt; ::= &lt;column name
    list&gt;</literal></simpara>

    <simpara>Create new rows in a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>MERGE INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">MERGE INTO</emphasis></simpara>

    <simpara><emphasis>merge statement</emphasis></simpara>

    <simpara><literal>&lt;merge statement&gt; ::= MERGE INTO &lt;target
    table&gt; [ [ AS ] &lt;merge correlation name&gt; ] USING &lt;table
    reference&gt; ON &lt;search condition&gt; &lt;merge operation
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge correlation name&gt; ::= &lt;correlation
    name&gt;</literal></simpara>

    <simpara><literal>&lt;merge operation specification&gt; ::= &lt;merge when
    clause&gt;...</literal></simpara>

    <simpara><literal>&lt;merge when clause&gt; ::= &lt;merge when matched
    clause&gt; | &lt;merge when not matched clause&gt;</literal></simpara>

    <simpara><literal>&lt;merge when matched clause&gt; ::= WHEN MATCHED [ AND
    &lt;search condition&gt; ] THEN &lt;merge update
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge when not matched clause&gt; ::= WHEN NOT
    MATCHED [ AND &lt;search condition&gt; ] THEN &lt;merge insert
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge update specification&gt; ::= UPDATE SET
    &lt;set clause list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert specification&gt; ::= INSERT [ &lt;left
    paren&gt; &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override
    clause&gt; ] VALUES &lt;merge insert value list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value list&gt; ::= &lt;left paren&gt;
    &lt;merge insert value element&gt; [ { &lt;comma&gt; &lt;merge insert
    value element&gt; }... ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value element&gt; ::= &lt;value
    expression&gt; | &lt;contextually typed value
    specification&gt;</literal></simpara>

    <simpara>Conditionally update rows of a table, or insert new rows into a
    table, or both.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>UPDATE</primary>
    </indexterm>

    <simpara><emphasis role="bold">UPDATE</emphasis></simpara>

    <simpara><emphasis>update statement: searched</emphasis></simpara>

    <simpara><literal>&lt;update statement: searched&gt; ::= UPDATE &lt;target
    table&gt; [ [ AS ] &lt;correlation name&gt; ] SET &lt;set clause list&gt;
    [ WHERE &lt;search condition&gt; ]</literal></simpara>

    <simpara>Update rows of a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>set clause in UPDATE and MERGE statements</primary>
    </indexterm>

    <simpara><emphasis role="bold">set clause list</emphasis></simpara>

    <simpara><emphasis>set clause list</emphasis></simpara>

    <simpara><literal>&lt;set clause list&gt; ::= &lt;set clause&gt; [ {
    &lt;comma&gt; &lt;set clause&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;set clause&gt; ::= &lt;multiple column
    assignment&gt; | &lt;set target&gt; &lt;equals operator&gt; &lt;update
    source&gt;</literal></simpara>

    <simpara><literal>&lt;multiple column assignment&gt; ::= &lt;set target
    list&gt; &lt;equals operator&gt; &lt;assigned row&gt;</literal></simpara>

    <simpara><literal>&lt;set target list&gt; ::= &lt;left paren&gt; &lt;set
    target&gt; [ { &lt;comma&gt; &lt;set target&gt; }... ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;assigned row&gt; ::= &lt;contextually typed row
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;set target&gt; ::= &lt;column
    name&gt;</literal></simpara>

    <simpara><literal>&lt;update source&gt; ::= &lt;value expression&gt; |
    &lt;contextually typed value specification&gt;</literal></simpara>

    <simpara>Specify a list of updates.</simpara>
  </section>
</chapter>
