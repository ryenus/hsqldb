<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="dataaccess-title">Data Access and Change</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision: 734 $</releaseinfo>

    <pubdate>$Date: 2009-01-08 19:19:51 +0000 (Thu, 08 Jan 2009) $</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2009 Fred Toussi. Permission is granted to distribute
      this document without any alteration under the terms of the HSQLDB
      license. Additional permission is granted to the HSQL Development Group
      to distribute this document with or without alterations under the terms
      of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section>
    <title>Overview</title>

    <para>HyperSQL data access and data change statements are fully compatible
    with the latest SQL Standard. There are a few extensions and some
    relaxation or rules, but these do not affect statements that are written
    to the Standard syntax. There is full support for classic SQL, as
    specified by SQL-92, and many enhancements added in later versions of the
    standard.</para>
  </section>

  <section>
    <title>Syntax Elements</title>

    <para>The syntax elements that can be used in data access and data change
    statements are described in this section. The SQL Standard has a very
    extensive set of definitions for these elements. The BNF definitions given
    here are sometimes simplified.</para>

    <section>
      <title>Literals</title>

      <para>Literals are used to express constant values.</para>

      <indexterm significance="preferred" type="sql">
        <primary>unicode escape elements</primary>
      </indexterm>

      <simpara><emphasis role="bold">unicode escape
      elements</emphasis></simpara>

      <simpara><emphasis>unicode escape elements</emphasis></simpara>

      <simpara><literal>&lt;Unicode escape specifier&gt; ::= [ UESCAPE
      &lt;quote&gt;&lt;Unicode escape character&gt;&lt;quote&gt; ]
      </literal></simpara>

      <simpara><literal>&lt;Unicode escape value&gt; ::= &lt;Unicode 4 digit
      escape value&gt; | &lt;Unicode 6 digit escape value&gt; | &lt;Unicode
      character escape value&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 4 digit escape value&gt; ::= &lt;Unicode
      escape
      character&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode 6 digit escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;plus sign&gt;
      &lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;&lt;hexit&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode character escape value&gt; ::= &lt;Unicode
      escape character&gt;&lt;Unicode escape character&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode escape character&gt; ::= !! See the Syntax
      Rules.</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">character literal</emphasis></simpara>

      <simpara><emphasis>character literal</emphasis></simpara>

      <simpara><literal>&lt;character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ] &lt;quote&gt; [
      &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;introducer&gt; ::=
      &lt;underscore&gt;</literal></simpara>

      <simpara><literal>&lt;character representation&gt; ::= &lt;nonquote
      character&gt; | &lt;quote symbol&gt;</literal></simpara>

      <simpara><literal>&lt;nonquote character&gt; ::= !! See the Syntax
      Rules.</literal></simpara>

      <simpara><literal>&lt;quote symbol&gt; ::=
      &lt;quote&gt;&lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;national character string literal&gt; ::= N
      &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt; [ {
      &lt;separator&gt; &lt;quote&gt; [ &lt;character representation&gt;... ]
      &lt;quote&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;Unicode character string literal&gt; ::= [
      &lt;introducer&gt;&lt;character set specification&gt; ]
      U&lt;ampersand&gt;&lt;quote&gt; [ &lt;Unicode representation&gt;... ]
      &lt;quote&gt; [ { &lt;separator&gt; &lt;quote&gt; [ &lt;Unicode
      representation&gt;... ] &lt;quote&gt; }... ] &lt;Unicode escape
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;Unicode representation&gt; ::= &lt;character
      representation&gt; | &lt;Unicode escape value&gt;</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>binary literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">binary literal</emphasis></simpara>

      <simpara><emphasis>binary literal</emphasis></simpara>

      <simpara><literal>&lt;binary string literal&gt; ::= X &lt;quote&gt; [
      &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;... ] &lt;hexit&gt;
      [ &lt;space&gt;... ] }... ] &lt;quote&gt; [ { &lt;separator&gt;
      &lt;quote&gt; [ &lt;space&gt;... ] [ { &lt;hexit&gt; [ &lt;space&gt;...
      ] &lt;hexit&gt; [ &lt;space&gt;... ] }... ] &lt;quote&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;hexit&gt; ::= &lt;digit&gt; | A | B | C | D | E |
      F | a | b | c | d | e | f</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric literal</emphasis></simpara>

      <simpara><emphasis>numeric literal</emphasis></simpara>

      <simpara><literal>&lt;signed numeric literal&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned numeric literal&gt; ::= &lt;exact numeric
      literal&gt; | &lt;approximate numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;exact numeric literal&gt; ::= &lt;unsigned
      integer&gt; [ &lt;period&gt; [ &lt;unsigned integer&gt; ] ] |
      &lt;period&gt; &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;sign&gt; ::= &lt;plus sign&gt; | &lt;minus
      sign&gt;</literal></simpara>

      <simpara><literal>&lt;approximate numeric literal&gt; ::=
      &lt;mantissa&gt; E &lt;exponent&gt;</literal></simpara>

      <simpara><literal>&lt;mantissa&gt; ::= &lt;exact numeric
      literal&gt;</literal></simpara>

      <simpara><literal>&lt;exponent&gt; ::= &lt;signed
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;signed integer&gt; ::= [ &lt;sign&gt; ]
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned integer&gt; ::=
      &lt;digit&gt;...</literal></simpara>

      <simpara><literal>&lt;datetime literal&gt; ::= &lt;date literal&gt; |
      &lt;time literal&gt; | &lt;timestamp literal&gt;</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime and interval literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime and interval
      literal</emphasis></simpara>

      <simpara><emphasis>datetime and interval literal</emphasis></simpara>

      <simpara><literal>&lt;date literal&gt; ::= DATE &lt;date
      string&gt;</literal></simpara>

      <simpara><literal>&lt;time literal&gt; ::= TIME &lt;time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp literal&gt; ::= TIMESTAMP &lt;timestamp
      string&gt;</literal></simpara>

      <simpara><literal>&lt;date string&gt; ::= &lt;quote&gt; &lt;unquoted
      date string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time string&gt; ::= &lt;quote&gt; &lt;unquoted
      time string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp string&gt; ::= &lt;quote&gt;
      &lt;unquoted timestamp string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;time zone interval&gt; ::= &lt;sign&gt; &lt;hours
      value&gt; &lt;colon&gt; &lt;minutes value&gt;</literal></simpara>

      <simpara><literal>&lt;date value&gt; ::= &lt;years value&gt; &lt;minus
      sign&gt; &lt;months value&gt; &lt;minus sign&gt; &lt;days
      value&gt;</literal></simpara>

      <simpara><literal>&lt;time value&gt; ::= &lt;hours value&gt;
      &lt;colon&gt; &lt;minutes value&gt; &lt;colon&gt; &lt;seconds
      value&gt;</literal></simpara>

      <simpara><literal>&lt;interval literal&gt; ::= INTERVAL [ &lt;sign&gt; ]
      &lt;interval string&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval string&gt; ::= &lt;quote&gt; &lt;unquoted
      interval string&gt; &lt;quote&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted date string&gt; ::= &lt;date
      value&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted time string&gt; ::= &lt;time value&gt; [
      &lt;time zone interval&gt; ]</literal></simpara>

      <simpara><literal>&lt;unquoted timestamp string&gt; ::= &lt;unquoted
      date string&gt; &lt;space&gt; &lt;unquoted time
      string&gt;</literal></simpara>

      <simpara><literal>&lt;unquoted interval string&gt; ::= [ &lt;sign&gt; ]
      { &lt;year-month literal&gt; | &lt;day-time literal&gt;
      }</literal></simpara>

      <simpara><literal>&lt;year-month literal&gt; ::= &lt;years value&gt; [
      &lt;minus sign&gt; &lt;months value&gt; ] | &lt;months
      value&gt;</literal></simpara>

      <simpara><literal>&lt;day-time literal&gt; ::= &lt;day-time interval&gt;
      | &lt;time interval&gt;</literal></simpara>

      <simpara><literal>&lt;day-time interval&gt; ::= &lt;days value&gt; [
      &lt;space&gt; &lt;hours value&gt; [ &lt;colon&gt; &lt;minutes value&gt;
      [ &lt;colon&gt; &lt;seconds value&gt; ] ] ]</literal></simpara>

      <simpara><literal>&lt;time interval&gt; ::= &lt;hours value&gt; [
      &lt;colon&gt; &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] ] | &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds
      value&gt; ] | &lt;seconds value&gt;</literal></simpara>

      <simpara><literal>&lt;years value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;months value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;days value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;hours value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;minutes value&gt; ::= &lt;datetime
      value&gt;</literal></simpara>

      <simpara><literal>&lt;seconds value&gt; ::= &lt;seconds integer
      value&gt; [ &lt;period&gt; [ &lt;seconds fraction&gt; ]
      ]</literal></simpara>

      <simpara><literal>&lt;seconds integer value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;seconds fraction&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;datetime value&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <indexterm significance="preferred" type="sql">
        <primary>boolean literal</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean literal</emphasis></simpara>

      <simpara><emphasis>boolean literal</emphasis></simpara>

      <simpara><literal>&lt;boolean literal&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara>Specify a non-null value.</simpara>

      <!-- From Foundation chapt. 6 -->
    </section>

    <section>
      <title>Data Type</title>

      <simpara>Data type definition</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>data type</primary>
      </indexterm>

      <simpara><emphasis role="bold">data type</emphasis></simpara>

      <simpara><emphasis>data type</emphasis></simpara>

      <simpara><literal>&lt;data type&gt; ::= &lt;predefined type&gt; |
      &lt;path-resolved user-defined type name&gt;</literal></simpara>

      <simpara><literal>&lt;predefined type&gt; ::= &lt;character string
      type&gt; [ CHARACTER SET &lt;character set specification&gt; ] [
      &lt;collate clause&gt; ] | &lt;national character string type&gt; [
      &lt;collate clause&gt; ] | &lt;binary string type&gt; | &lt;numeric
      type&gt; | &lt;boolean type&gt; | &lt;datetime type&gt; | &lt;interval
      type&gt;</literal></simpara>

      <simpara><literal>&lt;character string type&gt; ::= CHARACTER [ &lt;left
      paren&gt; &lt;character length&gt; &lt;right paren&gt; ] | CHAR [
      &lt;left paren&gt; &lt;character length&gt; &lt;right paren&gt; ] |
      CHARACTER VARYING &lt;left paren&gt; &lt;character length&gt; &lt;right
      paren&gt; | CHAR VARYING &lt;left paren&gt; &lt;character length&gt;
      &lt;right paren&gt; | VARCHAR &lt;left paren&gt; &lt;character
      length&gt; &lt;right paren&gt; | &lt;character large object
      type&gt;</literal></simpara>

      <simpara><literal>&lt;character large object type&gt; ::= CHARACTER
      LARGE OBJECT [ &lt;left paren&gt; &lt;character large object length&gt;
      &lt;right paren&gt; ] | CHAR LARGE OBJECT [ &lt;left paren&gt;
      &lt;character large object length&gt; &lt;right paren&gt; ] | CLOB [
      &lt;left paren&gt; &lt;character large object length&gt; &lt;right
      paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;national character string type&gt; ::= NATIONAL
      CHARACTER [ &lt;left paren&gt; &lt;character length&gt; &lt;right
      paren&gt; ] | NATIONAL CHAR [ &lt;left paren&gt; &lt;character
      length&gt; &lt;right paren&gt; ] | NCHAR [ &lt;left paren&gt;
      &lt;character length&gt; &lt;right paren&gt; ] | NATIONAL CHARACTER
      VARYING &lt;left paren&gt; &lt;character length&gt; &lt;right paren&gt;
      | NATIONAL CHAR VARYING &lt;left paren&gt; &lt;character length&gt;
      &lt;right paren&gt; | NCHAR VARYING &lt;left paren&gt; &lt;character
      length&gt; &lt;right paren&gt; | &lt;national character large object
      type&gt;</literal></simpara>

      <simpara><literal>&lt;national character large object type&gt; ::=
      NATIONAL CHARACTER LARGE OBJECT [ &lt;left paren&gt; &lt;character large
      object length&gt; &lt;right paren&gt; ] | NCHAR LARGE OBJECT [ &lt;left
      paren&gt; &lt;character large object length&gt; &lt;right paren&gt; ] |
      NCLOB [ &lt;left paren&gt; &lt;character large object length&gt;
      &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;binary string type&gt; ::= BINARY [ &lt;left
      paren&gt; &lt;length&gt; &lt;right paren&gt; ] | { BINARY VARYING |
      VARBINARY } &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; |
      &lt;binary large object string type&gt;</literal></simpara>

      <simpara><literal>&lt;binary large object string type&gt; ::= { BINARY
      LARGE OBJECT | BLOB } [ &lt;left paren&gt; &lt;large object length&gt;
      &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;numeric type&gt; ::= &lt;exact numeric type&gt; |
      &lt;approximate numeric type&gt;</literal></simpara>

      <simpara><literal>&lt;exact numeric type&gt; ::= NUMERIC [ &lt;left
      paren&gt; &lt;precision&gt; [ &lt;comma&gt; &lt;scale&gt; ] &lt;right
      paren&gt; ] | { DECIMAL | DEC} [ &lt;left paren&gt; &lt;precision&gt; [
      &lt;comma&gt; &lt;scale&gt; ] &lt;right paren&gt; ] | SMALLINT | INTEGER
      | INT | BIGINT</literal></simpara>

      <simpara><literal>&lt;approximate numeric type&gt; ::= FLOAT [ &lt;left
      paren&gt; &lt;precision&gt; &lt;right paren&gt; ] | REAL | DOUBLE
      PRECISION</literal></simpara>

      <simpara><literal>&lt;length&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;character length&gt; ::= &lt;unsigned integer&gt;
      [ &lt;char length units&gt; ]</literal></simpara>

      <simpara><literal>&lt;large object length&gt; ::= &lt;length&gt; [
      &lt;multiplier&gt; ] | &lt;large object length
      token&gt;</literal></simpara>

      <simpara><literal>&lt;character large object length&gt; ::= &lt;large
      object length&gt; [ &lt;char length units&gt; ]</literal></simpara>

      <simpara><literal>&lt;char length units&gt; ::= CHARACTERS |
      OCTETS</literal></simpara>

      <simpara><literal>&lt;precision&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;scale&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;boolean type&gt; ::= BOOLEAN</literal></simpara>

      <simpara><literal>&lt;datetime type&gt; ::= DATE | TIME [ &lt;left
      paren&gt; &lt;time precision&gt; &lt;right paren&gt; ] [ &lt;with or
      without time zone&gt; ] | TIMESTAMP [ &lt;left paren&gt; &lt;timestamp
      precision&gt; &lt;right paren&gt; ] [ &lt;with or without time zone&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;with or without time zone&gt; ::= WITH TIME ZONE |
      WITHOUT TIME ZONE</literal></simpara>

      <simpara><literal>&lt;time precision&gt; ::= &lt;time fractional seconds
      precision&gt;</literal></simpara>

      <simpara><literal>&lt;timestamp precision&gt; ::= &lt;time fractional
      seconds precision&gt;</literal></simpara>

      <simpara><literal>&lt;time fractional seconds precision&gt; ::=
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;interval type&gt; ::= INTERVAL &lt;interval
      qualifier&gt;</literal></simpara>

      <simpara>Specify a data type.</simpara>
    </section>

    <section>
      <title>Basic Elements</title>

      <para>The basic elements are</para>

      <indexterm significance="preferred" type="sql">
        <primary>identifier chain</primary>
      </indexterm>

      <simpara><emphasis role="bold">identifier chain</emphasis></simpara>

      <simpara><emphasis>identifier chain</emphasis></simpara>

      <simpara><literal>&lt;identifier chain&gt; ::= &lt;identifier&gt; [ {
      &lt;period&gt; &lt;identifier&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;basic identifier chain&gt; ::= &lt;identifier
      chain&gt;</literal></simpara>

      <simpara>Disambiguate a period-separated chain of identifiers.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>column reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">column reference</emphasis></simpara>

      <simpara><emphasis>column reference</emphasis></simpara>

      <simpara><literal>&lt;column reference&gt; ::= &lt;basic identifier
      chain&gt; | MODULE &lt;period&gt; &lt;qualified identifier&gt;
      &lt;period&gt; &lt;column name&gt;</literal></simpara>

      <simpara>Reference a column.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SQL parameter reference</primary>
      </indexterm>

      <simpara><emphasis role="bold">SQL parameter
      reference</emphasis></simpara>

      <simpara><emphasis>SQL parameter reference</emphasis></simpara>

      <simpara><literal>&lt;SQL parameter reference&gt; ::= &lt;basic
      identifier chain&gt;</literal></simpara>

      <simpara>Reference an SQL parameter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>contextually typed value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">contextually typed value
      specification</emphasis></simpara>

      <simpara><emphasis>contextually typed value
      specification</emphasis></simpara>

      <simpara><literal>&lt;contextually typed value specification&gt; ::=
      &lt;null specification&gt; | &lt;default
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;null specification&gt; ::=
      NULL</literal></simpara>

      <simpara><literal>&lt;default specification&gt; ::=
      DEFAULT</literal></simpara>

      <simpara>Specify a value whose data type is to be inferred from its
      context. DEFAULT is used for assignments to table columns that have a
      default value. NULL is used in many contexts where</simpara>
    </section>

    <section>
      <title>Value Expression</title>

      <indexterm significance="preferred" type="sql">
        <primary>value expression primary</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression
      primary</emphasis></simpara>

      <simpara><emphasis>value expression primary</emphasis></simpara>

      <simpara><literal>&lt;value expression primary&gt; ::= &lt;parenthesized
      value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized value expression&gt; ::= &lt;left
      paren&gt; &lt;value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;nonparenthesized value expression primary&gt; ::=
      &lt;unsigned value specification&gt; | &lt;column reference&gt; |
      &lt;set function specification&gt; | &lt;scalar subquery&gt; | &lt;case
      expression&gt; | &lt;cast specification&gt; | &lt;next value
      expression&gt; | &lt;routine invocation&gt;</literal></simpara>

      <simpara>Specify a value that is syntactically self-delimited. This
      concept</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>value specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">value specification</emphasis></simpara>

      <simpara><emphasis>value specification</emphasis></simpara>

      <simpara><literal>&lt;value specification&gt; ::= &lt;literal&gt; |
      &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;unsigned value specification&gt; ::= &lt;unsigned
      literal&gt; | &lt;general value specification&gt;</literal></simpara>

      <simpara><literal>&lt;target specification&gt; ::= &lt;host parameter
      specification&gt; | &lt;SQL parameter reference&gt; | &lt;column
      reference&gt; | &lt;dynamic parameter
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;simple target specification&gt; ::= &lt;host
      parameter specification&gt; | &lt;SQL parameter reference&gt; |
      &lt;column reference&gt; | &lt;embedded variable
      name&gt;</literal></simpara>

      <simpara><literal>&lt;host parameter specification&gt; ::= &lt;host
      parameter name&gt; [ &lt;indicator parameter&gt; ]</literal></simpara>

      <simpara><literal>&lt;dynamic parameter specification&gt; ::=
      &lt;question mark&gt;</literal></simpara>

      <simpara>Specify one or more values, host parameters, SQL parameters,
      dynamic parameters, or host variables.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>row value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">row value expression</emphasis></simpara>

      <simpara><emphasis>row value expression</emphasis></simpara>

      <simpara><literal>&lt;row value expression&gt; ::= &lt;row value special
      case&gt; | &lt;explicit row value constructor&gt; </literal></simpara>

      <simpara><literal>&lt;row value predicand&gt; ::= &lt;row value special
      case&gt; | &lt;row value constructor predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value special case&gt; ::=
      &lt;nonparenthesized value expression primary&gt;</literal></simpara>

      <simpara><literal>&lt;explicit row value constructor&gt; ::= &lt;left
      paren&gt; &lt;row value constructor element&gt; &lt;comma&gt; &lt;row
      value constructor element list&gt; &lt;right paren&gt; | ROW &lt;left
      paren&gt; &lt;row value constructor element list&gt; &lt;right paren&gt;
      | &lt;row subquery&gt;</literal></simpara>

      <simpara>**</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>set function specification</primary>
      </indexterm>

      <simpara><emphasis role="bold">set function
      specification</emphasis></simpara>

      <simpara><emphasis>set function specification</emphasis></simpara>

      <simpara><literal>&lt;set function specification&gt; ::= &lt;aggregate
      function&gt; | &lt;grouping operation&gt;</literal></simpara>

      <simpara><literal>&lt;grouping operation&gt; ::= GROUPING &lt;left
      paren&gt; &lt;column reference&gt; [ { &lt;comma&gt; &lt;column
      reference&gt; }... ] &lt;right paren&gt;</literal></simpara>

      <simpara>Specify a value derived by the application of a function to an
      argument.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>case expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">case expression</emphasis></simpara>

      <simpara><emphasis>case expression</emphasis></simpara>

      <simpara><literal>&lt;case expression&gt; ::= &lt;case abbreviation&gt;
      | &lt;case specification&gt;</literal></simpara>

      <simpara><literal>&lt;case abbreviation&gt; ::= NULLIF &lt;left
      paren&gt; &lt;value expression&gt; &lt;comma&gt; &lt;value
      expression&gt; &lt;right paren&gt; | COALESCE &lt;left paren&gt;
      &lt;value expression&gt; { &lt;comma&gt; &lt;value expression&gt; }...
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;case specification&gt; ::= &lt;simple case&gt; |
      &lt;searched case&gt;</literal></simpara>

      <simpara><literal>&lt;simple case&gt; ::= CASE &lt;case operand&gt;
      &lt;simple when clause&gt;... [ &lt;else clause&gt; ]
      END</literal></simpara>

      <simpara><literal>&lt;searched case&gt; ::= CASE &lt;searched when
      clause&gt;... [ &lt;else clause&gt; ] END</literal></simpara>

      <simpara><literal>&lt;simple when clause&gt; ::= WHEN &lt;when operand
      list&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;searched when clause&gt; ::= WHEN &lt;search
      condition&gt; THEN &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;else clause&gt; ::= ELSE
      &lt;result&gt;</literal></simpara>

      <simpara><literal>&lt;case operand&gt; ::= &lt;row value predicand&gt; |
      &lt;overlaps predicate part 1&gt;</literal></simpara>

      <simpara><literal>&lt;when operand list&gt; ::= &lt;when operand&gt; [ {
      &lt;comma&gt; &lt;when operand&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;when operand&gt; ::= &lt;row value predicand&gt; |
      &lt;comparison predicate part 2&gt; | &lt;between predicate part 2&gt; |
      &lt;in predicate part 2&gt; | &lt;character like predicate part 2&gt; |
      &lt;octet like predicate part 2&gt; | &lt;similar predicate part 2&gt; |
      &lt;regex like predicate part 2&gt; | &lt;null predicate part 2&gt; |
      &lt;quantified comparison predicate part 2&gt; | &lt;match predicate
      part 2&gt; | &lt;overlaps predicate part 2&gt; | &lt;distinct predicate
      part 2&gt;</literal></simpara>

      <simpara><literal>&lt;result&gt; ::= &lt;result expression&gt; |
      NULL</literal></simpara>

      <simpara><literal>&lt;result expression&gt; ::= &lt;value
      expression&gt;</literal></simpara>

      <simpara>Specify a conditional value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CAST</primary>
      </indexterm>

      <simpara><emphasis role="bold">CAST</emphasis></simpara>

      <simpara><emphasis>cast specification</emphasis></simpara>

      <simpara><literal>&lt;cast specification&gt; ::= CAST &lt;left paren&gt;
      &lt;cast operand&gt; AS &lt;cast target&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;cast operand&gt; ::= &lt;value expression&gt; |
      &lt;implicitly typed value specification&gt;</literal></simpara>

      <simpara><literal>&lt;cast target&gt; ::= &lt;domain name&gt; | &lt;data
      type&gt;</literal></simpara>

      <simpara>Specify a data conversion.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>NEXT VALUE FOR</primary>
      </indexterm>

      <simpara><emphasis role="bold">NEXT VALUE FOR</emphasis></simpara>

      <simpara><emphasis>next value expression</emphasis></simpara>

      <simpara><literal>&lt;next value expression&gt; ::= NEXT VALUE FOR
      &lt;sequence generator name&gt;</literal></simpara>

      <simpara>Return the next value of a sequence generator. This expression
      can be used as a select list element in queries, or in assignments to
      table columns in data change statements. If the expression is used more
      than once in a single row that is being evaluated, the same value is
      returned for each invocation. After evaluation of the particular row is
      complete, the sequence generator will return a different value from the
      old value. The new value is generated by the sequence generator by
      adding the increment to the last value it generated</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">value expression</emphasis></simpara>

      <simpara><emphasis>value expression</emphasis></simpara>

      <simpara><literal>&lt;value expression&gt; ::= &lt;numeric value
      expression&gt; | &lt;string value expression&gt; | &lt;datetime value
      expression&gt; | &lt;interval value expression&gt; | &lt;boolean value
      expression&gt; | &lt;row value expression&gt;</literal></simpara>

      <simpara>Specify a value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      expression</emphasis></simpara>

      <simpara><emphasis>numeric value expression</emphasis></simpara>

      <simpara><literal>&lt;numeric value expression&gt; ::= &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;plus sign&gt; &lt;term&gt; |
      &lt;numeric value expression&gt; &lt;minus sign&gt;
      &lt;term&gt;</literal></simpara>

      <simpara><literal>&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;factor&gt; | &lt;term&gt; &lt;solidus&gt;
      &lt;factor&gt;</literal></simpara>

      <simpara><literal>&lt;factor&gt; ::= [ &lt;sign&gt; ] &lt;numeric
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;numeric primary&gt; ::= &lt;value expression
      primary&gt; | &lt;numeric value function&gt;</literal></simpara>

      <simpara>Specify a numeric value. The BNF indicates that
      &lt;asterisk&gt; and &lt;solidus&gt; (the operators for multiplication
      and division) have precedence over &lt;minus sign&gt; and &lt;plus
      sign&gt;.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>numeric value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">numeric value
      function</emphasis></simpara>

      <simpara><emphasis>numeric value function</emphasis></simpara>

      <simpara><literal>&lt;numeric value function&gt; ::= &lt;position
      expression&gt; | &lt;extract expression&gt; | &lt;length expression&gt;
      ...</literal></simpara>

      <simpara>Specify a function yielding a value of type numeric. The
      supported numeric value functions are listed and described in Built-In
      Functions chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>string value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">string value
      expression</emphasis></simpara>

      <simpara><emphasis>string value expression</emphasis></simpara>

      <simpara><literal>&lt;string value expression&gt; ::= &lt;string
      concatenation&gt; | &lt;string factor&gt;</literal></simpara>

      <simpara><literal>&lt;string factor&gt; ::= &lt;value expression
      primary&gt; | &lt;string value function&gt;</literal></simpara>

      <simpara><literal>&lt;string concatenation&gt; ::= &lt;string value
      expression&gt; &lt;concatenation operator&gt; &lt;string
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;concatenation operator&gt; ::=
      ||</literal></simpara>

      <simpara>Specify a character string value, a binary string value, or a
      bit string value. The BNF indicates that a string value expression can
      be formed by concatenation of two or more &lt;value expression
      primary&gt;. The types of the &lt;value expression primary&gt; elements
      must be compatible, that is, all must be string, or binary or bit string
      values.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>character value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">character value
      function</emphasis></simpara>

      <simpara><emphasis>string value function</emphasis></simpara>

      <simpara><literal>&lt;string value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function yielding a value of type character string or
      binary string. The supported character value functions are listed and
      described in Built-In Functions chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>datetime value expression</primary>
      </indexterm>

      <simpara><emphasis role="bold">datetime value
      expression</emphasis></simpara>

      <simpara><emphasis>datetime value expression</emphasis></simpara>

      <simpara><literal>&lt;datetime value expression&gt; ::= &lt;datetime
      term&gt; | &lt;interval value expression&gt; &lt;plus sign&gt;
      &lt;datetime term&gt; | &lt;datetime value expression&gt; &lt;plus
      sign&gt; &lt;interval term&gt; | &lt;datetime value expression&gt;
      &lt;minus sign&gt; &lt;interval term&gt;</literal></simpara>

      <simpara><literal>&lt;datetime term&gt; ::= &lt;datetime
      factor&gt;</literal></simpara>

      <simpara><literal>&lt;datetime factor&gt; ::= &lt;datetime primary&gt; [
      &lt;time zone&gt; ]</literal></simpara>

      <simpara><literal>&lt;datetime primary&gt; ::= &lt;value expression
      primary&gt; | &lt;datetime value function&gt;</literal></simpara>

      <simpara><literal>&lt;time zone&gt; ::= AT &lt;time zone
      specifier&gt;</literal></simpara>

      <simpara><literal>&lt;time zone specifier&gt; ::= LOCAL | TIME ZONE
      &lt;interval primary&gt;</literal></simpara>

      <simpara>Specify a datetime value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>current date value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">current date value
      function</emphasis></simpara>

      <simpara><emphasis>datetime value function</emphasis></simpara>

      <simpara><literal>&lt;datetime value function&gt; ::=
      ...</literal></simpara>

      <simpara>Specify a function that returns a datetime value. The supported
      datetime value functions are listed and described in Built-In Functions
      chapter.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval term</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval term</emphasis></simpara>

      <simpara><emphasis>interval value expression</emphasis></simpara>

      <simpara><literal>&lt;interval value expression&gt; ::= &lt;interval
      term&gt; | &lt;interval value expression 1&gt; &lt;plus sign&gt;
      &lt;interval term 1&gt; | &lt;interval value expression 1&gt; &lt;minus
      sign&gt; &lt;interval term 1&gt; | &lt;left paren&gt; &lt;datetime value
      expression&gt; &lt;minus sign&gt; &lt;datetime term&gt; &lt;right
      paren&gt; &lt;interval qualifier&gt;</literal></simpara>

      <simpara><literal>&lt;interval term&gt; ::= &lt;interval factor&gt; |
      &lt;interval term 2&gt; &lt;asterisk&gt; &lt;factor&gt; | &lt;interval
      term 2&gt; &lt;solidus&gt; &lt;factor&gt; | &lt;term&gt;
      &lt;asterisk&gt; &lt;interval factor&gt;</literal></simpara>

      <simpara><literal>&lt;interval factor&gt; ::= [ &lt;sign&gt; ]
      &lt;interval primary&gt;</literal></simpara>

      <simpara><literal>&lt;interval primary&gt; ::= &lt;value expression
      primary&gt; [ &lt;interval qualifier&gt; ] | &lt;interval value
      function&gt;</literal></simpara>

      <simpara><literal>&lt;interval value expression 1&gt; ::= &lt;interval
      value expression&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 1&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara><literal>&lt;interval term 2&gt; ::= &lt;interval
      term&gt;</literal></simpara>

      <simpara>Specify an interval value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval absolute value function</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval absolute value
      function</emphasis></simpara>

      <simpara><emphasis>interval value function</emphasis></simpara>

      <simpara><literal>&lt;interval value function&gt; ::= &lt;interval
      absolute value function&gt;</literal></simpara>

      <simpara><literal>&lt;interval absolute value function&gt; ::= ABS
      &lt;left paren&gt; &lt;interval value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a function that returns an interval value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>boolean term</primary>
      </indexterm>

      <simpara><emphasis role="bold">boolean term</emphasis></simpara>

      <simpara><emphasis>boolean value expression</emphasis></simpara>

      <simpara><literal>&lt;boolean value expression&gt; ::= &lt;boolean
      term&gt; | &lt;boolean value expression&gt; OR &lt;boolean
      term&gt;</literal></simpara>

      <simpara><literal>&lt;boolean term&gt; ::= &lt;boolean factor&gt; |
      &lt;boolean term&gt; AND &lt;boolean factor&gt;</literal></simpara>

      <simpara><literal>&lt;boolean factor&gt; ::= [ NOT ] &lt;boolean
      test&gt;</literal></simpara>

      <simpara><literal>&lt;boolean test&gt; ::= &lt;boolean primary&gt; [ IS
      [ NOT ] &lt;truth value&gt; ]</literal></simpara>

      <simpara><literal>&lt;truth value&gt; ::= TRUE | FALSE |
      UNKNOWN</literal></simpara>

      <simpara><literal>&lt;boolean primary&gt; ::= &lt;predicate&gt; |
      &lt;boolean predicand&gt;</literal></simpara>

      <simpara><literal>&lt;boolean predicand&gt; ::= &lt;parenthesized
      boolean value expression&gt; | &lt;nonparenthesized value expression
      primary&gt;</literal></simpara>

      <simpara><literal>&lt;parenthesized boolean value expression&gt; ::=
      &lt;left paren&gt; &lt;boolean value expression&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>Specify a boolean value.</simpara>
    </section>

    <section>
      <title>Predicates</title>

      <simpara>Predicates are conditions with two sides and evaluate to a
      boolean value. The <literal>&lt;row value predicand&gt;</literal> is the
      common element of all predicates. This element is a generalisation of
      both <literal>&lt;value expression&gt;</literal>, which is a scalar, and
      of <literal>&lt;explicit row value constructor&gt;</literal>, which is a
      row. The two sides of a predicate can be split in CASE statements where
      the <literal>&lt;row value predicand&gt;</literal> is part of multiple
      predicates.</simpara>

      <simpara>The number of fields in all <literal>&lt;row value
      predicand&gt;</literal> used in predicates must be the same and the
      types of the fields in the same position must be compatible for
      comparison. If either of these conditions does not hold, an exception
      is raised. The number of fields in a row is called the
      <glossterm>degree</glossterm>.</simpara>

      <simpara>If a <literal>&lt;row value predicand&gt;</literal> in a
      predicate evaluates to NULL, the result of the predicate is UNKNOWN. If
      the <literal>&lt;row value predicand&gt;</literal> has more than one
      element, and one or more of the fields evaluate to NULL, the result
      depends on the particular predicate.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>comparison predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">comparison predicand</emphasis></simpara>

      <simpara><emphasis>comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;comparison predicate&gt; ::= &lt;row value
      predicand&gt; &lt;comparison predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;comparison predicate part 2&gt; ::= &lt;comp
      op&gt; &lt;row value predicand&gt;</literal></simpara>

      <simpara><literal>&lt;comp op&gt; ::= &lt;equals operator&gt; | &lt;not
      equals operator&gt; | &lt;less than operator&gt; | &lt;greater than
      operator&gt; | &lt;less than or equals operator&gt; | &lt;greater than
      or equals operator&gt;</literal></simpara>

      <simpara>Specify a comparison of two row values. If either
      <literal>&lt;row value predicand&gt;</literal> evaluates to NULL, the
      result of <literal>&lt;comparison predicate&gt;</literal> is UNKNOWN.
      Otherwise, the result is TRUE, FALSE or UNKNOWN.</simpara>

      <simpara>If the <glossterm>degree</glossterm> of <literal>&lt;row value
      predicand&gt;</literal> is larger than one, comparison is performed
      between each field and the corresponding field in the other
      <literal>&lt;row value predicand&gt;</literal> from left to right, one
      by one.</simpara>

      <simpara>When comparing two elements, if either field is NULL then the
      result is UNKNOWN.</simpara>

      <simpara>For <literal>&lt;equals operator&gt;</literal>, if the result
      of comparison is TRUE for all field, the result of the predicate is
      TRUE. If the result of comparison is FALSE for one field, the result of
      predicate is FALSE. Otherwise the result is UNKNOWN.</simpara>

      <simpara>The <literal>&lt;not equals operator&gt;</literal> is
      translated to <literal>NOT (&lt;row value predicand&gt; = &lt;row value
      predicand&gt;)</literal>.</simpara>

      <simpara>The <literal>&lt;less than or equals operator&gt;</literal> is
      translated to <literal>(&lt;row value predicand&gt; = &lt;row value
      predicand&gt;) OR (&lt;row value predicand&gt; &lt; &lt;row value
      predicand&gt;)</literal>. The <literal>&lt;greater than or equals
      operator&gt;</literal> is translated similarly.</simpara>

      <simpara>For the <literal>&lt;less than operator&gt;</literal> and
      <literal>&lt;greater than operator&gt;</literal>, if two fields at a
      given position are equal, then comparison continues to the next field.
      Otherwise, the result of the last performed comparison is returned as
      the result of the predicate. This means that if the first field is NULL,
      the result is always UNKNOWN.</simpara>

      <simpara>The logic that governs NULL values and UNKNOWN result is as
      follows: Suppose the NULL values were substituted by arbitrary real
      values. If substitution cannot change the result of the predicate, then
      the result is TRUE or FALSE, based on the existing non-NULL values,
      otherwise the result of the predicate is UNKNOWN.</simpara>

      <simpara>The examples of comparison given below use literals, but the
      literals actually represent the evaluation of some expression.</simpara>

      <programlisting>((1, 2, 3, 4) = (1, 2, 3, 4)) IS TRUE
((1, 2, 3, 4) = (1, 2, 3, 5)) IS FALSE
((1, 2, 3, 4) &lt; (1, 2, 3, 4)) IS FALSE
((1, 2, 3, 4) &lt; (1, 2, 3, 5)) IS TRUE
((NULL, 1, NULL) == (NULL, 1, NULL)) IS UNKNOWN  
((NULL, 1, NULL) = (NULL, 2, NULL)) IS FALSE  
((NULL, 1, NULL) &lt;&gt; (NULL, 2, NULL)) IS TRUE  
((NULL, 1, 2) &lt;all operators&gt; (NULL, 1, 2)) IS UNKNOWN
((1, NULL, ...) &lt; (1, 2, ...)) IS UNKNOWN  
((1, NULL, ...) &lt; (2, NULL, ...)) IS TRUE
((2, NULL, ...) &lt; (1, NULL, ...)) IS FALSE
</programlisting>

      <indexterm significance="preferred" type="sql">
        <primary>between predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">between predicate</emphasis></simpara>

      <simpara><emphasis>between predicate</emphasis></simpara>

      <simpara><literal>&lt;between predicate&gt; ::= &lt;row value
      predicand&gt; &lt;between predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;between predicate part 2&gt; ::= [ NOT ] BETWEEN [
      ASYMMETRIC | SYMMETRIC ] &lt;row value predicand&gt; AND &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a range comparison. The default is ASYMMETRIC. The
      expression <literal>X BETWEEN Y AND Z</literal> is equivalent to
      <literal>(X &gt;= Y AND X &lt;= Z)</literal>. Therefore if Y &gt; Z, the
      BETWEEN expression is never true. The expression <literal>X BETWEEN
      SYMMETRIC Y AND Z</literal> is equivalent to <literal>(X &gt;= Y AND X
      &lt;= Z) OR (X &gt;= Z AND X &lt;= Y)</literal>. The expression
      <literal>Z NOT BETWEEN ...</literal> is equivalent to <literal>NOT (Z
      BETWEEN ...)</literal>. If any of the three <literal>&lt;row value
      predicand&gt;</literal> evaluates to NULL, the result is
      UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>in predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">in predicate</emphasis></simpara>

      <simpara><emphasis>in predicate</emphasis></simpara>

      <simpara><literal>&lt;in predicate&gt; ::= &lt;row value predicand&gt;
      &lt;in predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;in predicate part 2&gt; ::= [ NOT ] IN &lt;in
      predicate value&gt;</literal></simpara>

      <simpara><literal>&lt;in predicate value&gt; ::= &lt;table subquery&gt;
      | &lt;left paren&gt; &lt;in value list&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;in value list&gt; ::= &lt;row value expression&gt;
      [ { &lt;comma&gt; &lt;row value expression&gt; }...
      ]</literal></simpara>

      <simpara>Specify a quantified comparison. The expression <literal>X NOT
      IN Y is</literal> equivalent to <literal>NOT (X IN Y)</literal>. The
      <literal>( &lt;in value list&gt; )</literal> is converted into a table
      with one or more rows. The expression <literal>X IN Y</literal> is
      equivalent to <literal>X = ANY Y</literal>, which is a
      <literal>&lt;quantified comparison predicate&gt;</literal>. </simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, the result is FALSE. Otherwise the <literal>&lt;row value
      predicand&gt;</literal> is compared one by one with each row of the
      <literal>&lt;table subquery&gt;</literal>. </simpara>

      <simpara>If the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>like predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">like predicate</emphasis></simpara>

      <simpara><emphasis>like predicate</emphasis></simpara>

      <simpara><literal>&lt;like predicate&gt; ::= &lt;character like
      predicate&gt; | &lt;octet like predicate&gt;</literal></simpara>

      <simpara><literal>&lt;character like predicate&gt; ::= &lt;row value
      predicand&gt; &lt;character like predicate part
      2&gt;</literal></simpara>

      <simpara><literal>&lt;character like predicate part 2&gt; ::= [ NOT ]
      LIKE &lt;character pattern&gt; [ ESCAPE &lt;escape character&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;character pattern&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape character&gt; ::= &lt;character value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;octet like predicate&gt; ::= &lt;row value
      predicand&gt; &lt;octet like predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;octet like predicate part 2&gt; ::= [ NOT ] LIKE
      &lt;octet pattern&gt; [ ESCAPE &lt;escape octet&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;octet pattern&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;escape octet&gt; ::= &lt;binary value
      expression&gt;</literal></simpara>

      <simpara>Specify a pattern-match comparison.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>null predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">null predicate</emphasis></simpara>

      <simpara><emphasis>null predicate</emphasis></simpara>

      <simpara><literal>&lt;null predicate&gt; ::= &lt;row value predicand&gt;
      &lt;null predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;null predicate part 2&gt; ::= IS [ NOT ]
      NULL</literal></simpara>

      <simpara>Specify a test for a null value. The expression <literal>X IS
      NOT NULL</literal> is NOT equivalent to <literal>NOT (X IS
      NULL)</literal>if the degree of the <literal>&lt;row value
      predicand&gt;</literal> is larger than 1. The rules are: If all fields
      are null, <literal>X IS NULL</literal> is TRUE and <literal>X IS NOT
      NULL</literal> is FALSE. If only some fields are null, both <literal>X
      IS NULL</literal> and <literal>X IS NOT NULL</literal> are FALSE. If all
      fields are not null, <literal>X IS NULL</literal> is FALSE and
      <literal>X IS NOT NULL</literal> is TRUE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>quantified comparison predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">quantified comparison
      predicate</emphasis></simpara>

      <simpara><emphasis>quantified comparison predicate</emphasis></simpara>

      <simpara><literal>&lt;quantified comparison predicate&gt; ::= &lt;row
      value predicand&gt; &lt;quantified comparison predicate part
      2&gt;</literal></simpara>

      <simpara><literal>&lt;quantified comparison predicate part 2&gt; ::=
      &lt;comp op&gt; &lt;quantifier&gt; &lt;table
      subquery&gt;</literal></simpara>

      <simpara><literal>&lt;quantifier&gt; ::= &lt;all&gt; |
      &lt;some&gt;</literal></simpara>

      <simpara><literal>&lt;all&gt; ::= ALL</literal></simpara>

      <simpara><literal>&lt;some&gt; ::= SOME | ANY</literal></simpara>

      <simpara>Specify a quantified comparison. For a quantified comparison,
      the <literal>&lt;row value predicand&gt;</literal> is compared one by
      one with each row of the <literal>&lt;table sub query&gt;</literal>.
      </simpara>

      <simpara>If the <literal>&lt;table subquery&gt;</literal> returns no
      rows, then if <literal>ALL</literal> is specified the result is TRUE,
      but if <literal>SOME</literal> or <literal>ANY</literal> is specified
      the result is FALSE.</simpara>

      <simpara>If <literal>ALL</literal> is specified, if the comparison is
      TRUE for all rows, the result of the predicate is TRUE. If the
      comparison is FALSE for at least one row, the result is FALSE. Otherwise
      the result is UNKNOWN.</simpara>

      <simpara>If <literal>SOME</literal> or <literal>ANY</literal> is
      specified, if the comparison is TRUE for at least one row, the result is
      TRUE. If the comparison is FALSE for all rows, the result is FALSE.
      Otherwise the result is UNKNOWN. Note that the IN predicate is
      equivalent to the SOME or ANY predicate using the <literal>&lt;equals
      operator&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>EXISTS</primary>
      </indexterm>

      <simpara><emphasis role="bold">EXISTS</emphasis></simpara>

      <simpara><emphasis>exists predicate</emphasis></simpara>

      <simpara><literal>&lt;exists predicate&gt; ::= EXISTS &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for a non-empty set. If the evaluation of
      <literal>&lt;table subquery&gt;</literal> results in one or more rows,
      then the expression is TRUE, otherwise FALSE.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>UNIQUE</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

      <simpara><emphasis>unique predicate</emphasis></simpara>

      <simpara><literal>&lt;unique predicate&gt; ::= UNIQUE &lt;table
      subquery&gt;</literal></simpara>

      <simpara>Specify a test for the absence of duplicate rows. The result of
      the test is either TRUE or FALSE (never UNKNOWN). The rows of the
      <literal>&lt;table subquery&gt;</literal> that contain one or more NULL
      values are not considered for this test. If the rest of the rows are
      distinct from each other, the result of the test is TRUE, otherwise it
      is FALSE. The distinctness of rows X and Y is tested with the predicate
      <literal>X IS DISTINCT FROM Y</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>MATCH predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">MATCH</emphasis></simpara>

      <simpara><emphasis>match predicate</emphasis></simpara>

      <simpara><literal>&lt;match predicate&gt; ::= &lt;row value
      predicand&gt; &lt;match predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;match predicate part 2&gt; ::= MATCH [ UNIQUE ] [
      SIMPLE | PARTIAL | FULL ] &lt;table subquery&gt;</literal></simpara>

      <simpara>Specify a test for matching rows. The default is MATCH SIMPLE
      without UNIQUE. The result of the test is either TRUE or FALSE (never
      UNKNOWN).</simpara>

      <simpara>The interpretation of NULL values is different from other
      predicates and quite counter-intuitive. If the <literal>&lt;row value
      predicand&gt;</literal> is NULL, or all of its fields are NULL, the
      result is TRUE.</simpara>

      <simpara>Otherwise, the <literal>&lt;row value predicand&gt;</literal>
      is compared with each row of the <literal>&lt;table
      subquery&gt;</literal>.</simpara>

      <simpara>If SIMPLE is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is TRUE. Otherwise if
      <literal>&lt;row value predicate&gt; </literal>is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches. Otherwise the result is FALSE.</simpara>

      <simpara>If PARTIAL is specified, if the non-null values
      <literal>&lt;row value predicate&gt; </literal>are equal to those in one
      or more rows of <literal>&lt;table subquery&gt;</literal> the result is
      TRUE if UNIQUE is not specified, or if UNIQUE is specified and only one
      row matches. Otherwise the result is FALSE.</simpara>

      <simpara>If FULL is specified, if some field of <literal>&lt;row value
      predicate&gt;</literal> is NULL, the result is FALSE. Otherwise if
      <literal>&lt;row value predicate&gt;</literal> is equal to one or more
      rows of <literal>&lt;table subquery&gt;</literal> the result is TRUE if
      UNIQUE is not specified, or if UNIQUE is specified and only one row
      matches.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>OVERLAPS predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">OVERLAPS predicate</emphasis></simpara>

      <simpara><emphasis>overlaps predicate</emphasis></simpara>

      <simpara><literal>&lt;overlaps predicate&gt; ::= &lt;overlaps predicate
      part 1&gt; &lt;overlaps predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;overlaps predicate part 1&gt; ::= &lt;row value
      predicand 1&gt;</literal></simpara>

      <simpara><literal>&lt;overlaps predicate part 2&gt; ::= OVERLAPS &lt;row
      value predicand 2&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 1&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 2&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test for an overlap between two datetime periods.
      Each <literal>&lt;row value predicand&gt;</literal> must have two fields
      and the fields together represent a datetime period. So the predicates
      is always in the form <literal>(X1, X2) OVERLAPS (Y1, Y2)</literal>. The
      first field is always a datetime value, while the second field is either
      a datetime value or an interval value. If the second value is an
      interval value, it is replaced with the sum of the datetime value and
      itself, for example <literal>(X1, X1 + X2) OVERLAPS (Y1, Y1 + Y
      2)</literal>. If any of the values is NULL, the result is UNKNOWN. The
      expression is true if there is there is any overlap between the two
      datetime periods.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DISTINCT predicate</primary>
      </indexterm>

      <simpara><emphasis role="bold">DISTINCT predicate</emphasis></simpara>

      <simpara><emphasis>distinct predicate</emphasis></simpara>

      <simpara><literal>&lt;distinct predicate&gt; ::= &lt;row value predicand
      3&gt; &lt;distinct predicate part 2&gt;</literal></simpara>

      <simpara><literal>&lt;distinct predicate part 2&gt; ::= IS [ NOT ]
      DISTINCT FROM &lt;row value predicand 4&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 3&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara><literal>&lt;row value predicand 4&gt; ::= &lt;row value
      predicand&gt;</literal></simpara>

      <simpara>Specify a test of whether two row values are distinct. The
      result of the test is either TRUE or FALSE (never UNKNOWN). The
      <glossterm>degree</glossterm> the two <literal>&lt;row value
      predicand&gt;</literal> must be the same. Each field of the first
      <literal>&lt;row value predicand&gt;</literal> is compared to the field
      of the second <literal>&lt;row value predicand&gt;</literal> at the same
      position. If one field is NULL and the other is not NULL, or if the
      elements are NOT equal, then the result of the expression is TRUE. If no
      comparison result is TRUE, then the result of the predicate is FALSE.
      The expression <literal>X IS NOT DISTINCT FROM Y</literal> is equivalent
      to <literal>NOT (X IS DISTINCT FORM Y)</literal>.</simpara>
    </section>

    <section>
      <title></title>

      <indexterm significance="preferred" type="sql">
        <primary>search condition</primary>
      </indexterm>

      <simpara><emphasis role="bold">search condition</emphasis></simpara>

      <simpara><emphasis>search condition</emphasis></simpara>

      <simpara><literal>&lt;search condition&gt; ::= &lt;boolean value
      expression&gt;</literal></simpara>

      <simpara>Specify a condition that is TRUE, FALSE, or UNKNOWN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>interval qualifier</primary>
      </indexterm>

      <simpara><emphasis role="bold">interval qualifier</emphasis></simpara>

      <simpara><emphasis>interval qualifier</emphasis></simpara>

      <simpara><literal>&lt;interval qualifier&gt; ::= &lt;start field&gt; TO
      &lt;end field&gt; | &lt;single datetime field&gt;</literal></simpara>

      <simpara><literal>&lt;start field&gt; ::= &lt;non-second primary
      datetime field&gt; [ &lt;left paren&gt; &lt;interval leading field
      precision&gt; &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;end field&gt; ::= &lt;non-second primary datetime
      field&gt; | SECOND [ &lt;left paren&gt; &lt;interval fractional seconds
      precision&gt; &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;single datetime field&gt; ::= &lt;non-second
      primary datetime field&gt; [ &lt;left paren&gt; &lt;interval leading
      field precision&gt; &lt;right paren&gt; ] | SECOND [ &lt;left paren&gt;
      &lt;interval leading field precision&gt; [ &lt;comma&gt; &lt;interval
      fractional seconds precision&gt; ] &lt;right paren&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;primary datetime field&gt; ::= &lt;non-second
      primary datetime field&gt; | SECOND</literal></simpara>

      <simpara><literal>&lt;non-second primary datetime field&gt; ::= YEAR |
      MONTH | DAY | HOUR | MINUTE</literal></simpara>

      <simpara><literal>&lt;interval fractional seconds precision&gt; ::=
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara><literal>&lt;interval leading field precision&gt; ::=
      &lt;unsigned integer&gt;</literal></simpara>

      <simpara>Specify an interval data type.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>PATH</primary>
      </indexterm>

      <simpara><emphasis role="bold">PATH</emphasis></simpara>

      <simpara><emphasis>path specification</emphasis></simpara>

      <simpara><literal>&lt;path specification&gt; ::= PATH &lt;schema name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;schema name list&gt; ::= &lt;schema name&gt; [ {
      &lt;comma&gt; &lt;schema name&gt; }... ]</literal></simpara>

      <simpara>Specify an order for searching for an SQL-invoked
      routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>routine invocation</primary>
      </indexterm>

      <simpara><emphasis role="bold">routine invocation</emphasis></simpara>

      <simpara><emphasis>routine invocation</emphasis></simpara>

      <simpara><literal>&lt;routine invocation&gt; ::= &lt;routine name&gt;
      &lt;SQL argument list&gt;</literal></simpara>

      <simpara><literal>&lt;routine name&gt; ::= [ &lt;schema name&gt;
      &lt;period&gt; ] &lt;qualified identifier&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument list&gt; ::= &lt;left paren&gt; [
      &lt;SQL argument&gt; [ { &lt;comma&gt; &lt;SQL argument&gt; }... ] ]
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;SQL argument&gt; ::= &lt;value expression&gt; |
      &lt;target specification&gt;</literal></simpara>

      <simpara>Invoke an SQL-invoked routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>COLLATE</primary>
      </indexterm>

      <simpara><emphasis role="bold">COLLATE</emphasis></simpara>

      <simpara><emphasis>collate clause</emphasis></simpara>

      <simpara><literal>&lt;collate clause&gt; ::= COLLATE &lt;collation
      name&gt;</literal></simpara>

      <simpara>Specify a default collation.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>constraint name definition</emphasis></simpara>

      <simpara><literal>&lt;constraint name definition&gt; ::= CONSTRAINT
      &lt;constraint name&gt;</literal></simpara>

      <simpara><literal>&lt;constraint characteristics&gt; ::= &lt;constraint
      check time&gt; [ [ NOT ] DEFERRABLE ] | [ NOT ] DEFERRABLE [
      &lt;constraint check time&gt; ]</literal></simpara>

      <simpara><literal>&lt;constraint check time&gt; ::= INITIALLY DEFERRED |
      INITIALLY IMMEDIATE</literal></simpara>

      <simpara>Specify the name of a constraint and its
      characteristics.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>aggregate function</primary>
      </indexterm>

      <simpara><emphasis role="bold">aggregate function</emphasis></simpara>

      <simpara><emphasis>aggregate function</emphasis></simpara>

      <simpara><literal>&lt;aggregate function&gt; ::= COUNT &lt;left
      paren&gt; &lt;asterisk&gt; &lt;right paren&gt; [ &lt;filter clause&gt; ]
      | &lt;general set function&gt; [ &lt;filter clause&gt; ] | &lt;binary
      set function&gt; [ &lt;filter clause&gt; ] | &lt;ordered set
      function&gt; [ &lt;filter clause&gt; ] | &lt;array aggregate
      function&gt; [ &lt;filter clause&gt; ]</literal></simpara>

      <simpara><literal>&lt;general set function&gt; ::= &lt;set function
      type&gt; &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value
      expression&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;set function type&gt; ::= &lt;computational
      operation&gt;</literal></simpara>

      <simpara><literal>&lt;computational operation&gt; ::= AVG | MAX | MIN |
      SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP |
      VAR_POP | COLLECT | FUSION | INTERSECTION</literal></simpara>

      <simpara><literal>&lt;set quantifier&gt; ::= DISTINCT |
      ALL</literal></simpara>

      <simpara><literal>&lt;filter clause&gt; ::= FILTER &lt;left paren&gt;
      WHERE &lt;search condition&gt; &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;binary set function&gt; ::= &lt;binary set
      function type&gt; &lt;left paren&gt; &lt;dependent variable
      expression&gt; &lt;comma&gt; &lt;independent variable expression&gt;
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;binary set function type&gt; ::= COVAR_POP |
      COVAR_SAMP | CORR | REGR_SLOPE | REGR_INTERCEPT | REGR_COUNT | REGR_R2 |
      REGR_AVGX | REGR_AVGY | REGR_SXX | REGR_SYY |
      REGR_SXY</literal></simpara>

      <simpara><literal>&lt;dependent variable expression&gt; ::= &lt;numeric
      value expression&gt;</literal></simpara>

      <simpara><literal>&lt;independent variable expression&gt; ::=
      &lt;numeric value expression&gt;</literal></simpara>

      <simpara><literal>&lt;ordered set function&gt; ::= &lt;hypothetical set
      function&gt; | &lt;inverse distribution function&gt;</literal></simpara>

      <simpara><literal>&lt;hypothetical set function&gt; ::= &lt;rank
      function type&gt; &lt;left paren&gt; &lt;hypothetical set function value
      expression list&gt; &lt;right paren&gt; &lt;within group
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;within group specification&gt; ::= WITHIN GROUP
      &lt;left paren&gt; ORDER BY &lt;sort specification list&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;hypothetical set function value expression
      list&gt; ::= &lt;value expression&gt; [ { &lt;comma&gt; &lt;value
      expression&gt; }... ]</literal></simpara>

      <simpara><literal>&lt;inverse distribution function&gt; ::= &lt;inverse
      distribution function type&gt; &lt;left paren&gt; &lt;inverse
      distribution function argument&gt; &lt;right paren&gt; &lt;within group
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;inverse distribution function argument&gt; ::=
      &lt;numeric value expression&gt;</literal></simpara>

      <simpara><literal>&lt;inverse distribution function type&gt; ::=
      PERCENTILE_CONT | PERCENTILE_DISC</literal></simpara>

      <simpara><literal>&lt;array aggregate function&gt; ::= ARRAY_AGG
      &lt;left paren&gt; &lt;value expression&gt; [ ORDER BY &lt;sort
      specification list&gt; ] &lt;right paren&gt;</literal></simpara>

      <simpara>Specify a value computed from a collection of rows.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>sort specification list</primary>
      </indexterm>

      <simpara><emphasis role="bold">sort specification
      list</emphasis></simpara>

      <simpara><emphasis>sort specification list</emphasis></simpara>

      <simpara><literal>&lt;sort specification list&gt; ::= &lt;sort
      specification&gt; [ { &lt;comma&gt; &lt;sort specification&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;sort specification&gt; ::= &lt;sort key&gt; [
      &lt;ordering specification&gt; ] [ &lt;null ordering&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;sort key&gt; ::= &lt;value
      expression&gt;</literal></simpara>

      <simpara><literal>&lt;ordering specification&gt; ::= ASC |
      DESC</literal></simpara>

      <simpara><literal>&lt;null ordering&gt; ::= NULLS FIRST | NULLS
      LAST</literal></simpara>

      <simpara>Specify a sort order.</simpara>
    </section>
  </section>

  <section>
    <title>Data Access Statements</title>

    <para></para>
  </section>

  <section>
    <title>Data Change Statements</title>

    <indexterm significance="preferred" type="sql">
      <primary>DELETE FROM</primary>
    </indexterm>

    <simpara><emphasis role="bold">DELETE FROM</emphasis></simpara>

    <simpara><emphasis>delete statement: searched</emphasis></simpara>

    <simpara><literal>&lt;delete statement: searched&gt; ::= DELETE FROM
    &lt;target table&gt; [ [ AS ] &lt;correlation name&gt; ] [ WHERE
    &lt;search condition&gt; ]</literal></simpara>

    <simpara>Delete rows of a table. The search condition is a
    <literal>&lt;boolean value expression&gt;</literal> that is evaluated for
    each row of the table. If the condition is true, the row is deleted. If
    the condition is not specified, all the rows of the table are
    deleted.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>TRUNCATE TABLE</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRUNCATE TABLE</emphasis></simpara>

    <simpara><emphasis>truncate table statement</emphasis></simpara>

    <simpara><literal>&lt;truncate table statement&gt; ::= TRUNCATE TABLE
    &lt;target table&gt; [ &lt;identity column restart option&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;identity column restart option&gt; ::= CONTINUE
    IDENTITY | RESTART IDENTITY</literal></simpara>

    <simpara>Delete all rows of a base table without causing any triggered
    action. This statement can only be used on base tables (not views). If the
    table is referenced in a FOREIGN KEY constraint, the statement causes an
    exception. The default for <literal>&lt;identity column restart
    option&gt;</literal> is CONTINUE IDENTITY. This means no change to the
    IDENTITY sequence of the table. If RESTART IDENTITY is specified, then the
    sequence is reset to its start value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>INSERT INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">INSERT INTO</emphasis></simpara>

    <simpara><emphasis>insert statement</emphasis></simpara>

    <simpara><literal>&lt;insert statement&gt; ::= INSERT INTO &lt;insertion
    target&gt; &lt;insert columns and source&gt;</literal></simpara>

    <simpara><literal>&lt;insertion target&gt; ::= &lt;table
    name&gt;</literal></simpara>

    <simpara><literal>&lt;insert columns and source&gt; ::= &lt;from
    subquery&gt; | &lt;from constructor&gt; | &lt;from
    default&gt;</literal></simpara>

    <simpara><literal>&lt;from subquery&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;query expression&gt;</literal></simpara>

    <simpara><literal>&lt;from constructor&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;contextually typed table value constructor&gt;</literal></simpara>

    <simpara><literal>&lt;override clause&gt; ::= OVERRIDING USER VALUE |
    OVERRIDING SYSTEM VALUE</literal></simpara>

    <simpara><literal>&lt;from default&gt; ::= DEFAULT
    VALUES</literal></simpara>

    <simpara><literal>&lt;insert column list&gt; ::= &lt;column name
    list&gt;</literal></simpara>

    <simpara>Create new rows in a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>MERGE INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">MERGE INTO</emphasis></simpara>

    <simpara><emphasis>merge statement</emphasis></simpara>

    <simpara><literal>&lt;merge statement&gt; ::= MERGE INTO &lt;target
    table&gt; [ [ AS ] &lt;merge correlation name&gt; ] USING &lt;table
    reference&gt; ON &lt;search condition&gt; &lt;merge operation
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge correlation name&gt; ::= &lt;correlation
    name&gt;</literal></simpara>

    <simpara><literal>&lt;merge operation specification&gt; ::= &lt;merge when
    clause&gt;...</literal></simpara>

    <simpara><literal>&lt;merge when clause&gt; ::= &lt;merge when matched
    clause&gt; | &lt;merge when not matched clause&gt;</literal></simpara>

    <simpara><literal>&lt;merge when matched clause&gt; ::= WHEN MATCHED [ AND
    &lt;search condition&gt; ] THEN &lt;merge update
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge when not matched clause&gt; ::= WHEN NOT
    MATCHED [ AND &lt;search condition&gt; ] THEN &lt;merge insert
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge update specification&gt; ::= UPDATE SET
    &lt;set clause list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert specification&gt; ::= INSERT [ &lt;left
    paren&gt; &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override
    clause&gt; ] VALUES &lt;merge insert value list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value list&gt; ::= &lt;left paren&gt;
    &lt;merge insert value element&gt; [ { &lt;comma&gt; &lt;merge insert
    value element&gt; }... ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value element&gt; ::= &lt;value
    expression&gt; | &lt;contextually typed value
    specification&gt;</literal></simpara>

    <simpara>Conditionally update rows of a table, or insert new rows into a
    table, or both.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>UPDATE</primary>
    </indexterm>

    <simpara><emphasis role="bold">UPDATE</emphasis></simpara>

    <simpara><emphasis>update statement: searched</emphasis></simpara>

    <simpara><literal>&lt;update statement: searched&gt; ::= UPDATE &lt;target
    table&gt; [ [ AS ] &lt;correlation name&gt; ] SET &lt;set clause list&gt;
    [ WHERE &lt;search condition&gt; ]</literal></simpara>

    <simpara>Update rows of a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>set clause in UPDATE and MERGE statements</primary>
    </indexterm>

    <simpara><emphasis role="bold">set clause list</emphasis></simpara>

    <simpara><emphasis>set clause list</emphasis></simpara>

    <simpara><literal>&lt;set clause list&gt; ::= &lt;set clause&gt; [ {
    &lt;comma&gt; &lt;set clause&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;set clause&gt; ::= &lt;multiple column
    assignment&gt; | &lt;set target&gt; &lt;equals operator&gt; &lt;update
    source&gt;</literal></simpara>

    <simpara><literal>&lt;multiple column assignment&gt; ::= &lt;set target
    list&gt; &lt;equals operator&gt; &lt;assigned row&gt;</literal></simpara>

    <simpara><literal>&lt;set target list&gt; ::= &lt;left paren&gt; &lt;set
    target&gt; [ { &lt;comma&gt; &lt;set target&gt; }... ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;assigned row&gt; ::= &lt;contextually typed row
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;set target&gt; ::= &lt;column
    name&gt;</literal></simpara>

    <simpara><literal>&lt;update source&gt; ::= &lt;value expression&gt; |
    &lt;contextually typed value specification&gt;</literal></simpara>

    <simpara>Specify a list of updates.</simpara>
  </section>
</chapter>
