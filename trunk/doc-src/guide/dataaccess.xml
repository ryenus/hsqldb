<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="dataaccess-title">Data Access and Change</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision: 734 $</releaseinfo>

    <pubdate>$Date: 2009-01-08 19:19:51 +0000 (Thu, 08 Jan 2009) $</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2009 Fred Toussi. Permission is granted to distribute
      this document without any alteration under the terms of the HSQLDB
      license. Additional permission is granted to the HSQL Development Group
      to distribute this document with or without alterations under the terms
      of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section>
    <title>Overview</title>

    <para>All SQL data access and change statements are executed in
    sessions.</para>
  </section>

  <section>
    <title>Syntax Elements</title>

    <para></para>

    <indexterm significance="preferred" type="sql">
      <primary>parenthesized value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">parenthesized value
    expression</emphasis></simpara>

    <simpara><emphasis>value expression primary</emphasis></simpara>

    <simpara><literal>&lt;value expression primary&gt; ::= &lt;parenthesized
    value expression&gt; | &lt;nonparenthesized value expression
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;parenthesized value expression&gt; ::= &lt;left
    paren&gt; &lt;value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;nonparenthesized value expression primary&gt; ::=
    &lt;unsigned value specification&gt; | &lt;column reference&gt; | &lt;set
    function specification&gt; | &lt;window function&gt; | &lt;scalar
    subquery&gt; | &lt;case expression&gt; | &lt;cast specification&gt; |
    &lt;field reference&gt; | &lt;subtype treatment&gt; | &lt;method
    invocation&gt; | &lt;static method invocation&gt; | &lt;new
    specification&gt; | &lt;attribute or method reference&gt; | &lt;reference
    resolution&gt; | &lt;collection value constructor&gt; | &lt;array element
    reference&gt; | &lt;multiset element reference&gt; | &lt;next value
    expression&gt; | &lt;routine invocation&gt;</literal></simpara>

    <simpara><literal>&lt;collection value constructor&gt; ::= &lt;array value
    constructor&gt; | &lt;multiset value constructor&gt;</literal></simpara>

    <simpara>Specify a value that is syntactically self-delimited.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>literal</primary>
    </indexterm>

    <simpara><emphasis role="bold">literal</emphasis></simpara>

    <simpara><emphasis>value specification</emphasis></simpara>

    <simpara><literal>&lt;value specification&gt; ::= &lt;literal&gt; |
    &lt;general value specification&gt;</literal></simpara>

    <simpara><literal>&lt;unsigned value specification&gt; ::= &lt;unsigned
    literal&gt; | &lt;general value specification&gt;</literal></simpara>

    <simpara><literal>&lt;general value specification&gt; ::= &lt;host
    parameter specification&gt; | &lt;SQL parameter reference&gt; |
    &lt;dynamic parameter specification&gt; | &lt;embedded variable
    specification&gt; | &lt;current collation specification&gt; |
    CURRENT_CATALOG | CURRENT_DEFAULT_TRANSFORM_GROUP | CURRENT_PATH |
    CURRENT_ROLE | CURRENT_SCHEMA | CURRENT_TRANSFORM_GROUP_FOR_TYPE
    &lt;path-resolved user-defined type name&gt; | CURRENT_USER | SESSION_USER
    | SYSTEM_USER | USER | VALUE</literal></simpara>

    <simpara><literal>&lt;simple value specification&gt; ::= &lt;literal&gt; |
    &lt;host parameter name&gt; | &lt;SQL parameter reference&gt; |
    &lt;embedded variable name&gt;</literal></simpara>

    <simpara><literal>&lt;target specification&gt; ::= &lt;host parameter
    specification&gt; | &lt;SQL parameter reference&gt; | &lt;column
    reference&gt; | &lt;target array element specification&gt; | &lt;dynamic
    parameter specification&gt; | &lt;embedded variable
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;simple target specification&gt; ::= &lt;host
    parameter specification&gt; | &lt;SQL parameter reference&gt; | &lt;column
    reference&gt; | &lt;embedded variable name&gt;</literal></simpara>

    <simpara><literal>&lt;host parameter specification&gt; ::= &lt;host
    parameter name&gt; [ &lt;indicator parameter&gt; ]</literal></simpara>

    <simpara><literal>&lt;dynamic parameter specification&gt; ::= &lt;question
    mark&gt;</literal></simpara>

    <simpara><literal>&lt;embedded variable specification&gt; ::= &lt;embedded
    variable name&gt; [ &lt;indicator variable&gt; ]</literal></simpara>

    <simpara><literal>&lt;indicator variable&gt; ::= [ INDICATOR ]
    &lt;embedded variable name&gt;</literal></simpara>

    <simpara><literal>&lt;indicator parameter&gt; ::= [ INDICATOR ] &lt;host
    parameter name&gt;</literal></simpara>

    <simpara><literal>&lt;target array element specification&gt; ::=
    &lt;target array reference&gt; &lt;left bracket or trigraph&gt; &lt;simple
    value specification&gt; &lt;right bracket or
    trigraph&gt;</literal></simpara>

    <simpara><literal>&lt;target array reference&gt; ::= &lt;SQL parameter
    reference&gt; | &lt;column reference&gt;</literal></simpara>

    <simpara><literal>&lt;current collation specification&gt; ::= COLLATION
    FOR &lt;left paren&gt; &lt;string value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Specify one or more values, host parameters, SQL parameters,
    dynamic parameters, or host variables.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>implicitly typed value specification</primary>
    </indexterm>

    <simpara><emphasis role="bold">implicitly typed value
    specification</emphasis></simpara>

    <simpara><emphasis>contextually typed value
    specification</emphasis></simpara>

    <simpara><literal>&lt;contextually typed value specification&gt; ::=
    &lt;implicitly typed value specification&gt; | &lt;default
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;implicitly typed value specification&gt; ::=
    &lt;null specification&gt; | &lt;empty
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;null specification&gt; ::= NULL</literal></simpara>

    <simpara><literal>&lt;empty specification&gt; ::= ARRAY &lt;left bracket
    or trigraph&gt; &lt;right bracket or trigraph&gt; | MULTISET &lt;left
    bracket or trigraph&gt; &lt;right bracket or
    trigraph&gt;</literal></simpara>

    <simpara><literal>&lt;default specification&gt; ::=
    DEFAULT</literal></simpara>

    <simpara>Specify a value whose data type is to be inferred from its
    context.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>identifier {</primary>
    </indexterm>

    <simpara><emphasis role="bold">identifier {</emphasis></simpara>

    <simpara><emphasis>identifier chain</emphasis></simpara>

    <simpara><literal>&lt;identifier chain&gt; ::= &lt;identifier&gt; [ {
    &lt;period&gt; &lt;identifier&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;basic identifier chain&gt; ::= &lt;identifier
    chain&gt;</literal></simpara>

    <simpara>Disambiguate a period-separated chain of identifiers.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>basic identifier chain</primary>
    </indexterm>

    <simpara><emphasis role="bold">basic identifier chain</emphasis></simpara>

    <simpara><emphasis>column reference</emphasis></simpara>

    <simpara><literal>&lt;column reference&gt; ::= &lt;basic identifier
    chain&gt; | MODULE &lt;period&gt; &lt;qualified identifier&gt;
    &lt;period&gt; &lt;column name&gt;</literal></simpara>

    <simpara>Reference a column.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>basic identifier chain</primary>
    </indexterm>

    <simpara><emphasis role="bold">basic identifier chain</emphasis></simpara>

    <simpara><emphasis>SQL parameter reference</emphasis></simpara>

    <simpara><literal>&lt;SQL parameter reference&gt; ::= &lt;basic identifier
    chain&gt;</literal></simpara>

    <simpara>Reference an SQL parameter.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>aggregate function</primary>
    </indexterm>

    <simpara><emphasis role="bold">aggregate function</emphasis></simpara>

    <simpara><emphasis>set function specification</emphasis></simpara>

    <simpara><literal>&lt;set function specification&gt; ::= &lt;aggregate
    function&gt; | &lt;grouping operation&gt;</literal></simpara>

    <simpara><literal>&lt;grouping operation&gt; ::= GROUPING &lt;left
    paren&gt; &lt;column reference&gt; [ { &lt;comma&gt; &lt;column
    reference&gt; }... ] &lt;right paren&gt;</literal></simpara>

    <simpara>Specify a value derived by the application of a function to an
    argument.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>window function type OVER</primary>
    </indexterm>

    <simpara><emphasis role="bold">window function type
    OVER</emphasis></simpara>

    <simpara><emphasis>window function</emphasis></simpara>

    <simpara><literal>&lt;window function&gt; ::= &lt;window function type&gt;
    OVER &lt;window name or specification&gt;</literal></simpara>

    <simpara><literal>&lt;window function type&gt; ::= &lt;rank function
    type&gt; &lt;left paren&gt; &lt;right paren&gt; | ROW_NUMBER &lt;left
    paren&gt; &lt;right paren&gt; | &lt;aggregate function&gt; | &lt;ntile
    function&gt; | &lt;lead or lag function&gt; | &lt;first or last value
    function&gt; | &lt;nth value function&gt;</literal></simpara>

    <simpara><literal>&lt;rank function type&gt; ::= RANK | DENSE_RANK |
    PERCENT_RANK | CUME_DIST</literal></simpara>

    <simpara><literal>&lt;ntile function&gt; ::= NTILE &lt;left paren&gt;
    &lt;number of tiles&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;number of tiles&gt; ::= &lt;simple value
    specification&gt; | &lt;dynamic parameter
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;lead or lag function&gt; ::= &lt;lead or lag&gt;
    &lt;left paren&gt; &lt;lead or lag extent&gt; [ &lt;comma&gt;
    &lt;offset&gt; [ &lt;comma&gt; &lt;default expression&gt; ] ] &lt;right
    paren&gt; [ &lt;null treatment&gt; ]</literal></simpara>

    <simpara><literal>&lt;lead or lag&gt; ::= LEAD | LAG</literal></simpara>

    <simpara><literal>&lt;lead or lag extent&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;offset&gt; ::= &lt;exact numeric
    literal&gt;</literal></simpara>

    <simpara><literal>&lt;default expression&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;null treatment&gt; ::= RESPECT NULLS | IGNORE
    NULLS</literal></simpara>

    <simpara><literal>&lt;first or last value function&gt; ::= &lt;first or
    last value&gt; &lt;left paren&gt; &lt;value expression&gt; &lt;right
    paren&gt; [ &lt;null treatment&gt; ]</literal></simpara>

    <simpara><literal>&lt;first or last value&gt; ::= FIRST_VALUE |
    LAST_VALUE</literal></simpara>

    <simpara><literal>&lt;nth value function&gt; ::= NTH_VALUE &lt;left
    paren&gt; &lt;value expression&gt; &lt;comma&gt; &lt;nth row&gt; &lt;right
    paren&gt; [ &lt;from first or last&gt; ] [ &lt;null treatment&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;nth row&gt; ::= &lt;simple value specification&gt; |
    &lt;dynamic parameter specification&gt;</literal></simpara>

    <simpara><literal>&lt;from first or last&gt; ::= FROM FIRST | FROM
    LAST</literal></simpara>

    <simpara><literal>&lt;window name or specification&gt; ::= &lt;window
    name&gt; | &lt;in-line window specification&gt;</literal></simpara>

    <simpara><literal>&lt;in-line window specification&gt; ::= &lt;window
    specification&gt;</literal></simpara>

    <simpara>Specify a window function.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>case abbreviation</primary>
    </indexterm>

    <simpara><emphasis role="bold">case abbreviation</emphasis></simpara>

    <simpara><emphasis>case expression</emphasis></simpara>

    <simpara><literal>&lt;case expression&gt; ::= &lt;case abbreviation&gt; |
    &lt;case specification&gt;</literal></simpara>

    <simpara><literal>&lt;case abbreviation&gt; ::= NULLIF &lt;left paren&gt;
    &lt;value expression&gt; &lt;comma&gt; &lt;value expression&gt; &lt;right
    paren&gt; | COALESCE &lt;left paren&gt; &lt;value expression&gt; {
    &lt;comma&gt; &lt;value expression&gt; }... &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;case specification&gt; ::= &lt;simple case&gt; |
    &lt;searched case&gt;</literal></simpara>

    <simpara><literal>&lt;simple case&gt; ::= CASE &lt;case operand&gt;
    &lt;simple when clause&gt;... [ &lt;else clause&gt; ]
    END</literal></simpara>

    <simpara><literal>&lt;searched case&gt; ::= CASE &lt;searched when
    clause&gt;... [ &lt;else clause&gt; ] END</literal></simpara>

    <simpara><literal>&lt;simple when clause&gt; ::= WHEN &lt;when operand
    list&gt; THEN &lt;result&gt;</literal></simpara>

    <simpara><literal>&lt;searched when clause&gt; ::= WHEN &lt;search
    condition&gt; THEN &lt;result&gt;</literal></simpara>

    <simpara><literal>&lt;else clause&gt; ::= ELSE
    &lt;result&gt;</literal></simpara>

    <simpara><literal>&lt;case operand&gt; ::= &lt;row value predicand&gt; |
    &lt;overlaps predicate part 1&gt;</literal></simpara>

    <simpara><literal>&lt;when operand list&gt; ::= &lt;when operand&gt; [ {
    &lt;comma&gt; &lt;when operand&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;when operand&gt; ::= &lt;row value predicand&gt; |
    &lt;comparison predicate part 2&gt; | &lt;between predicate part 2&gt; |
    &lt;in predicate part 2&gt; | &lt;character like predicate part 2&gt; |
    &lt;octet like predicate part 2&gt; | &lt;similar predicate part 2&gt; |
    &lt;regex like predicate part 2&gt; | &lt;null predicate part 2&gt; |
    &lt;quantified comparison predicate part 2&gt; | &lt;normalized predicate
    part 2&gt; | &lt;match predicate part 2&gt; | &lt;overlaps predicate part
    2&gt; | &lt;distinct predicate part 2&gt; | &lt;member predicate part
    2&gt; | &lt;submultiset predicate part 2&gt; | &lt;set predicate part
    2&gt; | &lt;type predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;result&gt; ::= &lt;result expression&gt; |
    NULL</literal></simpara>

    <simpara><literal>&lt;result expression&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara>Specify a conditional value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>CAST</primary>
    </indexterm>

    <simpara><emphasis role="bold">CAST</emphasis></simpara>

    <simpara><emphasis>cast specification</emphasis></simpara>

    <simpara><literal>&lt;cast specification&gt; ::= CAST &lt;left paren&gt;
    &lt;cast operand&gt; AS &lt;cast target&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;cast operand&gt; ::= &lt;value expression&gt; |
    &lt;implicitly typed value specification&gt;</literal></simpara>

    <simpara><literal>&lt;cast target&gt; ::= &lt;domain name&gt; | &lt;data
    type&gt;</literal></simpara>

    <simpara>Specify a data conversion.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>NEXT VALUE FOR</primary>
    </indexterm>

    <simpara><emphasis role="bold">NEXT VALUE FOR</emphasis></simpara>

    <simpara><emphasis>next value expression</emphasis></simpara>

    <simpara><literal>&lt;next value expression&gt; ::= NEXT VALUE FOR
    &lt;sequence generator name&gt;</literal></simpara>

    <simpara>Return the next value of a sequence generator.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>value expression primary</primary>
    </indexterm>

    <simpara><emphasis role="bold">value expression
    primary</emphasis></simpara>

    <simpara><emphasis>field reference</emphasis></simpara>

    <simpara><literal>&lt;field reference&gt; ::= &lt;value expression
    primary&gt; &lt;period&gt; &lt;field name&gt;</literal></simpara>

    <simpara>Reference a field of a row value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>TREAT</primary>
    </indexterm>

    <simpara><emphasis role="bold">TREAT</emphasis></simpara>

    <simpara><emphasis>subtype treatment</emphasis></simpara>

    <simpara><literal>&lt;subtype treatment&gt; ::= TREAT &lt;left paren&gt;
    &lt;subtype operand&gt; AS &lt;target subtype&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;subtype operand&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;target subtype&gt; ::= &lt;path-resolved
    user-defined type name&gt; | &lt;reference type&gt;</literal></simpara>

    <simpara>Modify the declared type of an expression.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>direct invocation</primary>
    </indexterm>

    <simpara><emphasis role="bold">direct invocation</emphasis></simpara>

    <simpara><emphasis>method invocation</emphasis></simpara>

    <simpara><literal>&lt;method invocation&gt; ::= &lt;direct invocation&gt;
    | &lt;generalized invocation&gt;</literal></simpara>

    <simpara><literal>&lt;direct invocation&gt; ::= &lt;value expression
    primary&gt; &lt;period&gt; &lt;method name&gt; [ &lt;SQL argument list&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;generalized invocation&gt; ::= &lt;left paren&gt;
    &lt;value expression primary&gt; AS &lt;data type&gt; &lt;right paren&gt;
    &lt;period&gt; &lt;method name&gt; [ &lt;SQL argument list&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;method selection&gt; ::= &lt;routine
    invocation&gt;</literal></simpara>

    <simpara><literal>&lt;constructor method selection&gt; ::= &lt;routine
    invocation&gt;</literal></simpara>

    <simpara>Reference an SQL-invoked method of a user-defined type
    value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>path-resolved user-defined type name</primary>
    </indexterm>

    <simpara><emphasis role="bold">path-resolved user-defined type
    name</emphasis></simpara>

    <simpara><emphasis>static method invocation</emphasis></simpara>

    <simpara><literal>&lt;static method invocation&gt; ::= &lt;path-resolved
    user-defined type name&gt; &lt;double colon&gt; &lt;method name&gt; [
    &lt;SQL argument list&gt; ]</literal></simpara>

    <simpara><literal>&lt;static method selection&gt; ::= &lt;routine
    invocation&gt;</literal></simpara>

    <simpara>Invoke a static method.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>NEW</primary>
    </indexterm>

    <simpara><emphasis role="bold">NEW</emphasis></simpara>

    <simpara><emphasis>new specification</emphasis></simpara>

    <simpara><literal>&lt;new specification&gt; ::= NEW &lt;path-resolved
    user-defined type name&gt; &lt;SQL argument list&gt;</literal></simpara>

    <simpara><literal>&lt;new invocation&gt; ::= &lt;method invocation&gt; |
    &lt;routine invocation&gt;</literal></simpara>

    <simpara>Invoke a method on a newly-constructed value of a structured
    type.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>value expression primary</primary>
    </indexterm>

    <simpara><emphasis role="bold">value expression
    primary</emphasis></simpara>

    <simpara><emphasis>attribute or method reference</emphasis></simpara>

    <simpara><literal>&lt;attribute or method reference&gt; ::= &lt;value
    expression primary&gt; &lt;dereference operator&gt; &lt;qualified
    identifier&gt; [ &lt;SQL argument list&gt; ]</literal></simpara>

    <simpara><literal>&lt;dereference operator&gt; ::= &lt;right
    arrow&gt;</literal></simpara>

    <simpara>Return a value acquired by accessing a column of the row
    identified by a value of a reference type or by invoking an SQL-invoked
    method.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>reference value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">reference value
    expression</emphasis></simpara>

    <simpara><emphasis>dereference operation</emphasis></simpara>

    <simpara><literal>&lt;dereference operation&gt; ::= &lt;reference value
    expression&gt; &lt;dereference operator&gt; &lt;attribute
    name&gt;</literal></simpara>

    <simpara>Access a column of the row identified by a value of a reference
    type.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>value expression primary</primary>
    </indexterm>

    <simpara><emphasis role="bold">value expression
    primary</emphasis></simpara>

    <simpara><emphasis>method reference</emphasis></simpara>

    <simpara><literal>&lt;method reference&gt; ::= &lt;value expression
    primary&gt; &lt;dereference operator&gt; &lt;method name&gt; &lt;SQL
    argument list&gt;</literal></simpara>

    <simpara>Return a value acquired from invoking an SQL-invoked routine that
    is a method.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>DEREF</primary>
    </indexterm>

    <simpara><emphasis role="bold">DEREF</emphasis></simpara>

    <simpara><emphasis>reference resolution</emphasis></simpara>

    <simpara><literal>&lt;reference resolution&gt; ::= DEREF &lt;left
    paren&gt; &lt;reference value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Obtain the value referenced by a reference value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>array value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">array value expression</emphasis></simpara>

    <simpara><emphasis>array element reference</emphasis></simpara>

    <simpara><literal>&lt;array element reference&gt; ::= &lt;array value
    expression&gt; &lt;left bracket or trigraph&gt; &lt;numeric value
    expression&gt; &lt;right bracket or trigraph&gt;</literal></simpara>

    <simpara>Return an element of an array.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>ELEMENT</primary>
    </indexterm>

    <simpara><emphasis role="bold">ELEMENT</emphasis></simpara>

    <simpara><emphasis>multiset element reference</emphasis></simpara>

    <simpara><literal>&lt;multiset element reference&gt; ::= ELEMENT &lt;left
    paren&gt; &lt;multiset value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Return the sole element of a multiset of one element.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>common value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">common value
    expression</emphasis></simpara>

    <simpara><emphasis>value expression</emphasis></simpara>

    <simpara><literal>&lt;value expression&gt; ::= &lt;common value
    expression&gt; | &lt;boolean value expression&gt; | &lt;row value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;common value expression&gt; ::= &lt;numeric value
    expression&gt; | &lt;string value expression&gt; | &lt;datetime value
    expression&gt; | &lt;interval value expression&gt; | &lt;user-defined type
    value expression&gt; | &lt;reference value expression&gt; | &lt;collection
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;user-defined type value expression&gt; ::= &lt;value
    expression primary&gt;</literal></simpara>

    <simpara><literal>&lt;reference value expression&gt; ::= &lt;value
    expression primary&gt;</literal></simpara>

    <simpara><literal>&lt;collection value expression&gt; ::= &lt;array value
    expression&gt; | &lt;multiset value expression&gt;</literal></simpara>

    <simpara>Specify a value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>term</primary>
    </indexterm>

    <simpara><emphasis role="bold">term</emphasis></simpara>

    <simpara><emphasis>numeric value expression</emphasis></simpara>

    <simpara><literal>&lt;numeric value expression&gt; ::= &lt;term&gt; |
    &lt;numeric value expression&gt; &lt;plus sign&gt; &lt;term&gt; |
    &lt;numeric value expression&gt; &lt;minus sign&gt;
    &lt;term&gt;</literal></simpara>

    <simpara><literal>&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt;
    &lt;asterisk&gt; &lt;factor&gt; | &lt;term&gt; &lt;solidus&gt;
    &lt;factor&gt;</literal></simpara>

    <simpara><literal>&lt;factor&gt; ::= [ &lt;sign&gt; ] &lt;numeric
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;numeric primary&gt; ::= &lt;value expression
    primary&gt; | &lt;numeric value function&gt;</literal></simpara>

    <simpara>Specify a numeric value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>position expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">position expression</emphasis></simpara>

    <simpara><emphasis>numeric value function</emphasis></simpara>

    <simpara><literal>&lt;numeric value function&gt; ::= &lt;position
    expression&gt; | &lt;regex occurrences function&gt; | &lt;regex position
    expression&gt; | &lt;extract expression&gt; | &lt;length expression&gt; |
    &lt;cardinality expression&gt; | &lt;max cardinality expression&gt; |
    &lt;absolute value expression&gt; | &lt;modulus expression&gt; |
    &lt;natural logarithm&gt; | &lt;exponential function&gt; | &lt;power
    function&gt; | &lt;square root&gt; | &lt;floor function&gt; | &lt;ceiling
    function&gt; | &lt;width bucket function&gt;</literal></simpara>

    <simpara><literal>&lt;position expression&gt; ::= &lt;character position
    expression&gt; | &lt;binary position expression&gt;</literal></simpara>

    <simpara><literal>&lt;regex occurrences function&gt; ::= OCCURRENCES_REGEX
    &lt;left paren&gt; &lt;XQuery pattern&gt; [ FLAG &lt;XQuery option
    flag&gt; ] IN &lt;regex subject string&gt; [ FROM &lt;start position&gt; ]
    [ USING &lt;char length units&gt; ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;XQuery pattern&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;XQuery option flag&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;regex subject string&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;regex position expression&gt; ::= POSITION_REGEX
    &lt;left paren&gt; [ &lt;regex position start or after&gt; ] &lt;XQuery
    pattern&gt; [ FLAG &lt;XQuery option flag&gt; ] IN &lt;regex subject
    string&gt; [ FROM &lt;start position&gt; ] [ USING &lt;char length
    units&gt; ] [ OCCURRENCE &lt;regex occurrence&gt; ] [ GROUP &lt;regex
    capture group&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;regex position start or after&gt; ::= START |
    AFTER</literal></simpara>

    <simpara><literal>&lt;regex occurrence&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;regex capture group&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;character position expression&gt; ::= POSITION
    &lt;left paren&gt; &lt;character value expression 1&gt; IN &lt;character
    value expression 2&gt; [ USING &lt;char length units&gt; ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;character value expression 1&gt; ::= &lt;character
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;character value expression 2&gt; ::= &lt;character
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;binary position expression&gt; ::= POSITION &lt;left
    paren&gt; &lt;binary value expression&gt; IN &lt;binary value
    expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;length expression&gt; ::= &lt;char length
    expression&gt; | &lt;octet length expression&gt;</literal></simpara>

    <simpara><literal>&lt;char length expression&gt; ::= { CHAR_LENGTH |
    CHARACTER_LENGTH } &lt;left paren&gt; &lt;character value expression&gt; [
    USING &lt;char length units&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;octet length expression&gt; ::= OCTET_LENGTH
    &lt;left paren&gt; &lt;string value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;extract expression&gt; ::= EXTRACT &lt;left
    paren&gt; &lt;extract field&gt; FROM &lt;extract source&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;extract field&gt; ::= &lt;primary datetime field&gt;
    | &lt;time zone field&gt;</literal></simpara>

    <simpara><literal>&lt;time zone field&gt; ::= TIMEZONE_HOUR |
    TIMEZONE_MINUTE</literal></simpara>

    <simpara><literal>&lt;extract source&gt; ::= &lt;datetime value
    expression&gt; | &lt;interval value expression&gt;</literal></simpara>

    <simpara><literal>&lt;cardinality expression&gt; ::= CARDINALITY &lt;left
    paren&gt; &lt;collection value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;max cardinality expression&gt; ::= MAX_CARDINALITY
    &lt;left paren&gt; &lt;array value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;absolute value expression&gt; ::= ABS &lt;left
    paren&gt; &lt;numeric value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;modulus expression&gt; ::= MOD &lt;left paren&gt;
    &lt;numeric value expression dividend&gt; &lt;comma&gt; &lt;numeric value
    expression divisor&gt;&lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;numeric value expression dividend&gt; ::=
    &lt;numeric value expression&gt;</literal></simpara>

    <simpara><literal>&lt;numeric value expression divisor&gt; ::= &lt;numeric
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;natural logarithm&gt; ::= LN &lt;left paren&gt;
    &lt;numeric value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;exponential function&gt; ::= EXP &lt;left paren&gt;
    &lt;numeric value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;power function&gt; ::= POWER &lt;left paren&gt;
    &lt;numeric value expression base&gt; &lt;comma&gt; &lt;numeric value
    expression exponent&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;numeric value expression base&gt; ::= &lt;numeric
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;numeric value expression exponent&gt; ::=
    &lt;numeric value expression&gt;</literal></simpara>

    <simpara><literal>&lt;square root&gt; ::= SQRT &lt;left paren&gt;
    &lt;numeric value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;floor function&gt; ::= FLOOR &lt;left paren&gt;
    &lt;numeric value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;ceiling function&gt; ::= { CEIL | CEILING } &lt;left
    paren&gt; &lt;numeric value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;width bucket function&gt; ::= WIDTH_BUCKET &lt;left
    paren&gt; &lt;width bucket operand&gt; &lt;comma&gt; &lt;width bucket
    bound 1&gt; &lt;comma&gt; &lt;width bucket bound 2&gt; &lt;comma&gt;
    &lt;width bucket count&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;width bucket operand&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;width bucket bound 1&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;width bucket bound 2&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;width bucket count&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara>Specify a function yielding a value of type numeric.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>character value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">character value
    expression</emphasis></simpara>

    <simpara><emphasis>string value expression</emphasis></simpara>

    <simpara><literal>&lt;string value expression&gt; ::= &lt;character value
    expression&gt; | &lt;binary value expression&gt;</literal></simpara>

    <simpara><literal>&lt;character value expression&gt; ::=
    &lt;concatenation&gt; | &lt;character factor&gt;</literal></simpara>

    <simpara><literal>&lt;concatenation&gt; ::= &lt;character value
    expression&gt; &lt;concatenation operator&gt; &lt;character
    factor&gt;</literal></simpara>

    <simpara><literal>&lt;character factor&gt; ::= &lt;character primary&gt; [
    &lt;collate clause&gt; ]</literal></simpara>

    <simpara><literal>&lt;character primary&gt; ::= &lt;value expression
    primary&gt; | &lt;string value function&gt;</literal></simpara>

    <simpara><literal>&lt;binary value expression&gt; ::= &lt;binary
    concatenation&gt; | &lt;binary factor&gt;</literal></simpara>

    <simpara><literal>&lt;binary factor&gt; ::= &lt;binary
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;binary primary&gt; ::= &lt;value expression
    primary&gt; | &lt;string value function&gt;</literal></simpara>

    <simpara><literal>&lt;binary concatenation&gt; ::= &lt;binary value
    expression&gt; &lt;concatenation operator&gt; &lt;binary
    factor&gt;</literal></simpara>

    <simpara>Specify a character string value or a binary string
    value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>character value function</primary>
    </indexterm>

    <simpara><emphasis role="bold">character value
    function</emphasis></simpara>

    <simpara><emphasis>string value function</emphasis></simpara>

    <simpara><literal>&lt;string value function&gt; ::= &lt;character value
    function&gt; | &lt;binary value function&gt;</literal></simpara>

    <simpara><literal>&lt;character value function&gt; ::= &lt;character
    substring function&gt; | &lt;regular expression substring function&gt; |
    &lt;regex substring function&gt; | &lt;fold&gt; | &lt;transcoding&gt; |
    &lt;character transliteration&gt; | &lt;regex transliteration&gt; |
    &lt;trim function&gt; | &lt;character overlay function&gt; | &lt;normalize
    function&gt; | &lt;specific type method&gt;</literal></simpara>

    <simpara><literal>&lt;character substring function&gt; ::= SUBSTRING
    &lt;left paren&gt; &lt;character value expression&gt; FROM &lt;start
    position&gt; [ FOR &lt;string length&gt; ] [ USING &lt;char length
    units&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;regular expression substring function&gt; ::=
    SUBSTRING &lt;left paren&gt; &lt;character value expression&gt; SIMILAR
    &lt;character value expression&gt; ESCAPE &lt;escape character&gt;
    &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;regex substring function&gt; ::= SUBSTRING_REGEX
    &lt;left paren&gt; &lt;XQuery pattern&gt; [ FLAG &lt;XQuery option
    flag&gt; ] IN &lt;regex subject string&gt; [ FROM &lt;start position&gt; ]
    [ USING &lt;char length units&gt; ] [ OCCURRENCE &lt;regex occurrence&gt;
    ] [ GROUP &lt;regex capture group&gt; ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;fold&gt; ::= { UPPER | LOWER } &lt;left paren&gt;
    &lt;character value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;transcoding&gt; ::= CONVERT &lt;left paren&gt;
    &lt;character value expression&gt; USING &lt;transcoding name&gt;
    &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;character transliteration&gt; ::= TRANSLATE &lt;left
    paren&gt; &lt;character value expression&gt; USING &lt;transliteration
    name&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;regex transliteration&gt; ::= TRANSLATE_REGEX
    &lt;left paren&gt; &lt;XQuery pattern&gt; [ FLAG &lt;XQuery option
    flag&gt; ] IN &lt;regex subject string&gt; [ WITH &lt;XQuery replacement
    string&gt; ] [ FROM &lt;start position&gt; ] [ USING &lt;char length
    units&gt; ] [ OCCURRENCE &lt;regex transliteration occurrence&gt; ]
    &lt;left paren&gt;</literal></simpara>

    <simpara><literal>&lt;XQuery replacement string&gt; ::= &lt;character
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;regex transliteration occurrence&gt; ::= &lt;regex
    occurrence&gt; | ALL</literal></simpara>

    <simpara><literal>&lt;trim function&gt; ::= TRIM &lt;left paren&gt;
    &lt;trim operands&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;trim operands&gt; ::= [ [ &lt;trim specification&gt;
    ] [ &lt;trim character&gt; ] FROM ] &lt;trim
    source&gt;</literal></simpara>

    <simpara><literal>&lt;trim source&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;trim specification&gt; ::= LEADING | TRAILING |
    BOTH</literal></simpara>

    <simpara><literal>&lt;trim character&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;character overlay function&gt; ::= OVERLAY &lt;left
    paren&gt; &lt;character value expression&gt; PLACING &lt;character value
    expression&gt; FROM &lt;start position&gt; [ FOR &lt;string length&gt; ] [
    USING &lt;char length units&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;normalize function&gt; ::= NORMALIZE &lt;left
    paren&gt; &lt;character value expression&gt; [ &lt;comma&gt; &lt;normal
    form&gt; [ &lt;comma&gt; &lt;normalize function result length&gt; ] ]
    &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;normal form&gt; ::= NFC | NFD | NFKC |
    NFKD</literal></simpara>

    <simpara><literal>&lt;normalize function result length&gt; ::=
    &lt;character length&gt; | &lt;character large object
    length&gt;</literal></simpara>

    <simpara><literal>&lt;specific type method&gt; ::= &lt;user-defined type
    value expression&gt; &lt;period&gt; SPECIFICTYPE [ &lt;left paren&gt;
    &lt;right paren&gt; ]</literal></simpara>

    <simpara><literal>&lt;binary value function&gt; ::= &lt;binary substring
    function&gt; | &lt;binary trim function&gt; | &lt;binary overlay
    function&gt;</literal></simpara>

    <simpara><literal>&lt;binary substring function&gt; ::= SUBSTRING &lt;left
    paren&gt; &lt;binary value expression&gt; FROM &lt;start position&gt; [
    FOR &lt;string length&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;binary trim function&gt; ::= TRIM &lt;left paren&gt;
    &lt;binary trim operands&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;binary trim operands&gt; ::= [ [ &lt;trim
    specification&gt; ] [ &lt;trim octet&gt; ] FROM ] &lt;binary trim
    source&gt;</literal></simpara>

    <simpara><literal>&lt;binary trim source&gt; ::= &lt;binary value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;trim octet&gt; ::= &lt;binary value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;binary overlay function&gt; ::= OVERLAY &lt;left
    paren&gt; &lt;binary value expression&gt; PLACING &lt;binary value
    expression&gt; FROM &lt;start position&gt; [ FOR &lt;string length&gt; ]
    &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;start position&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;string length&gt; ::= &lt;numeric value
    expression&gt;</literal></simpara>

    <simpara>Specify a function yielding a value of type character string or
    binary string.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>datetime term</primary>
    </indexterm>

    <simpara><emphasis role="bold">datetime term</emphasis></simpara>

    <simpara><emphasis>datetime value expression</emphasis></simpara>

    <simpara><literal>&lt;datetime value expression&gt; ::= &lt;datetime
    term&gt; | &lt;interval value expression&gt; &lt;plus sign&gt;
    &lt;datetime term&gt; | &lt;datetime value expression&gt; &lt;plus
    sign&gt; &lt;interval term&gt; | &lt;datetime value expression&gt;
    &lt;minus sign&gt; &lt;interval term&gt;</literal></simpara>

    <simpara><literal>&lt;datetime term&gt; ::= &lt;datetime
    factor&gt;</literal></simpara>

    <simpara><literal>&lt;datetime factor&gt; ::= &lt;datetime primary&gt; [
    &lt;time zone&gt; ]</literal></simpara>

    <simpara><literal>&lt;datetime primary&gt; ::= &lt;value expression
    primary&gt; | &lt;datetime value function&gt;</literal></simpara>

    <simpara><literal>&lt;time zone&gt; ::= AT &lt;time zone
    specifier&gt;</literal></simpara>

    <simpara><literal>&lt;time zone specifier&gt; ::= LOCAL | TIME ZONE
    &lt;interval primary&gt;</literal></simpara>

    <simpara>Specify a datetime value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>current date value function</primary>
    </indexterm>

    <simpara><emphasis role="bold">current date value
    function</emphasis></simpara>

    <simpara><emphasis>datetime value function</emphasis></simpara>

    <simpara><literal>&lt;datetime value function&gt; ::= &lt;current date
    value function&gt; | &lt;current time value function&gt; | &lt;current
    timestamp value function&gt; | &lt;current local time value function&gt; |
    &lt;current local timestamp value function&gt;</literal></simpara>

    <simpara><literal>&lt;current date value function&gt; ::=
    CURRENT_DATE</literal></simpara>

    <simpara><literal>&lt;current time value function&gt; ::= CURRENT_TIME [
    &lt;left paren&gt; &lt;time precision&gt; &lt;right paren&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;current local time value function&gt; ::= LOCALTIME
    [ &lt;left paren&gt; &lt;time precision&gt; &lt;right paren&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;current timestamp value function&gt; ::=
    CURRENT_TIMESTAMP [ &lt;left paren&gt; &lt;timestamp precision&gt;
    &lt;right paren&gt; ]</literal></simpara>

    <simpara><literal>&lt;current local timestamp value function&gt; ::=
    LOCALTIMESTAMP [ &lt;left paren&gt; &lt;timestamp precision&gt; &lt;right
    paren&gt; ]</literal></simpara>

    <simpara>Specify a function yielding a value of type datetime.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>interval term</primary>
    </indexterm>

    <simpara><emphasis role="bold">interval term</emphasis></simpara>

    <simpara><emphasis>interval value expression</emphasis></simpara>

    <simpara><literal>&lt;interval value expression&gt; ::= &lt;interval
    term&gt; | &lt;interval value expression 1&gt; &lt;plus sign&gt;
    &lt;interval term 1&gt; | &lt;interval value expression 1&gt; &lt;minus
    sign&gt; &lt;interval term 1&gt; | &lt;left paren&gt; &lt;datetime value
    expression&gt; &lt;minus sign&gt; &lt;datetime term&gt; &lt;right
    paren&gt; &lt;interval qualifier&gt;</literal></simpara>

    <simpara><literal>&lt;interval term&gt; ::= &lt;interval factor&gt; |
    &lt;interval term 2&gt; &lt;asterisk&gt; &lt;factor&gt; | &lt;interval
    term 2&gt; &lt;solidus&gt; &lt;factor&gt; | &lt;term&gt; &lt;asterisk&gt;
    &lt;interval factor&gt;</literal></simpara>

    <simpara><literal>&lt;interval factor&gt; ::= [ &lt;sign&gt; ]
    &lt;interval primary&gt;</literal></simpara>

    <simpara><literal>&lt;interval primary&gt; ::= &lt;value expression
    primary&gt; [ &lt;interval qualifier&gt; ] | &lt;interval value
    function&gt;</literal></simpara>

    <simpara><literal>&lt;interval value expression 1&gt; ::= &lt;interval
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;interval term 1&gt; ::= &lt;interval
    term&gt;</literal></simpara>

    <simpara><literal>&lt;interval term 2&gt; ::= &lt;interval
    term&gt;</literal></simpara>

    <simpara>Specify an interval value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>interval absolute value function</primary>
    </indexterm>

    <simpara><emphasis role="bold">interval absolute value
    function</emphasis></simpara>

    <simpara><emphasis>interval value function</emphasis></simpara>

    <simpara><literal>&lt;interval value function&gt; ::= &lt;interval
    absolute value function&gt;</literal></simpara>

    <simpara><literal>&lt;interval absolute value function&gt; ::= ABS
    &lt;left paren&gt; &lt;interval value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Specify a function yielding a value of type interval.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>boolean term</primary>
    </indexterm>

    <simpara><emphasis role="bold">boolean term</emphasis></simpara>

    <simpara><emphasis>boolean value expression</emphasis></simpara>

    <simpara><literal>&lt;boolean value expression&gt; ::= &lt;boolean
    term&gt; | &lt;boolean value expression&gt; OR &lt;boolean
    term&gt;</literal></simpara>

    <simpara><literal>&lt;boolean term&gt; ::= &lt;boolean factor&gt; |
    &lt;boolean term&gt; AND &lt;boolean factor&gt;</literal></simpara>

    <simpara><literal>&lt;boolean factor&gt; ::= [ NOT ] &lt;boolean
    test&gt;</literal></simpara>

    <simpara><literal>&lt;boolean test&gt; ::= &lt;boolean primary&gt; [ IS [
    NOT ] &lt;truth value&gt; ]</literal></simpara>

    <simpara><literal>&lt;truth value&gt; ::= TRUE | FALSE |
    UNKNOWN</literal></simpara>

    <simpara><literal>&lt;boolean primary&gt; ::= &lt;predicate&gt; |
    &lt;boolean predicand&gt;</literal></simpara>

    <simpara><literal>&lt;boolean predicand&gt; ::= &lt;parenthesized boolean
    value expression&gt; | &lt;nonparenthesized value expression
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;parenthesized boolean value expression&gt; ::=
    &lt;left paren&gt; &lt;boolean value expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Specify a boolean value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>array concatenation</primary>
    </indexterm>

    <simpara><emphasis role="bold">array concatenation</emphasis></simpara>

    <simpara><emphasis>array value expression</emphasis></simpara>

    <simpara><literal>&lt;array value expression&gt; ::= &lt;array
    concatenation&gt; | &lt;array primary&gt;</literal></simpara>

    <simpara><literal>&lt;array concatenation&gt; ::= &lt;array value
    expression 1&gt; &lt;concatenation operator&gt; &lt;array
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;array value expression 1&gt; ::= &lt;array value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;array primary&gt; ::= &lt;array value function&gt; |
    &lt;value expression primary&gt;</literal></simpara>

    <simpara>Specify an array value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>trim array function</primary>
    </indexterm>

    <simpara><emphasis role="bold">trim array function</emphasis></simpara>

    <simpara><emphasis>array value function</emphasis></simpara>

    <simpara><literal>&lt;array value function&gt; ::= &lt;trim array
    function&gt;</literal></simpara>

    <simpara><literal>&lt;trim array function&gt; ::= TRIM_ARRAY &lt;left
    paren&gt; &lt;array value expression&gt; &lt;comma&gt; &lt;numeric value
    expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara>Specify a function yielding a value of an array type.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>array value constructor by enumeration</primary>
    </indexterm>

    <simpara><emphasis role="bold">array value constructor by
    enumeration</emphasis></simpara>

    <simpara><emphasis>array value constructor</emphasis></simpara>

    <simpara><literal>&lt;array value constructor&gt; ::= &lt;array value
    constructor by enumeration&gt; | &lt;array value constructor by
    query&gt;</literal></simpara>

    <simpara><literal>&lt;array value constructor by enumeration&gt; ::= ARRAY
    &lt;left bracket or trigraph&gt; &lt;array element list&gt; &lt;right
    bracket or trigraph&gt;</literal></simpara>

    <simpara><literal>&lt;array element list&gt; ::= &lt;array element&gt; [ {
    &lt;comma&gt; &lt;array element&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;array element&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;array value constructor by query&gt; ::= ARRAY
    &lt;left paren&gt; &lt;query expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara>Specify construction of an array.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>multiset term</primary>
    </indexterm>

    <simpara><emphasis role="bold">multiset term</emphasis></simpara>

    <simpara><emphasis>multiset value expression</emphasis></simpara>

    <simpara><literal>&lt;multiset value expression&gt; ::= &lt;multiset
    term&gt; | &lt;multiset value expression&gt; MULTISET UNION [ ALL |
    DISTINCT ] &lt;multiset term&gt; | &lt;multiset value expression&gt;
    MULTISET EXCEPT [ ALL | DISTINCT ] &lt;multiset
    term&gt;</literal></simpara>

    <simpara><literal>&lt;multiset term&gt; ::= &lt;multiset primary&gt; |
    &lt;multiset term&gt; MULTISET INTERSECT [ ALL | DISTINCT ] &lt;multiset
    primary&gt;</literal></simpara>

    <simpara><literal>&lt;multiset primary&gt; ::= &lt;multiset value
    function&gt; | &lt;value expression primary&gt;</literal></simpara>

    <simpara>Specify a multiset value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>multiset set function</primary>
    </indexterm>

    <simpara><emphasis role="bold">multiset set function</emphasis></simpara>

    <simpara><emphasis>multiset value function</emphasis></simpara>

    <simpara><literal>&lt;multiset value function&gt; ::= &lt;multiset set
    function&gt;</literal></simpara>

    <simpara><literal>&lt;multiset set function&gt; ::= SET &lt;left paren&gt;
    &lt;multiset value expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara>Specify a function yielding a value of a multiset type.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>multiset value constructor by enumeration</primary>
    </indexterm>

    <simpara><emphasis role="bold">multiset value constructor by
    enumeration</emphasis></simpara>

    <simpara><emphasis>multiset value constructor</emphasis></simpara>

    <simpara><literal>&lt;multiset value constructor&gt; ::= &lt;multiset
    value constructor by enumeration&gt; | &lt;multiset value constructor by
    query&gt; | &lt;table value constructor by query&gt;</literal></simpara>

    <simpara><literal>&lt;multiset value constructor by enumeration&gt; ::=
    MULTISET &lt;left bracket or trigraph&gt; &lt;multiset element list&gt;
    &lt;right bracket or trigraph&gt;</literal></simpara>

    <simpara><literal>&lt;multiset element list&gt; ::= &lt;multiset
    element&gt; [ { &lt;comma&gt; &lt;multiset element&gt; }...
    ]</literal></simpara>

    <simpara><literal>&lt;multiset element&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;multiset value constructor by query&gt; ::= MULTISET
    &lt;table subquery&gt;</literal></simpara>

    <simpara><literal>&lt;table value constructor by query&gt; ::= TABLE
    &lt;table subquery&gt;</literal></simpara>

    <simpara>Specify construction of a multiset.</simpara>

    <!-- From Foundation chapt. 8 -->

    <indexterm significance="preferred" type="sql">
      <primary>comparison predicate</primary>
    </indexterm>

    <simpara><emphasis role="bold">comparison predicate</emphasis></simpara>

    <simpara><emphasis>predicate</emphasis></simpara>

    <simpara><literal>&lt;predicate&gt; ::= &lt;comparison predicate&gt; |
    &lt;between predicate&gt; | &lt;in predicate&gt; | &lt;like predicate&gt;
    | &lt;similar predicate&gt; | &lt;regex like predicate&gt; | &lt;null
    predicate&gt; | &lt;quantified comparison predicate&gt; | &lt;exists
    predicate&gt; | &lt;unique predicate&gt; | &lt;normalized predicate&gt; |
    &lt;match predicate&gt; | &lt;overlaps predicate&gt; | &lt;distinct
    predicate&gt; | &lt;member predicate&gt; | &lt;submultiset predicate&gt; |
    &lt;set predicate&gt; | &lt;type predicate&gt;</literal></simpara>

    <simpara>Specify a condition that can be evaluated to give a boolean
    value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>comparison predicate</emphasis></simpara>

    <simpara><literal>&lt;comparison predicate&gt; ::= &lt;row value
    predicand&gt; &lt;comparison predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;comparison predicate part 2&gt; ::= &lt;comp op&gt;
    &lt;row value predicand&gt;</literal></simpara>

    <simpara><literal>&lt;comp op&gt; ::= &lt;equals operator&gt; | &lt;not
    equals operator&gt; | &lt;less than operator&gt; | &lt;greater than
    operator&gt; | &lt;less than or equals operator&gt; | &lt;greater than or
    equals operator&gt;</literal></simpara>

    <simpara>Specify a comparison of two row values.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>between predicate</emphasis></simpara>

    <simpara><literal>&lt;between predicate&gt; ::= &lt;row value
    predicand&gt; &lt;between predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;between predicate part 2&gt; ::= [ NOT ] BETWEEN [
    ASYMMETRIC | SYMMETRIC ] &lt;row value predicand&gt; AND &lt;row value
    predicand&gt;</literal></simpara>

    <simpara>Specify a range comparison.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>in predicate</emphasis></simpara>

    <simpara><literal>&lt;in predicate&gt; ::= &lt;row value predicand&gt;
    &lt;in predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;in predicate part 2&gt; ::= [ NOT ] IN &lt;in
    predicate value&gt;</literal></simpara>

    <simpara><literal>&lt;in predicate value&gt; ::= &lt;table subquery&gt; |
    &lt;left paren&gt; &lt;in value list&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;in value list&gt; ::= &lt;row value expression&gt; [
    { &lt;comma&gt; &lt;row value expression&gt; }... ]</literal></simpara>

    <simpara>Specify a quantified comparison.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>character like predicate</primary>
    </indexterm>

    <simpara><emphasis role="bold">character like
    predicate</emphasis></simpara>

    <simpara><emphasis>like predicate</emphasis></simpara>

    <simpara><literal>&lt;like predicate&gt; ::= &lt;character like
    predicate&gt; | &lt;octet like predicate&gt;</literal></simpara>

    <simpara><literal>&lt;character like predicate&gt; ::= &lt;row value
    predicand&gt; &lt;character like predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;character like predicate part 2&gt; ::= [ NOT ] LIKE
    &lt;character pattern&gt; [ ESCAPE &lt;escape character&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;character pattern&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;escape character&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;octet like predicate&gt; ::= &lt;row value
    predicand&gt; &lt;octet like predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;octet like predicate part 2&gt; ::= [ NOT ] LIKE
    &lt;octet pattern&gt; [ ESCAPE &lt;escape octet&gt; ]</literal></simpara>

    <simpara><literal>&lt;octet pattern&gt; ::= &lt;binary value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;escape octet&gt; ::= &lt;binary value
    expression&gt;</literal></simpara>

    <simpara>Specify a pattern-match comparison.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>similar predicate</emphasis></simpara>

    <simpara><literal>&lt;similar predicate&gt; ::= &lt;row value
    predicand&gt; &lt;similar predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;similar predicate part 2&gt; ::= [ NOT ] SIMILAR TO
    &lt;similar pattern&gt; [ ESCAPE &lt;escape character&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;similar pattern&gt; ::= &lt;character value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;regular expression&gt; ::= &lt;regular term&gt; |
    &lt;regular expression&gt; &lt;vertical bar&gt; &lt;regular
    term&gt;</literal></simpara>

    <simpara><literal>&lt;regular term&gt; ::= &lt;regular factor&gt; |
    &lt;regular term&gt; &lt;regular factor&gt;</literal></simpara>

    <simpara><literal>&lt;regular factor&gt; ::= &lt;regular primary&gt; |
    &lt;regular primary&gt; &lt;asterisk&gt; | &lt;regular primary&gt;
    &lt;plus sign&gt; | &lt;regular primary&gt; &lt;question mark&gt; |
    &lt;regular primary&gt; &lt;repeat factor&gt;</literal></simpara>

    <simpara><literal>&lt;repeat factor&gt; ::= &lt;left brace&gt; &lt;low
    value&gt; [ &lt;upper limit&gt; ] &lt;right brace&gt;</literal></simpara>

    <simpara><literal>&lt;upper limit&gt; ::= &lt;comma&gt; [ &lt;high
    value&gt; ]</literal></simpara>

    <simpara><literal>&lt;low value&gt; ::= &lt;unsigned
    integer&gt;</literal></simpara>

    <simpara><literal>&lt;high value&gt; ::= &lt;unsigned
    integer&gt;</literal></simpara>

    <simpara><literal>&lt;regular primary&gt; ::= &lt;character specifier&gt;
    | &lt;percent&gt; | &lt;regular character set&gt; | &lt;left paren&gt;
    &lt;regular expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;character specifier&gt; ::= &lt;non-escaped
    character&gt; | &lt;escaped character&gt;</literal></simpara>

    <simpara><literal>&lt;non-escaped character&gt; ::= !! See the Syntax
    Rules.</literal></simpara>

    <simpara><literal>&lt;escaped character&gt; ::= !! See the Syntax
    Rules.</literal></simpara>

    <simpara><literal>&lt;regular character set&gt; ::= &lt;underscore&gt; |
    &lt;left bracket&gt; &lt;character enumeration&gt;... &lt;right
    bracket&gt; | &lt;left bracket&gt; &lt;circumflex&gt; &lt;character
    enumeration&gt;... &lt;right bracket&gt; | &lt;left bracket&gt;
    &lt;character enumeration include&gt;... &lt;circumflex&gt; &lt;character
    enumeration exclude&gt;... &lt;right bracket&gt;</literal></simpara>

    <simpara><literal>&lt;character enumeration include&gt; ::= &lt;character
    enumeration&gt;</literal></simpara>

    <simpara><literal>&lt;character enumeration exclude&gt; ::= &lt;character
    enumeration&gt;</literal></simpara>

    <simpara><literal>&lt;character enumeration&gt; ::= &lt;character
    specifier&gt; | &lt;character specifier&gt; &lt;minus sign&gt;
    &lt;character specifier&gt; | &lt;left bracket&gt; &lt;colon&gt;
    &lt;regular character set identifier&gt; &lt;colon&gt; &lt;right
    bracket&gt;</literal></simpara>

    <simpara><literal>&lt;regular character set identifier&gt; ::=
    &lt;identifier&gt;</literal></simpara>

    <simpara>Specify a character string similarity by means of a regular
    expression.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>regex like predicate</emphasis></simpara>

    <simpara><literal>&lt;regex like predicate&gt; ::= &lt;row value
    predicand&gt; &lt;regex like predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;regex like predicate part 2&gt; ::= [ NOT ]
    LIKE_REGEX &lt;XQuery pattern&gt; [ FLAG &lt;XQuery option flag&gt;
    ]</literal></simpara>

    <simpara>Specify a pattern-match comparison using an XQuery regular
    expression.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>null predicate</emphasis></simpara>

    <simpara><literal>&lt;null predicate&gt; ::= &lt;row value predicand&gt;
    &lt;null predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;null predicate part 2&gt; ::= IS [ NOT ]
    NULL</literal></simpara>

    <simpara>Specify a test for a null value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>quantified comparison predicate</emphasis></simpara>

    <simpara><literal>&lt;quantified comparison predicate&gt; ::= &lt;row
    value predicand&gt; &lt;quantified comparison predicate part
    2&gt;</literal></simpara>

    <simpara><literal>&lt;quantified comparison predicate part 2&gt; ::=
    &lt;comp op&gt; &lt;quantifier&gt; &lt;table
    subquery&gt;</literal></simpara>

    <simpara><literal>&lt;quantifier&gt; ::= &lt;all&gt; |
    &lt;some&gt;</literal></simpara>

    <simpara><literal>&lt;all&gt; ::= ALL</literal></simpara>

    <simpara><literal>&lt;some&gt; ::= SOME | ANY</literal></simpara>

    <simpara>Specify a quantified comparison.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>EXISTS</primary>
    </indexterm>

    <simpara><emphasis role="bold">EXISTS</emphasis></simpara>

    <simpara><emphasis>exists predicate</emphasis></simpara>

    <simpara><literal>&lt;exists predicate&gt; ::= EXISTS &lt;table
    subquery&gt;</literal></simpara>

    <simpara>Specify a test for a non-empty set.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>UNIQUE</primary>
    </indexterm>

    <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

    <simpara><emphasis>unique predicate</emphasis></simpara>

    <simpara><literal>&lt;unique predicate&gt; ::= UNIQUE &lt;table
    subquery&gt;</literal></simpara>

    <simpara>Specify a test for the absence of duplicate rows.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>normalized predicate</emphasis></simpara>

    <simpara><literal>&lt;normalized predicate&gt; ::= &lt;row value
    predicand&gt; &lt;normalized predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;normalized predicate part 2&gt; ::= IS [ NOT ] [
    &lt;normal form&gt; ] NORMALIZED</literal></simpara>

    <simpara>Determine whether a character string value is
    normalized.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>match predicate</emphasis></simpara>

    <simpara><literal>&lt;match predicate&gt; ::= &lt;row value predicand&gt;
    &lt;match predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;match predicate part 2&gt; ::= MATCH [ UNIQUE ] [
    SIMPLE | PARTIAL | FULL ] &lt;table subquery&gt;</literal></simpara>

    <simpara>Specify a test for matching rows.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>overlaps predicate part 1</primary>
    </indexterm>

    <simpara><emphasis role="bold">overlaps predicate part
    1</emphasis></simpara>

    <simpara><emphasis>overlaps predicate</emphasis></simpara>

    <simpara><literal>&lt;overlaps predicate&gt; ::= &lt;overlaps predicate
    part 1&gt; &lt;overlaps predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;overlaps predicate part 1&gt; ::= &lt;row value
    predicand 1&gt;</literal></simpara>

    <simpara><literal>&lt;overlaps predicate part 2&gt; ::= OVERLAPS &lt;row
    value predicand 2&gt;</literal></simpara>

    <simpara><literal>&lt;row value predicand 1&gt; ::= &lt;row value
    predicand&gt;</literal></simpara>

    <simpara><literal>&lt;row value predicand 2&gt; ::= &lt;row value
    predicand&gt;</literal></simpara>

    <simpara>Specify a test for an overlap between two datetime
    periods.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand 3</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand 3</emphasis></simpara>

    <simpara><emphasis>distinct predicate</emphasis></simpara>

    <simpara><literal>&lt;distinct predicate&gt; ::= &lt;row value predicand
    3&gt; &lt;distinct predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;distinct predicate part 2&gt; ::= IS [ NOT ]
    DISTINCT FROM &lt;row value predicand 4&gt;</literal></simpara>

    <simpara><literal>&lt;row value predicand 3&gt; ::= &lt;row value
    predicand&gt;</literal></simpara>

    <simpara><literal>&lt;row value predicand 4&gt; ::= &lt;row value
    predicand&gt;</literal></simpara>

    <simpara>Specify a test of whether two row values are distinct</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>member predicate</emphasis></simpara>

    <simpara><literal>&lt;member predicate&gt; ::= &lt;row value predicand&gt;
    &lt;member predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;member predicate part 2&gt; ::= [ NOT ] MEMBER [ OF
    ] &lt;multiset value expression&gt;</literal></simpara>

    <simpara>Specify a test of whether a value is a member of a
    multiset.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>submultiset predicate</emphasis></simpara>

    <simpara><literal>&lt;submultiset predicate&gt; ::= &lt;row value
    predicand&gt; &lt;submultiset predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;submultiset predicate part 2&gt; ::= [ NOT ]
    SUBMULTISET [ OF ] &lt;multiset value expression&gt;</literal></simpara>

    <simpara>Specify a test of whether a multiset is a submultiset of another
    multiset.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>set predicate</emphasis></simpara>

    <simpara><literal>&lt;set predicate&gt; ::= &lt;row value predicand&gt;
    &lt;set predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;set predicate part 2&gt; ::= IS [ NOT ] A
    SET</literal></simpara>

    <simpara>Specify a test of whether a multiset is a set (that is, does not
    contain any duplicates).</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>row value predicand</primary>
    </indexterm>

    <simpara><emphasis role="bold">row value predicand</emphasis></simpara>

    <simpara><emphasis>type predicate</emphasis></simpara>

    <simpara><literal>&lt;type predicate&gt; ::= &lt;row value predicand&gt;
    &lt;type predicate part 2&gt;</literal></simpara>

    <simpara><literal>&lt;type predicate part 2&gt; ::= IS [ NOT ] OF &lt;left
    paren&gt; &lt;type list&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;type list&gt; ::= &lt;user-defined type
    specification&gt; [ { &lt;comma&gt; &lt;user-defined type
    specification&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;user-defined type specification&gt; ::=
    &lt;inclusive user-defined type specification&gt; | &lt;exclusive
    user-defined type specification&gt;</literal></simpara>

    <simpara><literal>&lt;inclusive user-defined type specification&gt; ::=
    &lt;path-resolved user-defined type name&gt;</literal></simpara>

    <simpara><literal>&lt;exclusive user-defined type specification&gt; ::=
    ONLY &lt;path-resolved user-defined type name&gt;</literal></simpara>

    <simpara>Specify a type test.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>boolean value expression</primary>
    </indexterm>

    <simpara><emphasis role="bold">boolean value
    expression</emphasis></simpara>

    <simpara><emphasis>search condition</emphasis></simpara>

    <simpara><literal>&lt;search condition&gt; ::= &lt;boolean value
    expression&gt;</literal></simpara>

    <simpara>Specify a condition that is True, False, or Unknown, depending on
    the value of a boolean value expression.</simpara>

    <!-- From Foundation chapt. 10 -->

    <indexterm significance="preferred" type="sql">
      <primary>start field TO</primary>
    </indexterm>

    <simpara><emphasis role="bold">start field TO</emphasis></simpara>

    <simpara><emphasis>interval qualifier</emphasis></simpara>

    <simpara><literal>&lt;interval qualifier&gt; ::= &lt;start field&gt; TO
    &lt;end field&gt; | &lt;single datetime field&gt;</literal></simpara>

    <simpara><literal>&lt;start field&gt; ::= &lt;non-second primary datetime
    field&gt; [ &lt;left paren&gt; &lt;interval leading field precision&gt;
    &lt;right paren&gt; ]</literal></simpara>

    <simpara><literal>&lt;end field&gt; ::= &lt;non-second primary datetime
    field&gt; | SECOND [ &lt;left paren&gt; &lt;interval fractional seconds
    precision&gt; &lt;right paren&gt; ]</literal></simpara>

    <simpara><literal>&lt;single datetime field&gt; ::= &lt;non-second primary
    datetime field&gt; [ &lt;left paren&gt; &lt;interval leading field
    precision&gt; &lt;right paren&gt; ] | SECOND [ &lt;left paren&gt;
    &lt;interval leading field precision&gt; [ &lt;comma&gt; &lt;interval
    fractional seconds precision&gt; ] &lt;right paren&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;primary datetime field&gt; ::= &lt;non-second
    primary datetime field&gt; | SECOND</literal></simpara>

    <simpara><literal>&lt;non-second primary datetime field&gt; ::= YEAR |
    MONTH | DAY | HOUR | MINUTE</literal></simpara>

    <simpara><literal>&lt;interval fractional seconds precision&gt; ::=
    &lt;unsigned integer&gt;</literal></simpara>

    <simpara><literal>&lt;interval leading field precision&gt; ::=
    &lt;unsigned integer&gt;</literal></simpara>

    <simpara>Specify the precision of an interval data type.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>LANGUAGE</primary>
    </indexterm>

    <simpara><emphasis role="bold">LANGUAGE</emphasis></simpara>

    <simpara><emphasis>language clause</emphasis></simpara>

    <simpara><literal>&lt;language clause&gt; ::= LANGUAGE &lt;language
    name&gt;</literal></simpara>

    <simpara><literal>&lt;language name&gt; ::= ADA | C | COBOL | FORTRAN | M
    | MUMPS | PASCAL | PLI | SQL</literal></simpara>

    <simpara>Specify a programming language.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>PATH</primary>
    </indexterm>

    <simpara><emphasis role="bold">PATH</emphasis></simpara>

    <simpara><emphasis>path specification</emphasis></simpara>

    <simpara><literal>&lt;path specification&gt; ::= PATH &lt;schema name
    list&gt;</literal></simpara>

    <simpara><literal>&lt;schema name list&gt; ::= &lt;schema name&gt; [ {
    &lt;comma&gt; &lt;schema name&gt; }... ]</literal></simpara>

    <simpara>Specify an order for searching for an SQL-invoked
    routine.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>routine name</primary>
    </indexterm>

    <simpara><emphasis role="bold">routine name</emphasis></simpara>

    <simpara><emphasis>routine invocation</emphasis></simpara>

    <simpara><literal>&lt;routine invocation&gt; ::= &lt;routine name&gt;
    &lt;SQL argument list&gt;</literal></simpara>

    <simpara><literal>&lt;routine name&gt; ::= [ &lt;schema name&gt;
    &lt;period&gt; ] &lt;qualified identifier&gt;</literal></simpara>

    <simpara><literal>&lt;SQL argument list&gt; ::= &lt;left paren&gt; [
    &lt;SQL argument&gt; [ { &lt;comma&gt; &lt;SQL argument&gt; }... ] ]
    &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;SQL argument&gt; ::= &lt;value expression&gt; |
    &lt;generalized expression&gt; | &lt;target
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;generalized expression&gt; ::= &lt;value
    expression&gt; AS &lt;path-resolved user-defined type
    name&gt;</literal></simpara>

    <simpara>Invoke an SQL-invoked routine.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>standard character set name</primary>
    </indexterm>

    <simpara><emphasis role="bold">standard character set
    name</emphasis></simpara>

    <simpara><emphasis>character set specification</emphasis></simpara>

    <simpara><literal>&lt;character set specification&gt; ::= &lt;standard
    character set name&gt; | &lt;implementation-defined character set name&gt;
    | &lt;user-defined character set name&gt;</literal></simpara>

    <simpara><literal>&lt;standard character set name&gt; ::= &lt;character
    set name&gt;</literal></simpara>

    <simpara><literal>&lt;implementation-defined character set name&gt; ::=
    &lt;character set name&gt;</literal></simpara>

    <simpara><literal>&lt;user-defined character set name&gt; ::=
    &lt;character set name&gt;</literal></simpara>

    <simpara>Identify a character set.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>SPECIFIC</primary>
    </indexterm>

    <simpara><emphasis role="bold">SPECIFIC</emphasis></simpara>

    <simpara><emphasis>specific routine designator</emphasis></simpara>

    <simpara><literal>&lt;specific routine designator&gt; ::= SPECIFIC
    &lt;routine type&gt; &lt;specific name&gt; | &lt;routine type&gt;
    &lt;member name&gt; [ FOR &lt;schema-resolved user-defined type name&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;routine type&gt; ::= ROUTINE | FUNCTION | PROCEDURE
    | [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD</literal></simpara>

    <simpara><literal>&lt;member name&gt; ::= &lt;member name alternatives&gt;
    [ &lt;data type list&gt; ]</literal></simpara>

    <simpara><literal>&lt;member name alternatives&gt; ::= &lt;schema
    qualified routine name&gt; | &lt;method name&gt;</literal></simpara>

    <simpara><literal>&lt;data type list&gt; ::= &lt;left paren&gt; [ &lt;data
    type&gt; [ { &lt;comma&gt; &lt;data type&gt; }... ] ] &lt;right
    paren&gt;</literal></simpara>

    <simpara>Specify an SQL-invoked routine.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>COLLATE</primary>
    </indexterm>

    <simpara><emphasis role="bold">COLLATE</emphasis></simpara>

    <simpara><emphasis>collate clause</emphasis></simpara>

    <simpara><literal>&lt;collate clause&gt; ::= COLLATE &lt;collation
    name&gt;</literal></simpara>

    <simpara>Specify a default collation.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>CONSTRAINT</primary>
    </indexterm>

    <simpara><emphasis role="bold">CONSTRAINT</emphasis></simpara>

    <simpara><emphasis>constraint name definition</emphasis></simpara>

    <simpara><literal>&lt;constraint name definition&gt; ::= CONSTRAINT
    &lt;constraint name&gt;</literal></simpara>

    <simpara><literal>&lt;constraint characteristics&gt; ::= &lt;constraint
    check time&gt; [ [ NOT ] DEFERRABLE ] | [ NOT ] DEFERRABLE [
    &lt;constraint check time&gt; ]</literal></simpara>

    <simpara><literal>&lt;constraint check time&gt; ::= INITIALLY DEFERRED |
    INITIALLY IMMEDIATE</literal></simpara>

    <simpara>Specify the name of a constraint and its
    characteristics.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>COUNT</primary>
    </indexterm>

    <simpara><emphasis role="bold">COUNT</emphasis></simpara>

    <simpara><emphasis>aggregate function</emphasis></simpara>

    <simpara><literal>&lt;aggregate function&gt; ::= COUNT &lt;left paren&gt;
    &lt;asterisk&gt; &lt;right paren&gt; [ &lt;filter clause&gt; ] |
    &lt;general set function&gt; [ &lt;filter clause&gt; ] | &lt;binary set
    function&gt; [ &lt;filter clause&gt; ] | &lt;ordered set function&gt; [
    &lt;filter clause&gt; ] | &lt;array aggregate function&gt; [ &lt;filter
    clause&gt; ]</literal></simpara>

    <simpara><literal>&lt;general set function&gt; ::= &lt;set function
    type&gt; &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value
    expression&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;set function type&gt; ::= &lt;computational
    operation&gt;</literal></simpara>

    <simpara><literal>&lt;computational operation&gt; ::= AVG | MAX | MIN |
    SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP |
    VAR_POP | COLLECT | FUSION | INTERSECTION</literal></simpara>

    <simpara><literal>&lt;set quantifier&gt; ::= DISTINCT |
    ALL</literal></simpara>

    <simpara><literal>&lt;filter clause&gt; ::= FILTER &lt;left paren&gt;
    WHERE &lt;search condition&gt; &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;binary set function&gt; ::= &lt;binary set function
    type&gt; &lt;left paren&gt; &lt;dependent variable expression&gt;
    &lt;comma&gt; &lt;independent variable expression&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;binary set function type&gt; ::= COVAR_POP |
    COVAR_SAMP | CORR | REGR_SLOPE | REGR_INTERCEPT | REGR_COUNT | REGR_R2 |
    REGR_AVGX | REGR_AVGY | REGR_SXX | REGR_SYY | REGR_SXY</literal></simpara>

    <simpara><literal>&lt;dependent variable expression&gt; ::= &lt;numeric
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;independent variable expression&gt; ::= &lt;numeric
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;ordered set function&gt; ::= &lt;hypothetical set
    function&gt; | &lt;inverse distribution function&gt;</literal></simpara>

    <simpara><literal>&lt;hypothetical set function&gt; ::= &lt;rank function
    type&gt; &lt;left paren&gt; &lt;hypothetical set function value expression
    list&gt; &lt;right paren&gt; &lt;within group
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;within group specification&gt; ::= WITHIN GROUP
    &lt;left paren&gt; ORDER BY &lt;sort specification list&gt; &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;hypothetical set function value expression list&gt;
    ::= &lt;value expression&gt; [ { &lt;comma&gt; &lt;value expression&gt;
    }... ]</literal></simpara>

    <simpara><literal>&lt;inverse distribution function&gt; ::= &lt;inverse
    distribution function type&gt; &lt;left paren&gt; &lt;inverse distribution
    function argument&gt; &lt;right paren&gt; &lt;within group
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;inverse distribution function argument&gt; ::=
    &lt;numeric value expression&gt;</literal></simpara>

    <simpara><literal>&lt;inverse distribution function type&gt; ::=
    PERCENTILE_CONT | PERCENTILE_DISC</literal></simpara>

    <simpara><literal>&lt;array aggregate function&gt; ::= ARRAY_AGG &lt;left
    paren&gt; &lt;value expression&gt; [ ORDER BY &lt;sort specification
    list&gt; ] &lt;right paren&gt;</literal></simpara>

    <simpara>Specify a value computed from a collection of rows.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>sort specification {</primary>
    </indexterm>

    <simpara><emphasis role="bold">sort specification {</emphasis></simpara>

    <simpara><emphasis>sort specification list</emphasis></simpara>

    <simpara><literal>&lt;sort specification list&gt; ::= &lt;sort
    specification&gt; [ { &lt;comma&gt; &lt;sort specification&gt; }...
    ]</literal></simpara>

    <simpara><literal>&lt;sort specification&gt; ::= &lt;sort key&gt; [
    &lt;ordering specification&gt; ] [ &lt;null ordering&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;sort key&gt; ::= &lt;value
    expression&gt;</literal></simpara>

    <simpara><literal>&lt;ordering specification&gt; ::= ASC |
    DESC</literal></simpara>

    <simpara><literal>&lt;null ordering&gt; ::= NULLS FIRST | NULLS
    LAST</literal></simpara>

    <simpara>Specify a sort order.</simpara>
  </section>

  <section>
    <title>Data Access Statements</title>

    <para></para>
  </section>

  <section>
    <title>Data Change Statements</title>

    <indexterm significance="preferred" type="sql">
      <primary>DELETE FROM</primary>
    </indexterm>

    <simpara><emphasis role="bold">DELETE FROM</emphasis></simpara>

    <simpara><emphasis>delete statement: searched</emphasis></simpara>

    <simpara><literal>&lt;delete statement: searched&gt; ::= DELETE FROM
    &lt;target table&gt; [ [ AS ] &lt;correlation name&gt; ] [ WHERE
    &lt;search condition&gt; ]</literal></simpara>

    <simpara>Delete rows of a table. The search condition is a &lt;boolean
    value expression&gt; that is evaluated for each row of the table. If the
    condition is true, the row is deleted. If the condition is not specified,
    all the rows of the table are deleted.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>TRUNCATE TABLE</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRUNCATE TABLE</emphasis></simpara>

    <simpara><emphasis>truncate table statement</emphasis></simpara>

    <simpara><literal>&lt;truncate table statement&gt; ::= TRUNCATE TABLE
    &lt;target table&gt; [ &lt;identity column restart option&gt;
    ]</literal></simpara>

    <simpara><literal>&lt;identity column restart option&gt; ::= CONTINUE
    IDENTITY | RESTART IDENTITY</literal></simpara>

    <simpara>Delete all rows of a base table without causing any triggered
    action. This statement can only be used on base tables (not views). If the
    table is referenced in a FOREIGN KEY constraint, the statement causes an
    exception. The default for &lt;identity column restart option&gt; is
    CONTINUE IDENTITY. This means no change to the IDENTITY sequence of the
    table. If RESTART IDENTITY is specified, then the sequence is reset to its
    start value.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>INSERT INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">INSERT INTO</emphasis></simpara>

    <simpara><emphasis>insert statement</emphasis></simpara>

    <simpara><literal>&lt;insert statement&gt; ::= INSERT INTO &lt;insertion
    target&gt; &lt;insert columns and source&gt;</literal></simpara>

    <simpara><literal>&lt;insertion target&gt; ::= &lt;table
    name&gt;</literal></simpara>

    <simpara><literal>&lt;insert columns and source&gt; ::= &lt;from
    subquery&gt; | &lt;from constructor&gt; | &lt;from
    default&gt;</literal></simpara>

    <simpara><literal>&lt;from subquery&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;query expression&gt;</literal></simpara>

    <simpara><literal>&lt;from constructor&gt; ::= [ &lt;left paren&gt;
    &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override clause&gt;
    ] &lt;contextually typed table value constructor&gt;</literal></simpara>

    <simpara><literal>&lt;override clause&gt; ::= OVERRIDING USER VALUE |
    OVERRIDING SYSTEM VALUE</literal></simpara>

    <simpara><literal>&lt;from default&gt; ::= DEFAULT
    VALUES</literal></simpara>

    <simpara><literal>&lt;insert column list&gt; ::= &lt;column name
    list&gt;</literal></simpara>

    <simpara>Create new rows in a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>MERGE INTO</primary>
    </indexterm>

    <simpara><emphasis role="bold">MERGE INTO</emphasis></simpara>

    <simpara><emphasis>merge statement</emphasis></simpara>

    <simpara><literal>&lt;merge statement&gt; ::= MERGE INTO &lt;target
    table&gt; [ [ AS ] &lt;merge correlation name&gt; ] USING &lt;table
    reference&gt; ON &lt;search condition&gt; &lt;merge operation
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge correlation name&gt; ::= &lt;correlation
    name&gt;</literal></simpara>

    <simpara><literal>&lt;merge operation specification&gt; ::= &lt;merge when
    clause&gt;...</literal></simpara>

    <simpara><literal>&lt;merge when clause&gt; ::= &lt;merge when matched
    clause&gt; | &lt;merge when not matched clause&gt;</literal></simpara>

    <simpara><literal>&lt;merge when matched clause&gt; ::= WHEN MATCHED [ AND
    &lt;search condition&gt; ] THEN &lt;merge update
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge when not matched clause&gt; ::= WHEN NOT
    MATCHED [ AND &lt;search condition&gt; ] THEN &lt;merge insert
    specification&gt;</literal></simpara>

    <simpara><literal>&lt;merge update specification&gt; ::= UPDATE SET
    &lt;set clause list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert specification&gt; ::= INSERT [ &lt;left
    paren&gt; &lt;insert column list&gt; &lt;right paren&gt; ] [ &lt;override
    clause&gt; ] VALUES &lt;merge insert value list&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value list&gt; ::= &lt;left paren&gt;
    &lt;merge insert value element&gt; [ { &lt;comma&gt; &lt;merge insert
    value element&gt; }... ] &lt;right paren&gt;</literal></simpara>

    <simpara><literal>&lt;merge insert value element&gt; ::= &lt;value
    expression&gt; | &lt;contextually typed value
    specification&gt;</literal></simpara>

    <simpara>Conditionally update rows of a table, or insert new rows into a
    table, or both.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>UPDATE</primary>
    </indexterm>

    <simpara><emphasis role="bold">UPDATE</emphasis></simpara>

    <simpara><emphasis>update statement: searched</emphasis></simpara>

    <simpara><literal>&lt;update statement: searched&gt; ::= UPDATE &lt;target
    table&gt; [ [ AS ] &lt;correlation name&gt; ] SET &lt;set clause list&gt;
    [ WHERE &lt;search condition&gt; ]</literal></simpara>

    <simpara>Update rows of a table.</simpara>

    <indexterm significance="preferred" type="sql">
      <primary>set clause in UPDATE and MERGE statements</primary>
    </indexterm>

    <simpara><emphasis role="bold">set clause {</emphasis></simpara>

    <simpara><emphasis>set clause list</emphasis></simpara>

    <simpara><literal>&lt;set clause list&gt; ::= &lt;set clause&gt; [ {
    &lt;comma&gt; &lt;set clause&gt; }... ]</literal></simpara>

    <simpara><literal>&lt;set clause&gt; ::= &lt;multiple column
    assignment&gt; | &lt;set target&gt; &lt;equals operator&gt; &lt;update
    source&gt;</literal></simpara>

    <simpara><literal>&lt;multiple column assignment&gt; ::= &lt;set target
    list&gt; &lt;equals operator&gt; &lt;assigned row&gt;</literal></simpara>

    <simpara><literal>&lt;set target list&gt; ::= &lt;left paren&gt; &lt;set
    target&gt; [ { &lt;comma&gt; &lt;set target&gt; }... ] &lt;right
    paren&gt;</literal></simpara>

    <simpara><literal>&lt;assigned row&gt; ::= &lt;contextually typed row
    value expression&gt;</literal></simpara>

    <simpara><literal>&lt;set target&gt; ::= &lt;column
    name&gt;</literal></simpara>

    <simpara><literal>&lt;update source&gt; ::= &lt;value expression&gt; |
    &lt;contextually typed value specification&gt;</literal></simpara>

    <simpara>Specify a list of updates.</simpara>
  </section>
</chapter>
