<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % dummy22 SYSTEM "../entities/global.ent">
%dummy22;
]>
<chapter version="5.0" xml:id="deployment-chapt"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="deployment-title">Deployment Guide</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <pubdate>&timestamp;</pubdate>

    <keywordset>
      <keyword>HSQLDB</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2002-2020 Fred Toussi. Permission is granted to
      distribute this document without any alteration under the terms of the
      HSQLDB license. Additional permission is granted to the HSQL Development
      Group to distribute this document with or without alterations under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section xml:id="dec_mem_disk_use">
    <title>Memory and Disk Use</title>

    <indexterm significance="preferred">
      <primary>memory use</primary>
    </indexterm>

    <para>Memory used by the program can be thought of as two distinct pools:
    memory used for table data which is not released unless the data is
    deleted and memory that can be released or is released automatically,
    including memory used for caching, building result sets and other internal
    operations such as storing the information needed for a rollback a
    transaction.</para>

    <para>Most JVM implementations allocate up to a maximum amount of memory
    (usually 64 MB by default). This amount is generally not adequate when
    large memory tables are used, or when the average size of rows in cached
    tables is larger than a few hundred bytes. The maximum amount of allocated
    memory can be set on the Java command line that is used for running
    HyperSQL. For example, the JVM parameter <literal>-Xmx256m</literal>
    increases the amount to 256 MB.</para>

    <section xml:id="dec_table_mem_use">
      <title>Table Memory Allocation</title>

      <para>The memory used for a MEMORY table is the sum of memory used by
      each row. Each MEMORY table row is a Java object that has 2 int or
      reference variables. It contains an array of objects for the fields in
      the row. Each field is an object such as <classname>Integer</classname>,
      <classname>Long</classname>, <classname>String</classname>, etc. In
      addition, each index on the table adds a node object to the row. Each
      node object has 6 int or reference variables. As a result, a table with
      just one column of type INTEGER will have four objects per row, with a
      total of 10 variables of 4 bytes each - currently taking up 80 bytes per
      row. Beyond this, each extra column in the table adds at least a few
      bytes to the size of each row.</para>
    </section>

    <section xml:id="dec_result_mem_use">
      <title>Result Set Memory Allocation</title>

      <para>By default, all the rows in the result set are built in memory, so
      very large result sets may not be possible to build. A server-mode
      databases releases the result set from the server memory once the
      database server has returned the result set. An
      <glossterm>in-process</glossterm> database releases the memory when the
      application program closes the <classname>java.sql.ResultSet</classname>
      object. A server mode database requires additional memory for returning
      result sets, as it converts the full result set into an array of bytes
      which is then transmitted to the client.</para>

      <para>HyperSQL 2 supports disk-based result sets. The commands,
      <literal>SET SESSION RESULT MEMORY ROWS &lt;integer&gt;</literal> and
      <literal>SET DATABASE DEFAULT RESULT MEMORY ROWS
      &lt;integer&gt;</literal> specify a threshold for the number of rows.
      Results with row counts above the threshold are stored on disk. These
      settings also apply to temporary tables, views and subquery
      tables.</para>

      <para>Disk-based result sets slow down the database operations and
      should be used only when absolutely necessary, perhaps with result sets
      that are larger than tens of thousands of rows.</para>

      <para>In a server mode database, when the setFetchSize() method of the
      Statement interface is used to limit the number of rows fetched, the
      whole result is held by the engine and is returned to the JDBC ResultSet
      in blocks of rows of the specified fetch size.</para>
    </section>

    <section xml:id="dec_temp_mem_use">
      <title>Temporary Memory Use During Operations</title>

      <para>When UPDATE and DELETE queries are performed on CACHED tables, the
      full set of rows that are affected, including those affected due to ON
      UPDATE actions, is held in memory for the duration of the operation.
      This means it may not be possible to perform deletes or updates
      involving very large numbers of rows of CACHED tables. Such operations
      should be performed in smaller sets. This memory is released as soon as
      the DELETE or UPDATE is performed.</para>

      <para>When transactions support is enabled with SET AUTOCOMMIT FALSE,
      lists of all insert, delete or update operations are stored in memory so
      that they can be undone when ROLLBACK is issued. For CACHED tables, only
      the transaction information is held in memory, not the actual rows that
      have changed. Transactions that span thousands of modifications to data
      will take up a lot of memory until the next COMMIT or ROLLBACK clears
      the list. Each row modification uses less than 100 bytes until
      COMMIT.</para>

      <para>When subqueries or views are used in SELECT and other statements,
      transient tables are created and populated by the engine. If the
      <literal>SET SESSION RESULT MEMORY ROWS &lt;integer&gt;</literal>
      statement has been used, these transient tables are stored on disk when
      they are larger than the threshold.</para>
    </section>

    <section xml:id="dec_cache_mem_use">
      <title>Data Cache Memory Allocation</title>

      <para>With CACHED tables, the data is stored on disk and only up to a
      maximum number of rows are held in memory at any time. The default is up
      to 50,000 rows. The SET FILES CACHE ROWS command or the
      <property>hsqldb.cache_rows</property> connection property can be set to
      alter this amount. As any random subset of the rows in any of the CACHED
      tables can be held in the cache, the amount of memory needed by cached
      rows can reach the sum of the rows containing the largest field data.
      For example if a table with 100,000 rows contains 40,000 rows with 1,000
      bytes of data in each row and 60,000 rows with 100 bytes in each, the
      cache can grow to contain 50,000 of the smaller rows, but as explained
      below, only 10,000 or the large rows.</para>

      <para>An additional property, <property>hsqldb.cache_size</property> is
      used in conjunction with the <property>hsqldb.cache_rows</property>
      property. This puts a limit in bytes on the total size of rows that are
      cached. The default value is 10,000KB. This is the size of binary images
      of the rows and indexes. It translates to more actual memory, typically
      2-4 times, used for the cache because the data is represented by Java
      objects.</para>

      <para>If memory is limited, the <property>hsqldb.cache_rows</property>
      or <property>hsqldb.cache_size</property> database properties can be
      reduced. In the example above, if the
      <property>hsqldb.cache_size</property> is reduced from 10,000 to 5,000,
      it may allow the number of cached rows to reach 50,000 small rows, but
      only 5,000 of the larger rows.</para>

      <para>Data for CLOB and BLOB columns is not cached and does not affect
      the CACHED table memory cache.</para>

      <para>The operating system usually allocates a large amount of buffer
      memory for speed up file read operations. Therefore, when a lot of
      memory is available to the operating system, all database operations
      perform faster.</para>
    </section>

    <section xml:id="dec_pool_mem_use">
      <title>Object Pool Memory Allocation</title>

      <para>HyperSQL uses a set of fast pools for immutable objects such as
      Integer, Long and short String objects that are stored in the database.
      In most circumstances, this reduces the memory footprint still further
      as fewer copies of the most frequently used objects are kept in memory.
      The object pools are shared among all databases in the JVM. The size of
      each pool can be modified only by altering and recompiling the
      <literal>org.hsqldb.store.ValuePool</literal> class.</para>
    </section>

    <section xml:id="dec_lob_mem_use">
      <title>Lob Memory Usage</title>

      <para>Access to lobs is always performed in chunks internally, so it is
      perfectly possible to store and access a CLOB or BLOB that is larger
      than the JVM memory allocation. The actual total size of lobs is almost
      unlimited. We have tested with over 100 GB of lobs without any loss of
      performance.</para>

      <para>By default, HyperSQL 2 uses memory-based tables for the lob schema
      (not the actual lob data). Therefore, it is practical to store about
      100,000 individual lobs in the database with the default JVM memory
      allocation. More lobs can be stored with larger JVM memory allocations.
      In order to store more than a few hundreds of thousands of lobs, you can
      change the lob schema storage to CACHED tables with the following
      statements:</para>

      <example>
        <title>Using CACHED tables for the LOB schema</title>

        <screen> SET TABLE SYSTEM_LOBS.BLOCKS TYPE CACHED
 SET TABLE SYSTEM_LOBS.LOBS TYPE CACHED
 SET TABLE SYSTEM_LOBS.LOB_IDS TYPE CACHED
</screen>
      </example>
    </section>

    <section xml:id="dec_nio_access">
      <title>Using NIO File Access</title>

      <para>This method of file access uses the operating system's
      memory-mapped file buffer for the <literal>.data</literal> file. For
      larger databases with CACHED tables, use of nio improves database access
      speed significantly. Performance improvements can be tenfold or even
      higher. By default, NIO is used for <literal>.data</literal> files from
      16 MB up to 256 MB. You can increase the limit with the <literal>SET
      FILES NIO SIZE &lt;value&gt;</literal> statement. There should be enough
      RAM available to accommodate the memory mapped buffers. For vary large
      nio usage, a 64 bit JVM must be used. The memory is not taken from the
      JVM memory allocation, therefore there is no need to increase the -Xmx
      parameter of the JVM. If not enough memory is available for the
      specified value, nio is not used.</para>
    </section>

    <section xml:id="dec_disk_space">
      <title>Disk Space Use</title>

      <para>With <glossterm>file:</glossterm> database, the engine uses the
      disk for storage of data and any change. This includes: the
      <literal>.script</literal> file which is always present, the
      <literal>.log</literal> file which grows in size and is reset at regular
      intervals, the <literal>.data</literal> file when CACHED tables are
      used, and the <literal>.lobs</literal> file when CLOB or BLOB data is
      used. The <literal>.backup</literal> file is used for safely by the
      engine to store parts of the <literal>.data</literal> file that are
      modified internally during operation. Both the <literal>.log</literal>
      and <literal>.backup</literal> files are reset at each CHECKPOINT and a
      new copy of the <literal>.script</literal> file is written. Spare space,
      at larger than the total size of the <literal>.data</literal> and
      <literal>.script</literal> files, plus the maximum allowed size of the
      <literal>.log</literal> file, is needed. The <literal>.lobs</literal>
      file is not copied during database updates as it is not necessary for
      safety.</para>

      <para>When the RESULT MEMORY ROWS setting is used to limit the memory
      rows in result sets and temporary tables, each session uses additional
      disk space for large results and temporary tables. These results are
      stored in files in the temp directory alongside the database files,
      which are deleted at database shutdown.</para>
    </section>

    <section xml:id="dec_no_logging">
      <title>Using HyperSQL Without Logging Data Change</title>

      <para>All <glossterm>file:</glossterm> database that are not read-only,
      write changes to the <literal>.log</literal> file. There are scenarios
      where writing to the <literal>.log</literal> file can be turned off to
      improve performance, especially with larger databases used for temporary
      data. For these applications you can set the property
      <literal>hsqldb.log_data=false</literal> to disable the recovery log and
      speed up data change performance. The equivalent SQL command is SET
      FILES LOG FALSE.</para>

      <para>With this setting, no data is logged, but all the changes to
      cached tables are written to the <literal>.data</literal> file. To
      persist all the data changes up to date, you can use the CHECKPOINT
      command. If you perform SHUTDOWN, the data is also persisted correctly.
      If you do not use CHECKPOINT or SHUTDOWN when you terminate the
      application, all the changes are lost and the database reverts to its
      original state when it is opened without losing any of the original
      data.</para>

      <para>Your server applications can use a database as a temporary disk
      data cache which is not persisted past the lifetime of the application.
      For this usage, delete the database files when the application
      ends.</para>

      <para>On some platforms, such as embedded devices with SSD storage, this
      is also a useful option. Your application should issue CHECKPOINT to
      save the changes made so far. This method of use reduces write
      operations on SSD devices. For this usage, the lock file can also be
      disabled with the connection property
      <literal>hsqldb.lock_file=false</literal>.</para>
    </section>

    <section xml:id="dec_bulk_operations">
      <title>Bulk Inserts, Updates and Deletes</title>

      <para>Bulk inserts, deletes and updates are performed with the best
      performance with the following method. The database remains safe and
      consistent using this method. In the event of a machine crash during the
      operation, the database can be recovered to the point just before the
      bulk operation.</para>

      <orderedlist>
        <listitem>
          <para>Before the operation, execute the SET FILES LOG FALSE
          statement.</para>
        </listitem>

        <listitem>
          <para>Execute the CHECKPOINT statement.</para>
        </listitem>

        <listitem>
          <para>Perform all the bulk operations, using batched prepared
          statements. A batch size of 1000 to 10000 is adequate. Perform
          commit after each batch.</para>
        </listitem>

        <listitem>
          <para>After all the bulk operations are complete, execute the SET
          FILES LOG TRUE statement.</para>
        </listitem>

        <listitem>
          <para>Finally execute the CHECKPOINT statement.</para>
        </listitem>

        <listitem>
          <para>If you have performed many thousands of updates or deletes
          (not just inserts), it is a good idea to execute CHECKPOINT DEFRAG,
          instead of CHECKPOINT at the end.</para>
        </listitem>

        <listitem>
          <para>If things go wrong during the bulk operation, for example when
          a unique constraint violation aborts the operation, and you want to
          redo the whole operation, just use SHUTDOWN IMMEDIATELY instead of
          CHECKPOINT. When you restart the database it will revert to the
          state at the first CHECKPOINT and the bulk operation can be
          redone.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="dec_managing_connections">
    <title>Managing Database Connections</title>

    <para>In all running modes (server or <glossterm>in-process</glossterm>)
    multiple connections to the database engine are supported.
    <glossterm>in-process</glossterm> (standalone) mode supports connections
    from the client in the same Java Virtual Machine, while server modes
    support connections over the network from several different
    clients.</para>

    <para>Connection pooling software can be used to connect to the database
    but it is not generally necessary. Connection pools may be used for the
    following reasons.</para>

    <itemizedlist>
      <listitem>
        <para>To allow new queries to be performed while a time-consuming
        query is being performed in the background. In HyperSQL, blocking
        depends on the transaction control model, the isolation level, and the
        current activity by other sessions.</para>
      </listitem>

      <listitem>
        <para>To limit the maximum number of simultaneous connections to the
        database for performance reasons. With HSQLDB this can be useful if
        your application is designed in a way that opens and closes
        connections for each small task. Also, the overall performance may be
        higher when fewer simultaneous connections are used. If you want to
        reduce the number of simultaneous sessions, you can use a connection
        pool with fewer pooled connections.</para>
      </listitem>
    </itemizedlist>

    <para>An application that is not both multi-threaded and transactional,
    such as an application for recording user login and logout actions, does
    not need more than one connection. The connection can stay open
    indefinitely and reopened only when it is dropped due to network
    problems.</para>

    <para>When using an <glossterm>in-process</glossterm> database, when the
    last connection to the database is closed, the database still remains
    open, waiting for the next connection to be made. From version 2.2.9, each
    time the last connection is closed all the data changes are logged and
    synched to disk.</para>

    <para>An explicit SHUTDOWN command, with or without an argument, is
    required to close the database. A connection property, shutdown=true, can
    be used on the connection URL or in a properties object to shutdown the
    database when the last connection is closed.</para>

    <para>When using a server database (and to some extent, an
    <glossterm>in-process</glossterm> database), care must be taken to avoid
    creating and dropping JDBC Connections too frequently. Failure to observe
    this will result in poor performance when the application is under heavy
    load.</para>

    <para>A common error made by users in load-test simulations is to use a
    single client machine to open and close thousands of connections to a
    HyperSQL server instance. The connection attempts will fail after a few
    thousand because of OS restrictions on opening sockets and the delay that
    is built into the OS in closing them.</para>
  </section>

  <section xml:id="dec_app_dev_testing">
    <title>Application Development and Testing</title>

    <para>First thing to be aware of is the SQL conformance settings of
    HyperSQL. By default, HyperSQL version 2 applies stricter conformance
    rules than version 1.8 and catches long strings or decimal values that do
    not fit within the specified length or precision settings. However, there
    are several conformance settings that are turned off by default. This is
    to enable easier migration from earlier versions, and also greater
    compatibility with databases such as MySQL that are sometimes very liberal
    with type conversions. The conformance settings are listed in the System
    Management chapter and their connection property equivalents are listed in
    the Database Properties chapter. Ideally, all the settings that are not
    for syntax compatibility with other databases should have a true value for
    best error checking. You can turn on the settings for syntax compatibility
    with another database if you are porting or testing applications targeted
    at the other database.</para>

    <para>For application unit testing you can use an all-in-memory,
    in-process database.</para>

    <para>If the tests are all run in one process, then the contents of a
    <glossterm>mem:</glossterm> database survives between tests. To release
    the contents, you can use the SHUTDOWN command (an SQL command). You can
    even use multiple <glossterm>mem:</glossterm> databases in your tests and
    SHUTDOWN each one separately.</para>

    <para>If the tests are in different processes and you want to keep the
    data between the tests, the best solution is to use a Server instance that
    has a <glossterm>mem:</glossterm> database. After the tests are done, you
    can SHUTDOWN this database, which will shutdown the server.</para>

    <para>The Server has an option that allows databases to be created as
    needed by making a connection (see the Listeners Chapter). This option is
    useful for testing, as your server is never shut down when a database is
    shutdown. Each time you connect to the <glossterm>mem:</glossterm>
    database that is served by the Server, the database is created if it does
    not exist (i.e. has been previously shut down).</para>

    <para>If you do not want to run a Server instance, and you need
    persistence between tests in different processes, then you should use a
    <glossterm>file:</glossterm> database. From version 2.2.9 when the last
    existing connection to the database is closed, the latest changes to the
    database are persisted fully with fsync. The database is still in an open
    state until it is shut down. You can use the
    <literal>shutdown=true</literal> connection property to close the database
    automatically after the connections are closed. The automatic sync and
    shutdown are mainly for test environment. In production environments you
    should execute the SHUTDOWN statement before your application is closed.
    This ensures a quick start next time you connect to the database.</para>

    <para>An alternative option is to use
    <literal>hsqldb.write_delay=false</literal> connection property, but this
    is slightly slower than the other option and should be used in situations
    where the test application does not close the connections. This option
    uses fsync after each commit. Even if the test process is aborted without
    shutting down the connections, all committed data is saved. It has been
    reported that some data access frameworks do not close all their
    connection to the database after the tests. In such situations, you need
    to use this option if you want the data to persist at the end of the
    tests</para>

    <para>You may actually want to use a <glossterm>file:</glossterm>
    database, or a server instance that serves a <glossterm>file:</glossterm>
    database in preference to a <glossterm>mem:</glossterm> database. As
    HyperSQL logs the DDL and DML statements in the <literal>.log</literal>
    file, this file can be used to check what is being sent to the database.
    Note that UPDATE statements are represented by a DELETE followed by an
    INSERT statement. Statements are written out when the connection commits.
    The write delay also has an effect on how soon the statements are written
    out. By default, the write delay is 0.5 second.</para>

    <para>The SQL logging feature in version 2.2 and later records all
    executed statements and can be used for debugging your application.</para>

    <para>Some types of tests start with a database that already contains the
    tables and data, and perform various operations on it during the tests.
    You can create and populate the initial database then set the property
    "<literal>files_readonly=true</literal>" in the
    <literal>.properties</literal> file of the database. The tests can then
    modify the database, but these modifications are not persisted after the
    tests have completed.</para>

    <para>Databases with "<literal>files_readonly=true</literal>" can be
    placed within the classpath and in a jar file. In this case, the
    connection URL must use the <glossterm>res:</glossterm> protocol, which
    treats the database as a resource.</para>
  </section>

  <section xml:id="dec_tweaking">
    <title>Tweaking the Mode of Operation</title>

    <para>Different modes of operation and settings are used for different
    purposes. Some scenarios are discussed below:</para>

    <section xml:id="dec_embedded_desktop_db">
      <title>Embedded Databases in Desktop Applications</title>

      <para>In this usage, the amount of data change is often limited and
      there is often a requirement to persist the data immediately. The
      default write delay of 0.5 second is fine for many applications. You can
      also use the property <literal>hsqldb.write_delay_millis=100</literal>
      to reduce it to 0.1 second, or the property
      <literal>hsqldb.write_delay=false</literal> to force a disk fsync after
      each commit. Before the application is closed, you should perform the
      SHUTDOWN command to ensure the database is opened instantly when it is
      next opened. Note you don't need to use SHUTDOWN COMPACT as
      routine.</para>
    </section>

    <section xml:id="dec_embedded_server_db">
      <title>Embedded Databases in Server Applications</title>

      <para>This usage involves a server application, such as a web
      application, connecting to an embedded HyperSQL instance. In this usage,
      the database is often accessed heavily, therefore performance and
      latency is a consideration. If the database is updated heavily, the
      default value of the WRITE DELAY property (0.5 sec) is often enough, as
      it is assumed the server or the application does not go down frequently.
      If it is necessary, you can reduce the WRITE DELAY to a small value (20
      ms) without impacting the update speed. If you reduce WRITE DELAY to
      zero, performance drops to the speed of disk file sync operation.</para>

      <para>Alternatively, a server application can use an all-in-memory
      database instance for fast access, while sending the data changes to a
      persistent, disk based instance either periodically or in real
      time.</para>
    </section>

    <section xml:id="dec_mixed_mode_server">
      <title>Mixed Mode : Embedding a HyperSQL Server (Listener)</title>

      <para>Since you won't be able to access
      <glossterm>in-process</glossterm> database instances from other
      processes, you will often want to run a Listener in your applications
      that use embedded databases. You can do this by starting up a Server or
      WebServer instance programatically, but you could also use the class
      <classname>org.hsqldb.util.MainInvoker</classname> to start up your
      application and a HyperSQL Server or WebServer without any programming.
      MainInvoker is a general-purpose utility class to invoke the main
      methods of multiple classes. Each main class is followed by its
      arguments (if any), then an empty string to separate it from the next
      main class.<example>
          <title>MainInvoker Example</title>

          <screen>  java -cp path/to/your/app.jar:path/to/hsqldb.jar org.hsqldb.util.MainInvoker com.your.main.App "" org.hsqldb.server.Server</screen>
        </example> (Use ; instead of : to delimit classpath elements on
      Windows). The empty string separates your com.your.main.App invocation
      from the org.hsqldb.server.</para>

      <para>Specify the same <glossterm>in-process</glossterm> JDBC URL to
      your app and in the <filename>server.properties</filename> file. You can
      then connect to the database from outside using a JDBC URL like
      <literal>jdbc:hsqldb:hsql://hostname</literal>, while connecting from
      inside the application using something like
      <literal>jdbc:hsqldb:file:&lt;filepath of database&gt;</literal>
      .</para>

      <simpara>This tactic can be used to run off-the-shelf server
      applications with an embedded HyperSQL Server, without doing any
      coding.</simpara>

      <simpara><classname>MainInvoker</classname> can be used to run any
      number of Java class main method invocations in a single JVM. See the
      API spec for <classname xlink:href="#MainInvoker.html-link">
      MainInvoker</classname> for details on its usage.</simpara>
    </section>

    <section xml:id="dec_server_db">
      <title>Server Databases</title>

      <para>Running databases in a HyperSQL server is the best overall method
      of access. As the JVM process is separate from the application, this
      method is the most reliable as well as the most accessible method of
      running databases.</para>
    </section>
  </section>

  <section xml:id="dec_upgrade_database">
    <title>Upgrading Databases</title>

    <indexterm significance="preferred">
      <primary>upgrading</primary>
    </indexterm>

    <para>HSQLDB version 2.5.1 and later can open databases created with
    version 2.0 and above. It will not open databases created with older
    versions. It is a good idea to perform SHUTDOWN COMPACT after the
    upgrade.</para>

    <para>Downgrading is also possible. Once a database is upgraded to 2.5.1,
    you need to perform SHUTDOWN SCRIPT before you open it with previous 2.x.x
    versions of HyperSQL.</para>

    <para>To upgrade an old database created with version 1.8.x, you can use
    HSQLDB version 2.3.x to 2.5.0 to open the database and perform SHUTDOWN
    SCRIPT. You can then open the database with version 2.5.1 or later.</para>

    <para>If the 1.8.x database script format is set to BINARY or COMPRESSED
    (ZIPPED), you must open the database with version 1.8.x and issue the SET
    SCRIPTFORMAT TEXT and SHUTDOWN SCRIPT commands with the old version, prior
    to version upgrade.</para>

    <para>It is strongly recommended to execute SHUTDOWN SCRIPT after an
    automatic upgrade from previous versions.</para>

    <para>A note about SHUTDOWN modes. SHUTDOWN COMPACT is equivalent to
    SHUTDOWN SCRIPT plus opening the database and then performing a simple
    SHUTDOWN.</para>

    <para>After upgrading a database, there will be some changes to its
    settings. For example, the new SET FILES BACKUP INCREMENT TRUE is applied
    to improve the shutdown and checkpoint times of larger databases.</para>

    <para>If your database has been created with version 1.7.2 or 1.7.3, first
    upgrade to version 1.8.1 and perform a SHUTDOWN SCRIPT with this version.
    You can then upgrade the database to version 2.x.</para>

    <para>To upgrade from older version database files (1.7.1 and older) that
    contain CACHED tables, use the SCRIPT procedure below. In all versions of
    HyperSQL, the <literal>SCRIPT 'filename'</literal> command (used as an SQL
    statement) allows you to save a full record of your database, including
    database object definitions and data, to a file of your choice. You can
    then use the PERFORM IMPORT ... statement to load the file.</para>

    <section xml:id="dec_script_manual_change">
      <title>Manual Changes to the *.script File</title>

      <para>The <literal>*.script</literal> file contains SQL statements for
      the database settings and creation of objects such as tables, sequences
      and user-defined function. It also contains INSERT statements to
      populate MEMORY tables. A new copy of the <literal>*.script</literal>
      file is created by the database engine at each checkpoint or shutdown.
      This file is read when the database is opened. Only some types of SQL
      statements are used in this file; for example no UPDATE or DELETE
      statements are used, and the statements in the file follow a certain
      sequence. Therefore, the <literal>*.script</literal> file cannot be
      edited freely by the user and any edits must respect the acceptable
      format.</para>

      <para>In HyperSQL the full range of ALTER TABLE commands is available to
      change the data structures and their names. However, if an old database
      cannot be opened due to data inconsistencies, or it uses index or column
      names that are not compatible with 2.0, manual editing of the
      <literal>*.script</literal> file can be performed and can be
      faster.</para>

      <itemizedlist>
        <listitem>
          <para>Version 2.x does not accept duplicate names for indexes that
          were allowed before 1.7.2.</para>
        </listitem>

        <listitem>
          <para>Version 2.x does not accept some table or column names that
          are SQL reserved keywords without double quoting.</para>
        </listitem>

        <listitem>
          <para>Version 2.x does not accept unquoted table or column names
          which begin with an underscore, unless the connection
          <literal>sql.regular_names</literal> is set false.</para>
        </listitem>

        <listitem>
          <para>Version 2.x is more strict with check conditions and default
          values.</para>
        </listitem>
      </itemizedlist>

      <para>Other manual changes are also possible. Note that the
      <literal>*.script</literal> file must be the result of a SHUTDOWN SCRIPT
      and must contain the full data for the database. The following changes
      can be applied so long as they do not affect the integrity of existing
      data.</para>

      <itemizedlist>
        <listitem>
          <para>Names</para>

          <para>Names of tables, columns and indexes can be changed. These
          changes must be consistent regarding foreign key constraint
          references.</para>
        </listitem>

        <listitem>
          <para><literal>CHECK</literal></para>

          <para>A check constraint can always be removed.</para>
        </listitem>

        <listitem>
          <para><literal>NOT NULL</literal></para>

          <para>A not-null constraint can always be removed.</para>
        </listitem>

        <listitem>
          <para><literal>PRIMARY KEY</literal></para>

          <para>A primary key constraint can be removed. It cannot be removed
          if there is a foreign key referencing the column(s).</para>
        </listitem>

        <listitem>
          <para><literal>UNIQUE</literal></para>

          <para>A UNIQUE constraint can be removed if there is no foreign key
          referencing the column(s).</para>
        </listitem>

        <listitem>
          <para><literal>FOREIGN KEY</literal></para>

          <para>A FOREIGN KEY constraint can always be removed.</para>
        </listitem>

        <listitem>
          <para><literal>COLUMN TYPES</literal></para>

          <para>Some changes to column types are possible. For example an
          INTEGER column can be changed to BIGINT.</para>
        </listitem>

        <listitem>
          <para><literal>INSERT Statements</literal></para>

          <para>INSERT statements may be added to the file in the same format
          as written by the engine.</para>
        </listitem>

        <listitem>
          <para><literal>Character Escapes</literal></para>

          <para>All non-ASCII characters are escaped as Java Unicode escape
          sequences.</para>
        </listitem>
      </itemizedlist>

      <para>After completing the changes and saving the modified
      <literal>.script</literal> file, you can open the database as
      normal.</para>
    </section>
  </section>

  <section xml:id="dec_backware_compatibility">
    <title>Backward Compatibility Issues</title>

    <para>HyperSQL 2 conforms to the SQL Standard better than previous
    versions and has many more features. For these reasons, there may be some
    compatibility issues when converting old database, or using applications
    that were written for version 1.8.x or earlier. Some of the potential
    issues (and enhancements) are listed here. See the full list of connection
    properties for alternatives.</para>

    <itemizedlist>
      <listitem>
        <para>By default, when comparison strings, the shorter string is
        padded with spaces. This has an effect on comparing
        <literal>'test'</literal> and <literal>'test '</literal> which are now
        considered equal, despite the length difference. This behaviour is
        controlled by the default PAD SPACE property of collations, which can
        be changed to NO PAD. See the statement <literal>SET DATABASE
        COLLATION &lt;name&gt; [ PAD SPACE | NO PAD ]</literal>.</para>
      </listitem>

      <listitem>
        <para>User names and passwords are case-sensitive. Check the
        <literal>.script</literal> file of a database for the correct case of
        user name and password and use this form in the connection properties
        or on connection URL.</para>
      </listitem>

      <listitem>
        <para>It is now possible to specify the admin username and password
        for a new database (instead of SA and the empty password).</para>
      </listitem>

      <listitem>
        <para>HyperSQL 2.x has several settings that relax its conformance to
        the SQL Standard in the areas of type conversion and object names.
        These settings can be turned on for maximum conformance.</para>
      </listitem>

      <listitem>
        <para>Check constraints must conform to the SQL Standard. A check
        constraint is rejected if it is not deterministic or retrospectively
        deterministic. When opening an old database, HyperSQL silently drops
        check constraints that no longer compile. See under check constraints
        for more detail about what is not allowed.</para>
      </listitem>

      <listitem>
        <para>Type declarations in column definition and in cast expressions
        must have the necessary size parameters.</para>
      </listitem>

      <listitem>
        <para>In connection with the above, an old database that did not have
        the <literal>enforce_strict_size</literal> property, is now converted
        to version 2.x with the engine supplying the missing size parameters.
        For example, a VARCHAR column declaration that has no size, is given a
        32K size, a LONGVARCHAR column is given a 16MB size. Check these sizes
        are adequate for your use, and change the column definition as
        necessary.</para>
      </listitem>

      <listitem>
        <para>Column names in a GROUP BY clause were previously resolved to
        the column label. They are now resolved to column name first, and if
        the name does not match, to the column label.</para>
      </listitem>

      <listitem>
        <para>If two or more tables in a join contain columns with the same
        name, the columns cannot be referenced in join and where conditions.
        Use table names before column names to qualify the references to such
        columns. The <literal>SET DATABASE SQL REFERENCES { TRUE | FALSE
        }</literal> statement enables or disables this check.</para>
      </listitem>

      <listitem>
        <para>If the unqualified wild card is used, as in the statement SELECT
        * FROM ... no additional column references are allowed. A
        table-qualified wild card allows additional column references in the
        SELECT list</para>
      </listitem>

      <listitem>
        <para>Table definitions containing <literal>GENERATED BY DEFAULT AS
        IDENTITY</literal> but with no <literal>PRIMARY KEY</literal> do not
        automatically create a primary key. Database
        <literal>.script</literal> files made with 1.8 are fine, as the
        <literal>PRIMARY KEY</literal> clause is always included. But the
        <literal>CREATE TABLE</literal> statements in your application program
        may assume an automatic primary key is created. The old shortcut,
        IDENTITY, is retained with the same meaning. So <literal>CREATE TABLE
        T (ID IDENTITY, DAT VARCHAR(20))</literal> is translated into
        <literal>CREATE TABLE T(ID INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY, DAT VARCHAR(20))</literal>. This last form is the correct
        way of defining both autoincrement and primary key in versions 1.8 and
        2.x.</para>
      </listitem>

      <listitem>
        <para>CREATE ALIAS is now obsolete. Use the new function definition
        syntax. The <classname>org.hsqldb.Library </classname>class no longer
        exists. You should use the SQL form of the old library functions. For
        example, use <literal>LOG(x)</literal> rather than the direct form,
        <literal>"org.hsqldb.Library.log"(x)</literal>.</para>
      </listitem>

      <listitem>
        <para>The names of some commands for changing database and session
        properties have changed. See the list of statements in this
        chapter.</para>
      </listitem>

      <listitem>
        <para>Computed columns in SELECT statements which did not have an
        alias: These columns had no ResultMetaData label in version 1.8, but
        in version 2.x, the engine generates labels such as C1, C2.</para>
      </listitem>

      <listitem>
        <para>The issue with the JDBC ResultSetMetaData methods,
        <literal>getColumnName(int column)</literal> and
        <literal>getColumnLabel(int column)</literal> has been clarified by
        the JDBC 4 specification. <literal>getColumName()</literal> returns
        the underlying column name, while <literal>getColumnLabel()</literal>
        returns any specified or generated alias. HyperSQL 1.8 and 2.x have a
        connection property, <literal>get_column_name</literal>, which
        defaults to true in version 2.x, but defaulted to false in some
        releases of version 1.8.x. You have to explicitly specify this
        property as false if you want (non-standard behaviour)
        <literal>getColumnName()</literal> to return the same value as
        <literal>getColumnLabel()</literal>.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="dec_dependency_applications">
    <title>HyperSQL Dependency Settings for Applications</title>

    <subtitle>Dependency settings using Gradle, Ivy, Maven, Groovy</subtitle>

    <simpara>This section is about building applications that have build-time
    dependencies upon HyperSQL, and for executions that use a dependency
    library system. Examples of the second type are unit test runs, job runs
    triggered by a build system, or systems like Grape that pull libraries
    from the network at end-user run time.</simpara>

    <section xml:id="dec_hsqldb_version_pull">
      <title>What version to Pull</title>

      <para>The best option for most developers is to depend upon the latest
      public version of HyperSQL with a range pattern like
      <literal>[2,)</literal>. Here are exceptional cases where you should
      depend on a static version. <itemizedlist>
          <listitem>
            <simpara>Your application has code dependencies upon
            version-specific details of the HyperSQL distribution. In this
            case, the specific dependency specification should be checked in
            to your source code control system alongside the code that
            manifests the version-dependency. If your code is enhanced to use
            a newer version of HyperSQL, you should update the version
            specification so that whenever code + configs are checked out, the
            dependency will always match the code.</simpara>
          </listitem>

          <listitem>
            <simpara>Your organization only allows the use of vetted
            libraries. In this case, you vigorously maintain your
            configurations, updating your dependencies and regression testing
            as soon as new versions of HyperSQL are vetted. To get the best
            performance and reliability from HyperSQL, you should urge the
            appropriate parties to vet new versions as soon as they are
            publicly released.</simpara>
          </listitem>

          <listitem>
            <simpara>You need precisely reproducible builds.</simpara>
          </listitem>
        </itemizedlist>If none of these situations apply to you, then follow
      the suggestions in the appropriate sections below. If you need to
      specify a specific version, follow the instructions in the
      range-versioning section but change the version range specifications to
      literal versions like <literal>2.5.2</literal>.</para>
    </section>

    <section xml:id="dec_maven_range_version">
      <title>Range Versioning</title>

      <subtitle>Keeping up-to-date with Range Dependencies</subtitle>

      <note xml:id="dec_maven_range">
        <title>Limitation of Maven Version Range Specifiers</title>

        <simpara>Note that Ivy (and the many systems that use Ivy underneath,
        like Grape and Gradle) supports the opening exclusive
        <literal>]</literal> in addition to <literal>[</literal>, whereas
        Maven supports only the opening inclusive <literal>[</literal>
        specifier. See the relevant <link
        xlink:href="http://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html">
        Ivy</link> or <link
        xlink:href="http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution#DependencyMediationandConflictResolution-DependencyVersionRanges">
        Maven</link> documentation for details. There are special cases where
        you should depend on a specific version instead.</simpara>
      </note>

      <section xml:id="dec_hsqldb_dyn_dep_examples">
        <title>Range Dependency Specification Examples</title>

        <important>
          <simpara>For all examples below, when a range pattern is given, it
          means the latest version equal or greater than version
          <literal>2</literal>. If a classifier is shown, it is optional and
          you can skip it to get the default (no-classifier) jar.</simpara>
        </important>

        <example>
          <title>Sample Range Ivy Dependency</title>

          <programlisting>
 &lt;dependency org="org.hsqldb" name="hsqldb" rev="[2,)" conf="j8-&gt;default"/&gt;</programlisting>

          <simpara>I give no example here of specifying a
          <emphasis>classifier</emphasis> in <filename>ivy.xml</filename>
          because I have so far failed to get that to succeed. Classifiers in
          in <filename>ivy.xml</filename> are supported if using Gradle, as
          covered below.</simpara>

          <simpara>At the time that I'm writing this, our builds are only
          providing one classifier (besides the default no-classifier, of
          course) and its name is "debug". Therefore in all examples for using
          a classifier I am using classifier name "debug".</simpara>
        </example>

        <example>
          <title>Sample Range Maven Dependency</title>

          <simpara>See <link xlink:href="#dec_maven_range">note above</link>
          about Maven range specifications.</simpara>

          <programlisting>
 &lt;dependency&gt;
   &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
   &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
   &lt;version&gt;[2,)&lt;/version&gt;
   &lt;!-- Scope defaults to "compile":
   &lt;scope&gt;test&lt;/scope&gt;
     Use a classifier to pull one of our alternative jars:
   &lt;classifier&gt;debug&lt;/classifier&gt;
   --&gt;
 &lt;/dependency&gt;</programlisting>
        </example>

        <example>
          <title>Sample Range Gradle Dependency</title>

          <programlisting>
 dependencies.compile 'org.hsqldb:hsqldb:[2,):debug'
 dependencies {
     runtime 'org.hsqldb:hsqldb:[2,):debug@jar',
             'org.hsqldb:sqltool:[2,):debug@jar'
 }</programlisting>
        </example>

        <para>If you want to use an <filename>ivy.xml</filename> file with a
        Gradle build, you will need use the <link
        xlink:href="https://github.com/unsaved/gradle-ivyxml-plugin"> Ivyxml
        Gradle Plugin</link>. It just takes a few links of code in your
        <filename>build.gradle</filename> file to hook in
        <literal>ivyxml</literal>. See the <link
        xlink:href="https://github.com/unsaved/gradle-ivyxml-plugin/raw/master/README.txt">
        Ivyxml documentation</link> to see exactly how. <example>
            <title>Sample Range ivy.xml loaded by Ivyxml plugin</title>

            <programlisting>
 &lt;ivy-module version="2.0" xmlns:m="http://ant.apache.org/ivy/maven"&gt;
 ...
 &lt;dependency org="org.hsqldb" name="hsqldb" rev="[2,)" m:classifier="debug"/&gt;</programlisting>
          </example></para>

        <example>
          <title>Sample Range Groovy Dependency, using Grape</title>

          <programlisting>
@Grab('org.hsqldb:hsqldb:[2,):debug')</programlisting>
        </example>
      </section>
    </section>
  </section>
</chapter>
