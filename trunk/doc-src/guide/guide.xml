<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->
<!DOCTYPE book [
<!ENTITY % dummy22 SYSTEM "../entities/global.ent">
%dummy22;
]>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:ns5="http://www.w3.org/1999/xhtml"
      xmlns:ns4="http://www.w3.org/1998/Math/MathML"
      xmlns:ns3="http://www.w3.org/2000/svg"
      xmlns:ns="http://docbook.org/ns/docbook">
  <!-- We declare the default namespace + those for prefixes xlink: and xi: in
       the root element, so we can use them anywhere in this file. -->

  <info>
    <title>HyperSQL User Guide</title>

    <subtitle>HyperSQL Database Engine, aka HSQLDB</subtitle>

    <authorgroup>
      <editor>
        <orgname>The HSQL Development Group</orgname>
      </editor>

      <editor>
        <personname><firstname>Blaine</firstname>
        <surname>Simpson</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </editor>

      <editor>
        <personname><firstname>Fred</firstname>
        <surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </editor>
    </authorgroup>

    <edition>$Revision$</edition>

    <pubdate>$Date$</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>Hypersonic</keyword>

      <keyword>Database</keyword>

      <keyword>JDBC</keyword>

      <keyword>Java</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2002-2009 The HSQL Development Group. Permission is
      granted to distribute this document without any alteration under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <preface xml:id="book-pref">
    <title>Preface</title>

    <para>If you notice any mistakes in this document, please email the author
    listed at the beginning of the chapter. If you have problems with the
    procedures themselves, please use the HSQLDB support facilities which are
    listed at <link
    xlink:href="http://hsqldb.org/web/hsqlSupport.html">**todo**</link>.</para>

    <xi:include href="../altformats-sect.xml" />
  </preface>

  <chapter xml:id="running-chapt">
    <title>Running and Using HyperSQL</title>

    <info>
      <authorgroup>
        <author>
          <personname><firstname>Fred</firstname>
          <surname>Toussi</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Guide</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="running_jar-sect">
      <title>The HSQLDB Jar</title>

      <para>The HSQLDB jar package is located in the /lib directory of the ZIP
      package and contains several components and programs.</para>

      <itemizedlist>
        <title>Components of the Hsqldb jar package</title>

        <listitem>
          <para>HyperSQL RDBMS Engine (HSQLDB)</para>
        </listitem>

        <listitem>
          <para>HyperSQL JDBC Driver</para>
        </listitem>

        <listitem>
          <para>Database Manager (GUI database access tool, with Swing and AWT
          versions)</para>
        </listitem>

        <listitem>
          <para>Sql Tool (command line database access tool)</para>
        </listitem>
      </itemizedlist>

      <para>The HyperSQL RDBMS and JDBC Driver provide the core functionality.
      The rest are general-purpose database tools that can be used with any
      database engine that has a JDBC driver.</para>
    </section>

    <section xml:id="running_tools-sect">
      <title>Running Database Access Tools</title>

      <para>The tools are used for interactive user access to databases,
      including creation of a database, inserting or modifying data, or
      querying the database. All tools are run in the normal way for Java
      programs. In the following example the Swing version of the Database
      Manager is executed. The <filename>hsqldb.jar</filename> is located in
      the directory <filename>../lib</filename> relative to the current
      directory.</para>

      <screen>java -cp ../lib/hsqldb.jar org.hsqldb.util.DatabaseManagerSwing</screen>

      <para>If <filename>hsqldb.jar</filename> is in the current directory,
      the command would change to:</para>

      <screen>java -cp hsqldb.jar org.hsqldb.util.DatabaseManagerSwing</screen>

      <itemizedlist>
        <title>Main classes for the Hsqldb tools</title>

        <listitem>
          <para><classname>org.hsqldb.util.DatabaseManager</classname></para>
        </listitem>

        <listitem>
          <para><classname>org.hsqldb.util.DatabaseManagerSwing</classname></para>
        </listitem>

        <listitem>
          <para><classname>org.hsqldb.cmdline.SqlTool</classname></para>
        </listitem>
      </itemizedlist>

      <para>When a tool is up and running, you can connect to a database (may
      be a new database) and use SQL commands to access and modify the
      data.</para>

      <para>Tools can use command line arguments. You can add the command line
      argument --help to get a list of available arguments for these
      tools.</para>
    </section>

    <section xml:id="running_db-sect">
      <title>A HyperSQL Database</title>

      <para>Each HyperSQL database is called a catalog. There are three types
      of catalog depending on how the data is stored.</para>

      <itemizedlist>
        <title>Types of catalog data</title>

        <listitem>
          <para><glossterm>mem:</glossterm> stored entirely in RAM - without
          any persistence beyond the JVM process's life</para>
        </listitem>

        <listitem>
          <para><glossterm>file:</glossterm> stored in filesystem files</para>
        </listitem>

        <listitem>
          <para><glossterm>res:</glossterm> stored in a Java resource, such as
          a Jar and always read-only</para>
        </listitem>
      </itemizedlist>

      <para>All-in-memory, <glossterm>mem:</glossterm> catalogs can be used
      for test data or as sophisticated caches for an application. These
      databases do not have any files.</para>

      <para>A <glossterm>file</glossterm>: catalog consists of between 2 to 5
      files, all named the same but with different extensions, located in the
      same directory. For example, the database named "test" consists of the
      following files:</para>

      <itemizedlist>
        <listitem>
          <para><filename>test.properties</filename></para>
        </listitem>

        <listitem>
          <para><filename>test.script</filename></para>
        </listitem>

        <listitem>
          <para><filename>test.log</filename></para>
        </listitem>

        <listitem>
          <para><filename>test.data</filename></para>
        </listitem>

        <listitem>
          <para><filename>test.backup</filename></para>
        </listitem>
      </itemizedlist>

      <para>The properties file contains general settings about the database.
      The script file contains the definition of tables and other database
      objects, plus the data for non-cached tables. The log file contains
      recent changes to the database. The data file contains the data for
      cached tables and the backup file is a compressed backup of the last
      known consistent state of the data file. All these files are essential
      and should never be deleted. For some catalogs, the
      <filename>test.data</filename> and <filename>test.backup</filename>
      files will not be present. In addition to those files, a HyperSQL
      database may link to any formatted text files, such as CSV lists,
      anywhere on the disk.</para>

      <para>While the "test" catalog is open, a <filename>test.log</filename>
      file is used to write the changes made to data. This file is removed at
      a normal SHUTDOWN. Otherwise (with abnormal shutdown) this file is used
      at the next startup to redo the changes. A <filename>test.lck
      </filename>file is also used to record the fact that the database is
      open. This is deleted at a normal SHUTDOWN.</para>

      <note>
        <para>When the engine closes the database at a shutdown, it creates
        temporary files with the extension <literal>.new</literal> which it
        then renames to those listed above. In some circumstances, a
        <filename>test.data.old</filename> is created and deleted
        afterwards.</para>
      </note>

      <para>A <glossterm>res:</glossterm> catalog consists of the files for a
      small, read-only database that can be stored inside a Java resource such
      as a ZIP or JAR archive and distributed as part of a Java application
      program.</para>
    </section>

    <section xml:id="running_inprocess-sect">
      <title>In-Process Access to Database Catalogs</title>

      <para>In general, JDBC is used for all access to databases. This is done
      by making a connection to the database, then using various methods of
      the <classname>java.sql.Connection</classname> object that is returned
      to access the data. Access to an <glossterm>in-process</glossterm>
      database is started from JDBC, with the database path specified in the
      connection URL. For example, if the <glossterm>file:
      </glossterm>database name is "testdb" and its files are located in the
      same directory as where the command to run your application was issued,
      the following code is used for the connection:</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:testdb", "SA", "");</programlisting>

      <para>The database file path format can be specified using forward
      slashes in Windows hosts as well as Linux hosts. So relative paths or
      paths that refer to the same directory on the same drive can be
      identical. For example if your database path in Linux is
      <filename>/opt/db/testdb</filename> and you create an identical
      directory structure on the <literal>C:</literal> drive of a Windows
      host, you can use the same URL in both Windows and Linux:</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb", "SA", "");</programlisting>

      <para>When using relative paths, these paths will be taken relative to
      the directory in which the shell command to start the Java Virtual
      Machine was executed. Refer to the Javadoc for <classname
      xlink:href="#JDBCConnection.html-link"> JDBCConnection</classname> for
      more details.</para>

      <para>A <glossterm>mem:</glossterm> database is specified by the
      <glossterm>mem:</glossterm> protocol. For <glossterm>mem:</glossterm>
      databases, the path is simply a name. Several
      <glossterm>mem:</glossterm> databases can exist at the same time and
      distinguished by their names. In the example below, the database is
      called "mymemdb":</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:mem:mymemdb", "SA", "");</programlisting>

      <para>A <glossterm>res:</glossterm> database, is specified by the
      <glossterm>res:</glossterm> protocol. As it is a Java resource, the
      database path is a Java URL (similar to the path to a class). In the
      example below, "resdb" is the root name of the database files, which
      exists in the directory "org/my/path" within the classpath (probably in
      a Jar). A Java resource is stored in a compressed format and is
      decompressed in memory when it is used. For this reason, a
      <glossterm>res:</glossterm> database should not contain large amounts of
      data and is always read-only.</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:res:org.my.path.resdb", "SA", "");</programlisting>

      <para>The first time <glossterm>in-process</glossterm> connection is
      made to a database, some general data structures are initialised and a
      few helper threads are started. After this, creation of connections and
      calls to JDBC methods of the connections execute as if they are part of
      the Java application that is making the calls. When the SQL command
      "SHUTDOWN" is executed, the global structures and helper threads for the
      database are destroyed.</para>

      <para>Note that only one Java process at a time can make
      <glossterm>in-process</glossterm> connections to a given
      <glossterm>file:</glossterm> database. However, if the
      <glossterm>file:</glossterm> database has been made read-only, or if
      connections are made to a <glossterm>res:</glossterm> database, then it
      is possible to make <glossterm>in-process</glossterm> connections from
      multiple Java processes.</para>
    </section>

    <section xml:id="running_modes-sect">
      <title>Listener / Server Modes</title>

      <para>For most applications, <glossterm>in-process</glossterm> access is
      faster, as the data is not converted and sent over the network. The main
      drawback is that it is not possible by default to connect to the
      database from outside your application. As a result you cannot check the
      contents of the database with external tools such as Database Manager
      while your application is running.</para>

      <para>Server modes provide the maximum accessibility. The database
      engine runs in a JVM and and opens one or more
      <glossterm>in-process</glossterm> catalogs. It listens for connections
      from programs on the same computer or other computers on the network. It
      translates these connections into <glossterm>in-process</glossterm>
      connections to the databases.</para>

      <para>Several different programs can connect to the server and retrieve
      or update information. Applications programs (clients) connect to the
      server using the HyperSQL JDBC driver. In most server modes, the server
      can serve an unlimited number of databases that are specified at the
      time of running the server, or optionally, as a connection request is
      received.</para>

      <para>There are three server modes, based on the protocol used for
      communications between the client and server, and briefly disucssed
      below. More details on servres is provided in a separate chapter.</para>

      <section xml:id="running_hsqlserver-sect">
        <title>HyperSQL HSQL Server</title>

        <para>This is the preferred way of running a database server and the
        fastest one. A proprietary communications protocol is used for this
        mode. A command similar to those used for running tools and described
        above is used for running the server. The following example of the
        command for starting the server starts the server with one (default)
        database with files named "mydb.*" and the public name of
        "xdb".</para>

        <informalexample>
          <screen>    java -cp ../lib/hsqldb.jar org.hsqldb.server.Server --database.0 file:mydb --dbname.0 xdb</screen>
        </informalexample>

        <para>The command line argument <literal>--help</literal> can be used
        to get a list of available arguments.</para>
      </section>

      <section xml:id="running_httpserver-sect">
        <title>HyperSQL HTTP Server</title>

        <para>This method of access is used when the computer hosting the
        database server is restricted to the HTTP protocol. The only reason
        for using this method of access is restrictions imposed by firewalls
        on the client or server machines and it should not be used where there
        are no such restrictions. The HyperSQL HTTP Server is a special web
        server that allows JDBC clients to connect via HTTP. The server can
        also act as a small general-purpose web server for static
        pages.</para>

        <para>To run an HTTP server, replace the main class for the server in
        the example command line above with the following:</para>

        <informalexample>
          <screen>    org.hsqldb.server.WebServer</screen>
        </informalexample>

        <para>The command line argument <literal>--help</literal> can be used
        to get a list of available arguments.</para>
      </section>

      <section xml:id="running_servlet-sect">
        <title>HyperSQL HTTP Servlet</title>

        <para>This method of access also uses the HTTP protocol. It is used
        when a separate servlet engine (or application server) such as Tomcat
        or Resin provides access to the database. The Servlet Mode cannot be
        started independently from the servlet engine. The
        <filename>Servlet</filename> class, in the HSQLDB jar, should be
        installed on the application server to provide the connection. The
        database is specified using an application server property. Refer to
        the source file <filename xlink:href="#Servlet.java-link">
        src/org/hsqldb/server/Servlet.java</filename> to see the
        details.</para>

        <para>Both HTTP Server and Servlet modes can only be accessed using
        the JDBC driver at the client end. They do not provide a web front end
        to the database. The Servlet mode can serve only a single
        database.</para>

        <para>Please note that you do not normally use this mode if you are
        using the database engine in an application server. In this situation,
        connections to a catalog are usually made
        <glossterm>in-process</glossterm>, or using a Server</para>
      </section>

      <section xml:id="running_connecting-sect">
        <title>Connecting to a Database Server</title>

        <para>When a HyperSQL server is running, client programs can connect
        to it using the HSQLDB JDBC Driver contained in
        <filename>hsqldb.jar</filename>. Full information on how to connect to
        a server is provided in the Java Documentation for <classname
        xlink:href="#JDBCConnection.html-link"> JDBCConnection</classname>
        (located in the <filename>/doc/src</filename> directory of HSQLDB
        distribution). A common example is connection to the default port
        (9001) used for the <glossterm>hsql:</glossterm> protocol on the same
        machine:</para>

        <example>
          <title>Java code to connect to the local hsql Server</title>

          <programlisting>    try {
        Class.forName("org.hsqldb.jdbc.JDBCDriver" );
    } catch (Exception e) {
        System.out.println("ERROR: failed to load HSQLDB JDBC driver.");
        e.printStackTrace();
        return;
    }

    Connection c = DriverManager.getConnection("jdbc:hsqldb:hsql://localhost/xdb", "SA", "");</programlisting>
        </example>

        <para>If the HyperSQL HTTP server is used, the protocol is
        <glossterm>http:</glossterm> and the URL will be different:</para>

        <example>
          <title>Java code to connect to the local http Server</title>

          <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:http://localhost/xdb", "SA", "");</programlisting>
        </example>

        <para>Note in the above connection URL, there is no mention of the
        database file, as this was specified when running the server. Instead,
        the public name defined for dbname.0 is used. Also, see the <link
        endterm="advanced-title" xlink:href="#advanced-chapt"></link>**todo**
        chapter for the connection URL when there is more than one database
        per server instance.</para>
      </section>

      <section xml:id="running_security-sect">
        <title>Security Considerations</title>

        <para>When a HyperSQL server is run, network access should be
        adequately protected. Source IP addresses may be restricted by use of
        TCP filtering or firewall programs, or standalone firewalls.<link
        endterm="tls-sect-title" xlink:href="#listeners_tls-sect"></link> Only
        secure passwords should be used-- most importantly, the password for
        the default system user should be changed from the default empty
        string. If you are purposefully providing data to the public, then the
        wide-open public network connection should be used exclusively to
        access the public data via read-only accounts. (i.e., neither secure
        data nor privileged accounts should use this connection). These
        considerations also apply to HSQLDB servers run with the HTTP
        protocol.</para>

        <para>HyperSQL provides two optional security mechanisms. The
        encrypted SSL protocol, and Access Control Lists. Both mechanisms can
        be specified when running the Server or WebServer. From the client,
        the URL's co connect to an SSL server is slightly different:</para>

        <para><example>
            <title>Java code to connect to the local secure SSL hsql and http
            Servers</title>

            <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:hsqls://localhost/xdb", "SA", "");
    Connection c = DriverManager.getConnection("jdbc:hsqldb:https://localhost/xdb", "SA", "");
</programlisting>
          </example>The security features are discussed in detail in
        **todo**.</para>
      </section>

      <section xml:id="running_multiple_db-sect">
        <title>Using Multiple Databases</title>

        <para>A server can provide connections to more than one database. In
        the examples above, more than one set of database names can be
        specified on the command line. It is also possible to specify all the
        databases in a <literal>.properties</literal> file, instead of the
        command line. These capabilities are covered in the ** todo **
        chapter.</para>
      </section>
    </section>

    <section xml:id="running-data-access-sect">
      <title>Accessing the Data</title>

      <para>As shown so far, a <classname>java.sql.Connection</classname>
      object is always used to access the database. But the speed and
      performance depends on the type of connection.</para>

      <para>Establishing a connection and closing it has some overheads,
      therefore it is not good practice to create a new connection to perform
      a small number of operations. A connection should be reused as much as
      possible and closed only when it is not going to be used again for a
      long while.</para>

      <para>Reuse is more important for server connections. A server
      connection uses a TCP port for communications. Each time a connection is
      made, a port is allocated by the operating system and deallocated after
      the connection is closed. If many connections are made from a single
      client, the operating system may not be able to keep up and may refuse
      the connection attempt.</para>

      <para>A <classname>java.sql.Connection</classname> object has some
      methods that return further <classname>java.sql.*</classname> objects.
      All these objects belong to the connection that returned them and are
      closed when the connection is closed. These objects can be reused, but
      if they are not needed after performing the operations, they should be
      closed.</para>

      <para>A <classname>java.sql.DatabaseMetaData</classname> object is used
      to get metadata for the database.</para>

      <para>A <classname>java.sql.Statement</classname> object is used to
      execute queries and data change statements. A
      <classname>java.sql.Statement</classname> can be reused to execute a
      different statement each time.</para>

      <para>A <classname>java.sql.PreparedStatement</classname> object is used
      to execute a single statement repeatedly. The SQL statement usually
      contains parameters, which can be set to new values before each reuse.
      When a <classname>java.sql.PreparedStatement</classname> object is
      created, the engine keeps the compiled SQL statement for reuse, until
      the <classname>java.sql.PreparedStatement</classname> object is closed.
      As a result, repeated use of a
      <classname>java.sql.PreparedStatement</classname> is much faster than
      using a <classname>java.sql.Statement</classname> object.</para>

      <para>A <classname>java.sql.CallableStatement</classname> object is used
      to execute an SQL CALL statement. The SQL CALL statement may contain
      parameters, which should be be set to new values before each reuse.
      Similar to <classname>java.sql.PreparedStatement</classname>, the engine
      keeps the compiled SQL statement for reuse, until the
      <classname>java.sql.CallableStatement</classname> object is
      closed.</para>

      <para>A <classname>java.sql.Connection</classname> object also has some
      methods for transaction control.</para>

      <para>The <methodname>commit()</methodname> method performs a
      <literal>COMMIT</literal> while the <methodname>rollback()</methodname>
      method performs a <literal>ROLLBACK</literal> SQL statement.</para>

      <para>The <methodname>setSavepoint(String name)</methodname> method
      performs a <literal>SAVEPOINT &lt;name&gt;</literal> SQL statement and
      returns a <classname>java.sql.Savepoint</classname> object. The
      <methodname>rollback(Savepoint name)</methodname> method performs a
      <literal>ROLLBACK TO SAVEPOINT &lt;name&gt;</literal> SQL
      statement.</para>

      <para>The Javadoc for <classname xlink:href="#JDBCConnection.html-link">
      JDBCConnection</classname>, <classname
      xlink:href="#JDBCDriver.html-link"> JDBCDriver</classname>, <classname
      xlink:href="#JDBCDatabaseMetaData.html-link">
      JDBCDatabaseMetadata</classname> <classname
      xlink:href="#JDBCResultSet.html-link"> JDBCResultSet</classname>,
      <classname xlink:href="#JDBCStatement.html-link">
      JDBCStatement</classname>, <classname
      xlink:href="#JDBCPreparedStatement.html-link">
      JDBCPreparedStatement</classname> list all the supported JDBC methods
      together with information that is specific to HSQLDB.</para>
    </section>

    <section xml:id="running_closing-sect">
      <title>Closing the Database</title>

      <para>All databases running in different modes can be closed with the
      SHUTDOWN command, issued as an SQL statement.</para>

      <para>When SHUTDOWN is issued, all active transactions are rolled back.
      The catalog files are then saved in a form that can be opened quickly
      the next time the catalog is opened.</para>

      <para>A special form of closing the database is via the SHUTDOWN COMPACT
      command. This command rewrites the <literal>.data</literal> file that
      contains the information stored in CACHED tables and compacts it to its
      minimum size. This command should be issued periodically, especially
      when lots of inserts, updates or deletes have been performed on the
      cached tables. Changes to the structure of the database, such as
      dropping or modifying populated CACHED tables or indexes also create
      large amounts of unused file space that can be reclaimed using this
      command.</para>

      <para>Databases are not closed when the last connection to the database
      is explicitly closed via JDBC. A connection property,
      <literal>shutdown=true</literal>, can be specified on the first
      connection to the database (the connection that opens the database) to
      force a shutdown when the last connection closes.</para>

      <para><example>
          <title>specifying a connection property to shutdown the database
          when the last connection is closed</title>

          <programlisting>Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb;shutdown=true", "SA", "");</programlisting>
        </example>This feature is useful for running tests, where it may not
      be practical to shutdown the database after each test. But it is not
      recommended for application programs.</para>
    </section>

    <section xml:id="running_newdb-sect">
      <title>Creating a New Database</title>

      <para>When a server instance is started, or when a connection is made to
      an <glossterm>in-process</glossterm> database, a new, empty database is
      created if no database exists at the given path.</para>

      <para>This feature has a side effect that can confuse new users. If a
      mistake is made in specifying the path for connecting to an existing
      database, a connection is nevertheless established to a new database.
      For troubleshooting purposes, you can specify a connection property
      <property>ifexists</property>=<literal>true</literal> to allow
      connection to an existing database only and avoid creating a new
      database. In this case, if the database does not exist, the
      <methodname>getConnection()</methodname> method will throw an
      exception.</para>

      <para><example>
          <title>specifying a connection property to disallow creating a new
          database</title>

          <programlisting>Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb;ifexists=true", "SA", "");</programlisting>
        </example></para>
    </section>
  </chapter>

  <chapter xml:id="sqlissues-chapt">
    <title xml:id="sqlissues-title">SQL Issues</title>

    <info>
      <authorgroup>
        <author>
          <personname><firstname>Fred</firstname>
          <surname>Toussi</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>SQL</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="sqlissues_standards-sect">
      <title>Standards Support</title>

      <para>HSQLDB 1.9.0 supports the dialect of SQL defined by SQL standards
      92, 1999, 2003 and 200n. This means where a feature of the standard is
      supported, e.g. left outer join, the syntax is that specified by the
      standard text. Almost all syntactic features of SQL-92 up to Advanced
      Level are supported, as well as SQL 200n core and many optional features
      of this standard. Work is in progress for a formal declaration of
      conformance.</para>

      <para>Various chapters of this guide list the syntax that is supported.
      When writing or converting existing SQL DDL (Data Definition Language),
      DML (Data Manipulation Language) or DQL (Data Query Language) statements
      for HSQLDB, you should consult the supported syntax and modify the
      statements accordingly. Some statements written for older versions may
      have to be modified.</para>

      <para>Over 300 words are reserved by the standard and should not be used
      as table or column names. For example, the word POSITION is reserved as
      it is a function defined by the Standards with a similar role as
      <methodname>String.indexOf()</methodname> in Java. HyperSQL does not
      currently prevent you from using a reserved word if it does not support
      its use or can distinguish it. For example CUBE is a reserved words that
      is not currently supported by HyperSQL and is allowed as a table or
      column name. You should avoid using such names as future versions of
      HyperSQL are likely to support the reserved words and may reject your
      table definitions or queries. The full list of SQL reserved words is in
      the source of the class <classname
      xlink:href="#Tokens.java-link">org.hsqldb.Tokens</classname>.</para>

      <para>If you have to use a reserved keyword as the name of a database
      object, you can enclose it in double quotes.</para>

      <para>HyperSQL also supports enhancements with keywords and expressions
      that are not part of the SQL standard. Expressions such as
      <literal>SELECT TOP 5 FROM ..</literal>, <literal>SELECT LIMIT 0 10 FROM
      ...</literal> or <literal>DROP TABLE mytable IF EXISTS</literal> are
      among such constructs.</para>

      <para>For a well-written basic guide to SQL with examples, you can
      consult <link
      xlink:href="http://www.postgresql.org/files/documentation/books/aw_pgsql/index.html">PostgreSQL:
      Introduction and Concepts</link> by Bruce Momjian, which is available on
      the web. Most of the core SQL coverage in the book applies also to
      HyperSQL. There are some differences in keywords supported by one and
      not the other engine (OUTER, OID's, etc.) or used differently
      (IDENTITY/SERIAL, TRIGGER, SEQUENCE, etc.).</para>

      <para>In version 1.9.0, all features of JDBC4 that apply to the
      capabilities of HSQLDB are fully supported. The relevant JDBC classes
      are thoroughly documented with additional clarifications and HyperSQL
      specific comments. See the <link
      xlink:href="#javadoc-link">JavaDoc</link> for the
      <classname>org.hsqldb.jdbc.JDBCXXXX</classname> classes.</para>
    </section>

    <section xml:id="sqlissues_tabletypes-sect">
      <title>Different Types of Tables</title>

      <para>HSQLDB supports TEMP tables and three types of persistent
      tables.</para>

      <para>TEMP tables are not written to disk and last only for the lifetime
      of the Connection object. The contents of each TEMP table is visible
      only from the Connection that was used to populate it; other concurrent
      connections to the database will have access to their own copies of the
      table. Since 1.8.0 the definition of TEMP tables conforms to the GLOBAL
      TEMPORARY type in the SQL standard. The definition of the table persists
      but each new connections sees its own copy of the table, which is empty
      at the beginning. When the connection commits, the contents of the table
      are cleared by default. If the table definition statements includes ON
      COMMIT PRESERVE ROWS, then the contents are kept when a commit takes
      place.</para>

      <para>The three types of persistent tables are MEMORY tables, CACHED
      tables and TEXT tables.</para>

      <para>Memory tables are the default type when the CREATE TABLE command
      is used. Their data is held entirely in memory but any change to their
      structure or contents is written to the
      <filename>&lt;dbname&gt;.script</filename> file. The script file is read
      the next time the database is opened, and the MEMORY tables are
      recreated with all their contents. So unlike TEMP table, the default,
      MEMORY tables are persistent.</para>

      <para>CACHED tables are created with the CREATE CACHED TABLE command.
      Only part of their data or indexes is held in memory, allowing large
      tables that would otherwise take up to several hundred megabytes of
      memory. Another advantage of cached tables is that the database engine
      takes less time to start up when a cached table is used for large
      amounts of data. The disadvantage of cached tables is a reduction in
      speed. Do not use cached tables if your data set is relatively small. In
      an application with some small tables and some large ones, it is better
      to use the default, MEMORY mode for the small tables.</para>

      <para>TEXT tables use a CSV (Comma Separated Value) or other delimited
      text file as the source of their data. You can specify an existing CSV
      file, such as a dump from another database or program, as the source of
      a TEXT table. Alternatively, you can specify an empty file to be filled
      with data by the database engine. TEXT tables are efficient in memory
      usage as they cache only part of the text data and all of the indexes.
      The Text table data source can always be reassigned to a different file
      if necessary. Two commands are needed to set up a TEXT table as detailed
      in the <link endterm="texttables-title"
      xlink:href="#texttables-chapt">**todo**</link> chapter.</para>

      <para>With all-in-memory databases (see above), both MEMORY table and
      CACHED table declarations are treated as declarations for non-persistent
      memory tables. TEXT table declarations are not allowed in this
      mode.</para>

      <para>The default type of table resulting from future CREATE TABLE
      statements can be specified with the SQL command:</para>

      <para><programlisting>    SET DEFAULT TABLE TYPE { CACHED | MEMORY };</programlisting>The
      type of an existing table can be changed with the SQL command:</para>

      <para><programlisting>    SET TABLE &lt;table name&gt; TYPE { CACHED | MEMORY };</programlisting>SQL
      statements access different types of tables uniformly. No change to
      statements is needed to access different types of table.</para>
    </section>

    <section xml:id="sqlissues_constr_indexes-sect">
      <title>Constraints and Indexes</title>

      <para>HyperSQL supports PRIMARY KEY, NOT NULL, UNIQUE, CHECK and FOREIGN
      KEY constraints. This support is fairly comprehensive and covers
      multi-column constraints and indexes, plus cascading updates and deletes
      for foreign keys.</para>

      <para>The engine creates indexes internally to support PRIMARY KEY,
      UNIQUE and FOREIGN KEY constraints: a unique index is created for each
      PRIMARY KEY or UNIQUE constraint; an ordinary index is created for each
      FOREIGN KEY constraint. Because of this, you should not create duplicate
      user-defined indexes on the same column sets covered by these
      constraints. This would result in unnecessary memory and speed
      overheads. See the discussion in the <link endterm="sqlissues-title"
      xlink:href="#sqlissues-chapt">**todo**</link> chapter for more
      information.</para>

      <para>Indexes are crucial for adequate query speed. When queries joining
      multiple tables are used, there must be an index on each joined column
      of each table. When range or equality conditions are used e.g.
      <literal>SELECT ... WHERE acol &gt;10 AND bcol = 0</literal>, an index
      is required on the acol column used in the condition. Indexes have no
      effect on ORDER BY clauses or some LIKE conditions. As a rule of thumb,
      HSQLDB is capable of internal processing of queries at over 100,000 rows
      per second. Any query that runs into several seconds should be checked
      and indexes should be added to the relevant columns of the tables if
      necessary.</para>

      <section>
        <title>Primary Key Constraints</title>

        <para>A PRIMARY KEY constraint is equivalent to a UNIQUE constraint
        with NOT NULL constraints on all it columns.</para>
      </section>

      <section>
        <title>Unique Constraints</title>

        <para>According to the SQL standards, a unique constraint on a single
        column means no two values are equal unless one of them is NULL. This
        means you can have one or more rows where the column value is
        NULL.</para>

        <para>A unique constraint on multiple columns (c1, c2, c3, ..) means
        that no two sets of values for the columns are equal unless at lease
        one of them is NULL. Each single column taken by itself can have
        repeat values. The following example satisfies a UNIQUE constraint on
        the two columns:</para>

        <example>
          <title>Column values which satisfy a 2-column UNIQUE
          constraint</title>

          <simplelist columns="2" type="horiz">
            <member>1,</member>

            <member>2</member>

            <member>2,</member>

            <member>1</member>

            <member>2,</member>

            <member>2</member>

            <member>NULL,</member>

            <member>1</member>

            <member>NULL,</member>

            <member>1</member>

            <member>1,</member>

            <member>NULL</member>

            <member>NULL,</member>

            <member>NULL</member>

            <member>NULL,</member>

            <member>NULL</member>
          </simplelist>
        </example>
      </section>

      <section>
        <title>Unique Indexes</title>

        <para>In 1.9.0, user-defined UNIQUE indexes can still be declared but
        they are deprecated. You should use a UNIQUE constraint
        instead.</para>

        <para><literal>CONSTRAINT &lt;name&gt; UNIQUE</literal> always creates
        internally a unique index on the columns, as with previous versions,
        so it has the same effect as the deprecated UNIQUE INDEX
        declaration.</para>
      </section>

      <section>
        <title>FOREIGN KEYS</title>

        <para>HSQLDB features single and multiple column foreign keys. A
        foreign key can also be specified to reference a target table without
        naming the target column(s). In this case the primary key column(s) of
        the target table is used as the referenced column(s). Each pair of
        referencing and referenced columns in any foreign key should be of
        identical type. When a foreign key is declared, a unique constraint
        (or primary key) must exist on the referenced columns in the primary
        key table. A non-unique index is automatically created on the
        referencing columns. For example:</para>

        <informalexample>
          <programlisting>    CREATE TABLE child(c1 INTEGER, c2 VARCHAR, FOREIGN KEY (c1, c2) REFERENCES parent(p1, p2));</programlisting>
        </informalexample>

        <para>There must be a UNIQUE constraint on columns
        <literal>(p1,p2)</literal> in the table named "parent". A non-unique
        index is automatically created on columns <literal>(c1, c2)</literal>
        in the table named "child". Columns <literal>p1</literal> and
        <literal>c1</literal> must be of the same type (INTEGER). Columns
        <literal>p2</literal> and <literal>c2</literal> must be of the same
        type (VARCHAR).</para>
      </section>

      <section>
        <title>Indexes and Query Speed</title>

        <para>HSQLDB does not use indexes to improve sorting of query results.
        But indexes have a crucial role in improving query speed. If no index
        is used in a query on a single table, such as a DELETE query, then all
        the rows of the table must be examined. With an index on one of the
        columns that is in the WHERE clause, it is often possible to start
        directly from the first candidate row and reduce the number of rows
        that are examined.</para>

        <para>Indexes are even more important in joins between multiple
        tables. <literal>SELECT ... FROM t1 JOIN t2 ON t1.c1 = t2.c2
        </literal> is performed by taking rows of t1 one by one and finding a
        matching row in t2. If there is no index on t2.c2 then for each row of
        t1, all the rows of t2 must be checked. Whereas with an index, a
        matching row can be found in a fraction of the time. If the query also
        has a condition on t1, e.g., <literal>SELECT ... FROM t1 JOIN t2 ON
        t1.c1 = t2.c2 WHERE t1.c3 = 4</literal> then an index on t1.c3 would
        eliminate the need for checking all the rows of t1 one by one, and
        will reduce query time to less than a millisecond per returned row. So
        if t1 and t2 each contain 10,000 rows, the query without indexes
        involves checking 100,000,000 row combinations. With an index on
        t2.c2, this is reduced to 10,000 row checks and index lookups. With
        the additional index on t2.c2, only about 4 rows are checked to get
        the first result row.</para>

        <para>Indexes are automatically created for PRIMARY KEY, UNIQUE, and
        FOREIGN KEY columns. Otherwise you should define an index using the
        CREATE INDEX command.</para>

        <para>Note that in HSQLDB a unique index on multiple columns can be
        used internally as a non-unique index on the first column in the list.
        For example: <literal>CONSTRAINT name1 UNIQUE (c1, c2, c3); </literal>
        means there is the equivalent of <literal>CREATE INDEX name2 ON
        atable(c1);</literal>. So you do not need to specify an extra index if
        you require one on the first column of the list.</para>

        <para>In 1.9.0, a multi-column index will speed up queries that
        contain joins or values on ALL the columns. You need NOT declare
        additional individual indexes on those columns unless you use queries
        that search only on a subset of the columns. For example, rows of a
        table that has a PRIMARY KEY or UNIQUE constraint on three columns or
        simply an ordinary index on those columns can be found efficiently
        when values for all three columns are specified in the WHERE clause.
        For example, <literal>SELECT ... FROM t1 WHERE t1.c1 = 4 AND t1.c2 = 6
        AND t1.c3 = 8 </literal>will use an index on
        <literal>t1(c1,c2,c3)</literal> if it exists.</para>

        <para>As a result of the improvements to multiple key indexes, the
        order of declared columns of the index or constraint has little affect
        on the speed of searches.</para>

        <para>A multi-column index will not speed up queries on the second or
        third column only. The first column must be specified in the JOIN ..
        ON or WHERE conditions.</para>

        <para>Query speed depends a lot on the order of the tables in the JOIN
        .. ON or FROM clauses. For example the second query below should be
        faster with large tables (provided there is an index on
        <literal>TB.COL3</literal>). The reason is that
        <literal>TB.COL3</literal> can be evaluated very quickly if it applies
        to the first table (and there is an index on
        <literal>TB.COL3</literal>):</para>

        <informalexample>
          <programlisting>    (TB is a very large table with only a few rows where TB.COL3 = 4)

    SELECT * FROM TA JOIN TB ON TA.COL1 = TB.COL2 AND TB.COL3 = 4;

    SELECT * FROM TB JOIN TA ON TA.COL1 = TB.COL2 AND TB.COL3 = 4;</programlisting>
        </informalexample>

        <para>The general rule is to put first the table that has a narrowing
        condition on one of its columns.</para>

        <para>HyperSQL features automatic, on-the-fly indexes for views and
        subselects that are used in a query.</para>
      </section>

      <section>
        <title>Where Condition or Join</title>

        <para>Unlike previous versions, HyperSQL 1.9.0 can use any relevant
        indexes for query processing, whether the query condition is specified
        in the <literal>WHERE</literal> clause or in a <literal>JOIN</literal>
        condition. It is better to use <literal>JOIN</literal> conditions, as
        they make queries more readable.</para>
      </section>

      <section>
        <title>Subqueries and Inline tables in Joins</title>

        <para>New capabilities in HSQLDB 1.9.0 **todo**...</para>

        <example>
          <title>query example</title>

          <programlisting>SELECT ... FROM (SELECT MAX(TB.COL2) C1 FROM TB WHERE TB.COL3 = 4) T2 JOIN TA ON TA.COL1 = T2.C1</programlisting>
        </example>

        <para>More on new capabilities...</para>
      </section>
    </section>

    <section xml:id="sqlissues_types_ops-sect">
      <title>Types and Arithmetic Operations</title>

      <para>Table columns of all types supported by HSQLDB can be indexed and
      can feature in comparisons. Types can be explicitly converted using the
      CAST expression, but in most cases they are converted automatically. It
      is recommended not to use indexes on LONGVARBINARY, LONGVARCHAR and
      OTHER columns, as these indexes will probably not be allowed in future
      versions.</para>

      <para>The following rules govern operations on numbers:</para>

      <para>TINYINT, SMALLINT, INTEGER, BIGINT, NUMERIC and DECIMAL (without a
      decimal point) are supported integral types. They correspond
      respectively to <classname>short</classname>,
      <classname>int</classname>, <classname>long</classname>,
      <classname>BigDecimal</classname> and <classname>BigDecimal</classname>
      Java types in the range of values that they can represent (NUMERIC and
      DECIMAL are equivalent). The SQL type dictates the maximum and minimum
      values that can be held in a field of each type. For example the value
      range for TINYINT is -128 to +127, although the actual Java type used
      for handling TINYINT is <classname>java.lang.Integer</classname>.</para>

      <para>REAL, FLOAT, DOUBLE are equivalent and all mapped to
      <classname>double</classname> in Java.</para>

      <para>DECIMAL and NUMERIC with decimal fractions are mapped to
      <classname>java.math.BigDecimal</classname> and can have very large
      numbers of digits.</para>

      <section>
        <title>Integral Types</title>

        <para>TINYINT, SMALLINT, INTEGER, BIGINT, NUMERIC and DECIMAL (without
        a decimal point) are fully interchangeable internally, and no data
        narrowing takes place. Depending on the types of the operands, the
        result of the operations is returned in a JDBC
        <classname>ResultSet</classname> in any of related Java types:
        <classname>Integer</classname>, <classname>Long</classname> or
        <classname>BigDecimal</classname>. The
        <methodname>ResultSet.getXXXX()</methodname> methods can be used to
        retrieve the values so long as the returned value can be represented
        by the resulting type. This type is deterministically based on the
        query, not on the actual rows returned. The type does not change when
        the same query that returned one row, returns many rows as a result of
        adding more data to the tables.</para>

        <para>If the SELECT statement refers to a simple column or function,
        then the return type is the type corresponding to the column or the
        return type of the function. For example:</para>

        <informalexample>
          <programlisting>    CREATE TABLE t(a INTEGER, b BIGINT);
    SELECT MAX(a), MAX(b) FROM t;</programlisting>
        </informalexample>

        <para>will return a <classname>ResultSet</classname> where the type of
        the first column is <classname>java.lang.Integer</classname> and the
        second column is <classname>java.lang.Long</classname>.
        However,</para>

        <informalexample>
          <programlisting>    SELECT MAX(a) + 1, MAX(b) + 1 FROM t;</programlisting>
        </informalexample>

        <para>will return <classname>java.lang.Long</classname> and
        <classname>BigDecimal</classname> values, generated as a result of
        uniform type promotion for all the return values. Note that type
        promotion to <classname>BigDecimal</classname> ensures the correct
        value is returned if <literal>MAX(b)</literal> evaluates to
        <literal>Long.MAX_VALUE</literal>.</para>

        <para>There is no built-in limit on the size of intermediate integral
        values in expressions. As a result, you should check for the type of
        the <classname>ResultSet</classname> column and choose an appropriate
        <methodname>getXXXX()</methodname> method to retrieve it.
        Alternatively, you can use the <methodname>getObject()</methodname>
        method, then cast the result to <classname>java.lang.Number
        </classname> and use the <methodname>intValue()</methodname> or
        <methodname>longValue()</methodname> methods on the result.</para>

        <para>When the result of an expression is stored in a column of a
        database table, it has to fit in the target column, otherwise an error
        is returned. For example when <literal>1234567890123456789012 /
        12345687901234567890</literal> is evaluated, the result can be stored
        in any integral type column, even a TINYINT column, as it is a small
        value.</para>
      </section>

      <section>
        <title>Other Numeric Types</title>

        <para>In SQL statements, numbers with a decimal point are treated as
        DECIMAL unless they are written with an exponent. Thus
        <literal>0.2</literal> is considered a DECIMAL value but
        <literal>0.2E0</literal> is considered a DOUBLE value.</para>

        <para>When <methodname>PreparedStatement.setDouble()</methodname> or
        <methodname>setFloat()</methodname> is used, the value is treated as a
        DOUBLE automatically.</para>

        <para>When a REAL, FLOAT or DOUBLE (all synonymous) is part of an
        expression, the type of the result is DOUBLE.</para>

        <para>Otherwise, when no DOUBLE value exists, if a DECIMAL or NUMERIC
        value is part an expression, the type of the result is DECIMAL. The
        result can be retrieved from a <classname>ResultSet</classname> in the
        required type so long as it can be represented. This means DECIMAL
        values can be converted to DOUBLE unless they are beyond the
        <literal>Double.MIN_VALUE - Double.MAX_VALUE</literal> range. Similar
        to integral values, when the result of an expression is stored in a
        table column, it has to fit in the target column, otherwise an error
        is returned.</para>

        <para>The distinction between DOUBLE and DECIMAL is important when a
        division takes place. When the terms are DECIMAL, the result is a
        value with a scale (number of digits to the right of the decimal
        point) equal to the larger of the scales of the two terms. With a
        DOUBLE term, the scale will reflect the actual result of the
        operation. For example, <literal>10.0/8.0</literal> (DECIMAL) equals
        <literal>1.2</literal> but <literal>10.0E0/8.0E0</literal> (DOUBLE)
        equals <literal>1.25</literal>. Without division operations, DECIMAL
        values represent exact arithmetic; the resulting scale is the sum of
        the scales of the two terms when multiplication is performed.</para>

        <para>REAL, FLOAT and DOUBLE values are all stored in the database as
        <classname>java.lang.Double</classname> objects. Special values such
        as NaN and +-Infinity are also stored and supported. These values can
        be submitted to the database via JDBC PreparedStatement methods and
        are returned in <classname>ResultSet</classname> objects.</para>
      </section>

      <section>
        <title>Bit and Boolean Types</title>

        <para>In previous versions, BIT was simply an alias for BOOLEAN. In
        1.9.0 BIT is a single-bit bit map, while BIT(n) and BIT VARYING(n) are
        strings of bits..</para>

        <para>The primary representation of BOOLEAN column is
        <literal>'true'</literal> or <literal>'false'</literal> either as the
        boolean type or as strings when used from JDBC. This type of column
        can also be initialised using values of any numeric type. In this case
        <literal>0</literal> is translated to <literal>false</literal> and any
        other value such as 1 is translated to <literal>true</literal>.</para>

        <para>The BOOLEAN type conforms to the SQL standards and supports the
        UNDEFINED state in addition to TRUE or FALSE. NULL values are treated
        as undefined. The three-value logic is sometimes misunderstood. For
        example, x IN (1, 2, NULL) does not return true if x is NULL. See the
        test text file, TestSelfNot.txt, for some examples of queries and the
        expected results.</para>
      </section>

      <section>
        <title>Storage and Handling of Java Objects</title>

        <para>Any serializable JAVA Object can be inserted directly into a
        column of type OTHER using any variation of
        <methodname>PreparedStatement.setObject()</methodname> methods.</para>

        <para>For comparison purposes and in indexes, any two Java Objects are
        considered equal unless one of them is NULL. You cannot search for a
        specific object or perform a join on a column of type OTHER.</para>

        <para>Please note that HSQLDB is not an object-relational database.
        Java Objects can simply be stored internally and no operations should
        be performed on them other than assignment between columns of type
        OTHER or tests for NULL. Tests such as <literal>WHERE object1 =
        object2</literal>, or <literal>WHERE object1 = ? </literal>do not mean
        what you might expect, as any non-null object would satisfy such a
        tests. But <literal>WHERE object1 IS NOT NULL</literal> is perfectly
        acceptable.</para>

        <para>The engine does not allow normal column values to be assigned to
        Java Object columns (for example assigning an INTEGER or STRING to
        such a column with an SQL statement such as <literal>UPDATE mytable
        SET objectcol = intcol WHERE ...</literal>).</para>
      </section>

      <section>
        <title>Type Size, Precision and Scale</title>

        <para>In older version of HSQLDB, all table column type definitions
        with a column size, precision or scale qualifier were accepted and
        ignored. HSQLDB 1.8.0 enforced correctness but included an option to
        enforce the size, precision or scale.</para>

        <para>In 1.9.0, size, precision and scale qualifiers are always
        enforced.</para>

        <para>String types, including all BIT, BINARY and CHAR string types
        plus CLOB and BLOB, are generally defined with a size. If no size is
        specified, the default size is 1.</para>

        <para>TIME and TIMESTAMP types can be defined with a fractional second
        precision between 0 and 9. INTERVAL type definition may have precision
        and, in some cases, fraction second precision. DECIMAL and NUMERIC
        types may be defined with precision and scale. For all of these types
        a default precision or scale value is used if one is not
        specified.</para>

        <para>Values are be changed from one type to another in two different
        ways: by using explicit CAST expression or by implicit conversion used
        in assignment, comparison and aggregation.</para>

        <para>String values cannot be assigned to VARCHAR columns if they are
        longer than the defined type size. For CHARACTER columns, a long
        string can be inserted (with truncation) only if all the characters
        after the size are spaces. Shorter strings are padded with the space
        character when inserted into a CHARACTER column. Similar rules are
        applied to VARBINARY and BINARY columns. For BINARY columns, the
        padding and truncation rules are applied with zero bytes, instead of
        spaces.</para>

        <para>Explicit CAST of a value to a CHARACTER or VARCHAR type will
        result in forced truncation or padding. So a test such as
        <literal>CAST (mycol AS VARCHAR(2)) = 'xy'</literal> will find the
        values beginning with 'xy'. This is the equivalent of
        <literal>SUBSTRING(mycol FROM 1 FOR 2)= 'xy'</literal>.</para>

        <para>For all numeric types, the rules of explicit cast and implicit
        conversion are the same. If cast or conversion causes any digits to be
        lost from the fractional part, it can take place. If the
        non-fractional part of the value cannot be represented in the new
        type, cast or conversion cannot take place and will result in a data
        exception.</para>

        <para>There are special rules for DATE, TIME, TIMESTAMP and INTERVAL
        casts and conversions.</para>
      </section>
    </section>

    <section xml:id="sqlissies_seq_identitis-sect">
      <title>Sequences and Identity</title>

      <para>The SEQUENCE objects and IDENTITY columns are supported fully
      according to the latest SQL 200n Standard syntax.</para>

      <section>
        <title>Identity Auto-Increment Columns</title>

        <para>Each table can contain a single auto-increment column, known as
        the IDENTITY column. An IDENTITY column is a SMALLINT, INTEGER,
        BIGINT, DECIMAL or NUMERIC column with its value generated by a
        sequence generator.</para>

        <para>In HyperSQL 1.9.0, an IDENTITY column is not by default treated
        as the primary key for the table (as a result, multi-column primary
        keys are possible with an IDENTITY column present).</para>

        <para>The SQL standard syntax is used, which allows the initial value
        and other options to be specified.<programlisting>    &lt;colname&gt; INTEGER GENERATED { BY DEFAULT | ALWAYS} AS IDENTITY [( &lt;options&gt; )] [PRIMARY KEY]</programlisting></para>

        <para>When you add a new row to such a table using an <literal>INSERT
        INTO &lt;tablename&gt; ...; </literal>statement, you can use the NULL
        value for the IDENTITY column, which results in an auto-generated
        value for the column. The <literal>IDENTITY() </literal>function
        returns the last value inserted into any IDENTITY column by this
        connection. Use <literal>CALL IDENTITY(); </literal>as an SQL
        statement to retrieve this value. If you want to use the value for a
        field in a child table, you can use <literal>INSERT INTO
        &lt;childtable&gt; VALUES (...,IDENTITY(),...);</literal>. Both types
        of call to<literal> IDENTITY()</literal> must be made before any
        additional update or insert statements are issued on the
        database.</para>

        <para>The next IDENTITY value to be used can be set with following
        command: <programlisting>    ALTER TABLE ALTER COLUMN &lt;column name&gt; RESTART WITH &lt;new value&gt;;</programlisting>For
        backward compatibility, support has been retained for <literal>CREATE
        TABLE &lt;tablename&gt;(&lt;colname&gt; IDENTITY, ...)</literal> as a
        shortcut which defines the column both as an IDENTITY column and a
        PRIMARY KEY column.</para>
      </section>

      <section>
        <title>Sequences</title>

        <para>The SQL 200n syntax and usage is different from what is
        supported by many existing database engines. Sequences are created
        with the <literal>CREATE SEQUENCE</literal> command and their current
        value can be modified at any time with <literal>ALTER
        SEQUENCE</literal>. The next value for a sequence is retrieved with
        the <literal>NEXT VALUE FOR &lt;name&gt;</literal> expression. This
        expression can be used for inserting and updating table rows.</para>

        <example>
          <title>inserting the next sequence value into a table row</title>

          <programlisting>    INSERT INTO mytable VALUES 2, 'John', NEXT VALUE FOR mysequence;</programlisting>
        </example>

        <para>You can also use it in select statements. For example, if you
        want to number the returned rows of a SELECT in sequential order, you
        can use:</para>

        <example>
          <title>numbering returned rows of a SELECT in sequential
          order</title>

          <programlisting>    SELECT NEXT VALUE FOR mysequence, col1, col2 FROM mytable WHERE ...</programlisting>
        </example>

        <para>In version 1.9.0, the semantics of sequences is exactly as
        defined by SQL 200n. If you use the same sequence twice in the same
        row in an INSERT statement, you will get the same value as required by
        the Standard.</para>

        <para>You can query the SEQUENCES table for the next value that will
        be returned from any of the defined sequences. The SEQUENCE_NAME
        column contains the name and the NEXT_VALUE column contains the next
        value to be returned. Note that this is only for getting information
        and you should not do this for using the sequence value.</para>
      </section>
    </section>

    <section xml:id="sqlissues_trans_cc-sect">
      <title>Transactions and Concurrency Control</title>

      <para>Before version 1.9, HSQLDB supported READ UNCOMMITTED transaction
      isolation. At this isolation level, uncommitted changes made to the data
      by a session are visible to other, concurrent sessions. This is called
      the "dirty read" phenomenon.</para>

      <para>HyperSQL 2.0 supports 4 levels of transaction isolation: READ
      UNCOMMITTED, READ COMMITTED, REPEATABLE READ and SERIALIZABLE. It also
      supports two concurrency control modes, two-phased-locking (2PL) and
      multiversion concurrency control (MVCC). The isolation level is a
      property of each SQL session, so different sessions can have different
      isolation levels. The concurrency control strategy governs all the
      sessions and is set for the database, as opposed for individual
      sessions. Isolation levels above READ UNCOMMITTED avoid the "dirty read"
      phenomenon and do not read uncommitted changes made to rows by other
      transactions.</para>

      <section>
        <title>Two Phased Locking</title>

        <para>In the 2PL mode, each table that is read by a transaction is
        locked with a shared lock, and each table that is written to is locked
        with an exclusive lock. If two sessions read and modify different
        tables then both go through simultaneously. If one session tries to
        lock a table that has been exclusively locked by the other, the engine
        will put it in wait, or it will invalidate the action it is attempting
        to perform, depending on the locks.</para>

        <para>When a transaction is running in read-only mode (or the session
        is in read-only mode), then it will not lock the tables and will go
        ahead and complete regardless of what other transactions may do. The
        READ UNCOMMITTED isolation level can be used in this mode for
        read-only operations.</para>

        <para>If a table is read-only, it will not be locked by any
        transaction.</para>
      </section>

      <section>
        <title>MVCC</title>

        <para>In MVCC mode, there are no shared, read locks. Exclusive locks
        are used on individual rows, but their use is different. Transactions
        can read and modify the same table simultaneously, generally without
        waiting for other transactions.</para>

        <para>When transactions are running in READ COMMITTED mode, no
        conflict will occur. If a transaction that runs in this mode wants to
        modify a row that has been modified by another uncommitted
        transaction, then the engine puts the transaction in wait, until the
        other transaction has committed. The transaction then continues
        automatically.</para>

        <para>When transactions are running in REPEATABLE READ or SERIALIZABLE
        isolation modes, conflict can happen. There is no difference in
        operation between these two isolation modes. If a transaction that
        runs in this mode wants to modify a row that has been modified by
        another uncommitted transaction, the engine allows it to go ahead
        despite the conflict. When one of the conflicting sessions commits,
        the commit goes through. But when committing, the engine will
        invalidate the other, conflicting transaction and roll back all its
        changes.</para>

        <para>In this mode, READ UNCOMMITTED is promoted to READ COMMITTED, as
        the new architecture is based on multi-version rows for uncommitted
        data and more than one version may exist for some rows.</para>

        <para>In all isolation modes, when a transaction only reads data, then
        it will go ahead and complete regardless of what other transactions
        may do. This does not depend on the transaction being
        read-only.</para>
      </section>

      <section>
        <title>Commands</title>

        <para>The following SQL command switches the concurrency control mode
        for the database. It can be issued only when all sessions have been
        committed or rolled back.</para>

        <para><programlisting>SET DATABASE TRANSACTION CONTROL { LOCKS | MVCC }</programlisting>The
        default isolation level for a session is READ COMMITTED. This can be
        changed using the JDBC <classname>java.sql.Connection</classname>
        object and its <methodname>setTransactionIsolation(int
        level)</methodname> method. The session can be put in read-only mode
        using the <methodname>setReadOnly(boolean readOnly)</methodname>
        method. Both methods can be invoked only after a commit or a
        rollback.</para>

        <para>The isolation level and / or the read only mode of a transaction
        can be modified using the same SQL command. You can use the command to
        change only the isolation mode, only the read-only mode, or both at
        the same time. This command can be issued only after a commit or
        rollback.</para>

        <para><programlisting>SET TRANSACTION &lt;transaction characteristic&gt; [ &lt;comma&gt; &lt;transaction characteristic&gt; ]

&lt;transaction characteristic&gt; :=
{ ISOLATION LEVEL { READ COMMITTED | REPEATABLE READ | SERIALIZABLE } } | { READ ONLY | READ WRITE }
</programlisting>More on transactions</para>
      </section>
    </section>
  </chapter>

  <xi:include href="listeners.xml" />

  <xi:include href="unix.xml" />

  <chapter xml:id="advanced-chapt">
    <title xml:id="advanced-title">Advanced Topics</title>

    <info>
      <authorgroup>
        <author>
          <personname><firstname>Fred</firstname>
          <surname>Toussi</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Advanced</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="advanced_connections-sect">
      <title>Connections</title>

      <para>The normal method of accessing an HSQLDB database is via the JDBC
      Connection interface. An introduction to different methods of providing
      database services and accessing them can be found in the <link
      endterm="sqlissues-title" xlink:href="#sqlissues-chapt"></link> chapter.
      Details and examples of how to connect via JDBC are provided in our
      JavaDoc for <classname xlink:href="#JDBCConnection.html-link">
      JDBCConnection</classname>.</para>

      <para>A uniform method is used to distinguish between different types of
      connection. The common driver identifier is
      <literal>jdbc:hsqldb:</literal> followed by a protocol identifier
      (<literal>mem: file: res: hsql: http: hsqls: https:</literal>) then
      followed by host and port identifiers in the case of servers, then
      followed by database identifier. Additional property / value pairs can
      be appended to the end of the URL, separated with semicolons.</para>

      <table frame="all" pgwide="1" tocentry="1">
        <title>Hsqldb URL Components</title>

        <tgroup align="left" cols="3">
          <colspec colname="c1" />

          <colspec colname="c2" />

          <colspec colname="c3" />

          <thead>
            <row>
              <entry>Driver and Protocol</entry>

              <entry>Host and Port</entry>

              <entry>Database</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><simplelist type="vert">
                  <member><literal>jdbc:hsqldb:mem:</literal></member>
                </simplelist></entry>

              <entry>not available</entry>

              <entry><simplelist type="vert">
                  <member><literal>accounts</literal></member>
                </simplelist></entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1"><para>Lowercase, single-word
              identifier creates the in-memory database when the first
              connection is made. Subsequent use of the same Connection URL
              connects to the existing DB.</para> <para>The old form for the
              URL, <literal>jdbc:hsqldb:.</literal> creates or connects to the
              same database as the new form for the URL,
              <literal>jdbc:hsqldb:mem:.</literal></para></entry>
            </row>

            <row>
              <entry><simplelist type="vert">
                  <member><literal>jdbc:hsqldb:file:</literal></member>
                </simplelist></entry>

              <entry>not available</entry>

              <entry><simplelist type="vert">
                  <member><filename>mydb</filename></member>

                  <member><filename>/opt/db/accounts</filename></member>

                  <member><filename>C:/data/mydb</filename></member>
                </simplelist></entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1"><para>The file path specifies
              the database file. In the above examples the first one refers to
              a set of mydb.* files in the directory where the
              <literal>java</literal>command for running the application was
              issued. The second and third examples refer to absolute paths on
              the host machine.</para></entry>
            </row>

            <row>
              <entry><simplelist type="vert">
                  <member><literal>jdbc:hsqldb:res:</literal></member>
                </simplelist></entry>

              <entry>not available</entry>

              <entry><simplelist type="vert">
                  <member><filename>/adirectory/dbname</filename></member>
                </simplelist></entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1">Database files can be loaded
              from one of the jars specified as part of the
              <literal>Java</literal> command the same way as resource files
              are accessed in Java programs. The
              <literal>/adirectory</literal> above stands for a directory in
              one of the jars.</entry>
            </row>

            <row>
              <entry><simplelist type="vert">
                  <member><literal>jdbc:hsqldb:hsql:</literal></member>

                  <member><literal>jdbc:hsqldb:hsqls:</literal></member>

                  <member><literal>jdbc:hsqldb:http:</literal></member>

                  <member><literal>jdbc:hsqldb:https:</literal></member>
                </simplelist></entry>

              <entry><simplelist type="vert">
                  <member><literal>//localhost</literal></member>

                  <member><literal>//192.0.0.10:9500</literal></member>

                  <member><literal>//dbserver.somedomain.com</literal></member>
                </simplelist></entry>

              <entry><simplelist type="vert">
                  <member><literal>/an_alias</literal></member>

                  <member><literal>/enrollments</literal></member>

                  <member><literal>/quickdb</literal></member>
                </simplelist></entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1"><para>The host and port specify
              the IP address or host name of the server and an optional port
              number. The database to connect to is specified by an alias.
              This alias is a lowercase string defined in the
              <filename>server.properties</filename> file to refer to an
              actual database on the file system of the server or a transient,
              in-memory database on the server. The following example lines in
              <filename>server.properties </filename> or
              <filename>webserver.properties</filename> define the database
              aliases listed above and accessible to clients to refer to
              different file and in-memory databases.</para> <para>The old
              form for the server URL, e.g.,
              <literal>jdbc:hsqldb:hsql//localhost</literal> connects to the
              same database as the new form for the URL,
              <literal>jdbc:hsqldb:hsql//localhost/</literal> where the alias
              is a zero length string. In the example below, the database
              catalog <literal>lists.*</literal> in the
              <literal>/home/dbmaster/</literal> directory is associated with
              the empty alias:</para> <programlisting>    database.3=/home/dbmaster/lists
    dbname.3=</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section xml:id="conn_props-sect">
        <title>Connection properties</title>

        <para>Each new JDBC Connection to a database can specify connection
        properties. The properties <property>user</property> and
        <property>password</property> are always required. In 1.9.0 the
        following optional properties can also be used.</para>

        <para>Connection properties are specified either by establishing the
        connection via the:</para>

        <programlisting>    DriverManager.getConnection (String url, Properties info);</programlisting>

        <para>method call, or the property can be appended to the full
        Connection URL.</para>

        <table frame="all" pgwide="1" tocentry="1">
          <title>Connection Properties</title>

          <tgroup align="left" cols="3">
            <colspec colname="c1" colwidth="7cm" />

            <colspec colname="c2" colwidth="1.5cm" />

            <colspec colname="c3" />

            <tbody valign="top">
              <row>
                <entry><property>get_column_name</property></entry>

                <entry><literal>true</literal></entry>

                <entry>column name in ResultSet</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>This property is used
                for compatibility with other JDBC driver implementations. When
                true (the default), <methodname>ResultSet.getColumnName(int
                c)</methodname> returns the underlying column name</para>
                <para>When false, the above method returns the same value as
                <methodname>ResultSet.getColumnLabel(int column)</methodname>
                Example below:</para> <programlisting>    jdbc:hsqldb:hsql://localhost/enrollments;get_column_name=false</programlisting>
                <para>When a ResultSet is used inside a user-defined stored
                procedure, the default, true, is always used for this
                property.</para></entry>
              </row>

              <row>
                <entry><property>ifexists</property></entry>

                <entry><literal>false</literal></entry>

                <entry>connect only if database already exists</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>Has an effect only with
                <glossterm>mem:</glossterm> and <glossterm>file:</glossterm>
                database. When true, will not create a new database if one
                does not already exist for the URL.</para> <para>When false
                (the default), a new <glossterm>mem:</glossterm> or
                <glossterm>file:</glossterm> database will be created if it
                does not exist.</para> <para>Setting the property to true is
                useful when troubleshooting as no database is created if the
                URL is malformed. Example below:</para> <programlisting>    jdbc:hsqldb:file:enrollments;ifexists=true</programlisting></entry>
              </row>

              <row>
                <entry><property>shutdown</property></entry>

                <entry><literal>false</literal></entry>

                <entry>shut down the database when the last connection is
                closed</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>If this property is
                <literal>true</literal>, when the last connection to a
                database is closed, the database is automatically shut down.
                The property takes effect only when the first connection is
                made to the database. This means the connection that opens the
                database. It has no effect if used with subsequent
                connections.</para> <para>This command has two uses. One is
                for test suites, where connections to the database are made
                from one JVM context, immediately followed by another context.
                The other use is for applications where it is not easy to
                configure the environment to shutdown the database. Examples
                reported by users include web application servers, where the
                closing of the last connection coincides with the web app
                being shut down.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In addition, when a connection to an
        <glossterm>in-process</glossterm> database creates a new database, or
        opens an existing database (i.e. it is the first connection made to
        the database by the application), all the user-defined database
        properties can be specified as URL properties. This can be used to
        specify properties to enforce more strict SQL adherence, or to change
        cache_scale or similar properties before the database files are
        created. However, for new databases, it is recommended to use the SET
        PROPERTY command for such settings.</para>
      </section>
    </section>

    <section xml:id="advanced_dbprops-sect">
      <title>Database Properties</title>

      <para>The database engine generates a <literal>.properties</literal>
      file for each file catalog. Most of these properties can be changed via
      SQL commands. Some properties are only changed by the engine. There are,
      however, a few properties than can be modified by the user while the
      database is shutdown.</para>

      <section>
        <title>Individual Database Properties</title>

        <para>Each database has its own <filename>&lt;dbname&gt;.properties
        </filename> file as part of a small group of files which also includes
        <filename>&lt;dbname&gt;.script</filename> and
        <filename>&lt;dbname&gt;.data</filename>. The properties files contain
        key/value pairs for some important settings.</para>

        <para>In version 1.9.0 an SQL command allows most database properties
        to be modified as follows:</para>

        <programlisting>    SET PROPERTY "property_name" property_value</programlisting>

        <para>Properties that can be modified via <literal>SET
        PROPERTY</literal> are indicated in the table below. Other properties
        are indicated as <literal>PROPERTIES FILE ONLY</literal> and can be
        modified only by editing the .properties file after a shutdown and
        before a restart. Only the user-defined values listed below should
        ever be modified. Changing any other value could result in unexpected
        malfunction in database operations. Most of these values have been
        introduced for the new features since 1.7.0:</para>

        <table frame="all" pgwide="1" tocentry="1">
          <title>Database-specific Property File Properties</title>

          <tgroup align="left" cols="3">
            <colspec colname="c1" colwidth="6.5cm" />

            <colspec colname="c2" colwidth="1.5cm" />

            <colspec colname="c3" />

            <thead>
              <row>
                <entry>Value</entry>

                <entry>Default</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody valign="top">
              <row>
                <entry><property>readonly</property></entry>

                <entry><literal>false</literal></entry>

                <entry>whole database is read-only</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>When true, the database
                cannot be modified in use. This setting can be changed to
                <literal>true</literal> if the database is to be opened from a
                CD. Prior to changing this setting, the database should be
                closed with the <literal>SHUTDOWN COMPACT</literal> command to
                ensure consistency and compactness of the data.
                <literal>(PROPERTIES FILE ONLY) but can be used as a
                connection property to open a normal database as
                readonly.</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.files_readonly</property></entry>

                <entry><literal>false</literal></entry>

                <entry>database files will not be written to</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>When true, data in
                MEMORY tables can be modified and new MEMORY tables can be
                added. However, these changes are not saved when the database
                is shutdown. CACHED and TEXT tables are always readonly when
                this setting is true. <literal>(PROPERTIES FILE
                ONLY)</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.cache_file_scale</property></entry>

                <entry><literal>1</literal></entry>

                <entry>Set larger data file limits. Once set, the limit will
                go up to 8GB.</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>This property can be set
                to 8 to increase the size limit of the .data file from 2GB to
                8GB. To apply the change to an existing database, SHUTDOWN
                SCRIPT should be performed first, then the property=value line
                below should be added to the .properties file before reopening
                the database. <literal>(SET
                PROPERTY)</literal><programlisting>hsqldb.cache_file_scale=8</programlisting></para>
                <para>The property can be set with the SQL command (as opposed
                to changing the value in the properties file) when the
                database has no CACHED tables (e.g. a new database).
                <literal>(SET PROPERTY)</literal></para></entry>
              </row>

              <row>
                <entry><property>sql.enforce_size</property></entry>

                <entry><literal>false</literal></entry>

                <entry>trimming and padding string columns</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>This property is no
                longer supported. Use sql.enforce_strict_size</para></entry>
              </row>

              <row>
                <entry><property>sql.enforce_strict_size</property></entry>

                <entry><literal>false</literal></entry>

                <entry>size enforcement and padding string columns</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>Conforms to SQL
                standards for size and precision of data types. When true, all
                CHARACTER, VARCHAR, NUMERIC and DECIMAL values that are in a
                row affected by an INSERT INTO or UPDATE statement are checked
                against the size specified in the SQL table definition. An
                exception is thrown if the value is too long. Also all
                CHARACTER values that are shorter than the specified size are
                padded with spaces. TIMESTAMP(0) and TIMESTAMP(6) are also
                allowed in order to specify the subsecond resolution of the
                values. When false (default), stores the exact string that is
                inserted. <literal> (SET PROPERTY)</literal></para></entry>
              </row>

              <row>
                <entry><property>sql.tx_no_multi_rewrite</property></entry>

                <entry><literal>false</literal></entry>

                <entry>transaction management</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>In the default
                READ_UNCOMMITED mode, a transaction can write over rows
                inserted or updated by another uncommitted
                transaction.<literal> Setting this property to true will raise
                an exception when such a write is attempted (SET
                PROPERTY)</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.cache_scale</property></entry>

                <entry><literal>14</literal></entry>

                <entry>memory cache exponent</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>Indicates the maximum
                number of rows of cached tables that are held in memory,
                calculated as 3 *(2**value) (three multiplied by (two to the
                power value)). The default results in up to 3*16384 rows from
                all cached tables being held in memory at any time.</para>
                <para>The value can range between 8-18. <literal>(SET
                PROPERTY)</literal>. If the value is set via SET PROPERTY then
                it becomes effective after the next database SHUTDOWN or
                CHECKPOINT. <literal>(SET PROPERTY)</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.cache_size_scale</property></entry>

                <entry><literal>10</literal></entry>

                <entry>memory cache exponent</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>Indicates the average
                size of each row in the memory cache used with cached tables,
                calculated as 2**value (two to the power value). This result
                value is multiplied by the maximum number of rows defined by
                <property>hsqldb.cache_scale</property> to form the maximum
                number of bytes for all the rows in memory cache. The default
                results in 1024 bytes per row. This default, combined with the
                default number of rows, results in approximately 50MB of the
                .data file to be stored in the memory cache.</para> <para>The
                value can range between 6-20. <literal>(SET
                PROPERTY)</literal>. If the value is set via SET PROPERTY then
                it becomes effective after the next database SHUTDOWN or
                CHECKPOINT. <literal>(SET PROPERTY)</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.log_size</property></entry>

                <entry><literal>200</literal></entry>

                <entry>size of log when checkpoint is performed</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>The value is the size in
                megabytes that the <literal>.log</literal> file can reach
                before an automatic checkpoint occurs. A checkpoint and
                rewrites the <literal>.script</literal> file and clears the
                <literal>.log</literal> file. The value is changed via the
                <literal>SET LOGSIZE nnn</literal> SQL command.</para></entry>
              </row>

              <row>
                <entry><property>runtime.gc_interval</property></entry>

                <entry><literal>0</literal></entry>

                <entry>forced garbage collection</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>This setting forces
                garbage collection each time a set number of result set row or
                cache row objects are created. The default, "0" means no
                garbage collection is forced by the program.</para> <para>This
                should not be set when the database engine is acting as a
                server inside an exclusive JVM. The setting can be useful when
                the database is used <glossterm>in-process</glossterm> with
                the application with some Java Runtime Environments (JRE's).
                Some JRE's increase the size of the memory heap before doing
                any automatic garbage collection. This setting would prevent
                any unnecessary enlargement of the heap. Typical values for
                this setting would probably be between 10,000 to 100,000.
                <literal>(PROPERTIES FILE ONLY)</literal></para></entry>
              </row>

              <row>
                <entry><property>hsqldb.nio_data_file</property></entry>

                <entry><literal>true</literal></entry>

                <entry>use of nio access methods for the .data file</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>When HSQLDB is compiled
                and run in Java 1.4 or higher, setting this property to
                <literal>false</literal> will avoid the use of nio access
                methods, resulting in somewhat reduced speed. If the data file
                is larger than 256MB when it is first opened, nio access
                methods are not used. Also, if the file gets larger than the
                amount of available computer memory that needs to be allocated
                for nio access, non-nio access methods are used.</para>
                <para><literal>(SET PROPERTY)</literal>. If used before
                defining any CACHED table, it applies immediately, otherwise
                it comes into effect after a SHUTDOWN and restart or
                CHECKPOINT.</para></entry>
              </row>

              <row>
                <entry><property>hsqldb.default_table_type</property></entry>

                <entry><literal>memory</literal></entry>

                <entry>type of table created with unqualified CREATE
                TABLE</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>The CREATE TABLE command
                results in a MEMORY table by default. Setting the value
                "cached" for this property will result in a cached table by
                default. The qualified forms such as CREATE MEMORY TABLE or
                CREATE CACHED TABLE are not affected at all by this property.
                This value is changed via the <literal>SET DEFAULT TABLE
                TYPE</literal> SQL command.</para></entry>
              </row>

              <row>
                <entry><property>hsqldb.applog</property></entry>

                <entry><literal>0</literal></entry>

                <entry>application logging level</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>The default level 0
                indicates no logging. Level 1 results in events related to
                persistence to be logged, including any failures. The events
                are logged in a file ending with ".app.log". This value is
                changed via the <literal>SET DATABASE EVENT LOG
                LEVEL</literal> SQL command.</para></entry>
              </row>

              <row>
                <entry><property>textdb.*</property></entry>

                <entry><literal>0</literal></entry>

                <entry>default properties for new text tables</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1"><para>Properties that override
                the database engine defaults for newly created text tables.
                Settings in the text table <literal>SET &lt;tablename&gt;
                SOURCE &lt;source string&gt; </literal>command override both
                the engine defaults and the database properties defaults.
                Individual <property>textdb.*</property> properties are listed
                in the <link endterm="texttables-title"
                xlink:href="#texttables-chapt"></link> chapter. <literal>(SET
                PROPERTY)</literal></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>When connecting to an <glossterm>in-process</glossterm> database
        creates a new database, or opens an existing database (i.e. it is the
        first connection made to the database by the application), all the
        user-defined database properties listed in this section can be
        specified as URL properties.</para>

        <simpara>The property sql.compare_in_locale=true is no longer
        supported. If the line exists in a .properties file, it will switch
        the database to the collation for the current default. See the
        <remark>Restore the &lt;link endterm="collation-title"
        xlink:href="#collation-sect"/&gt; link, once we have a collation
        description again.</remark> command.</simpara>

        <simpara>When HSQLDB is used in OpenOffice.org, some property values
        will have a different default. The properties and values
        are:</simpara>

        <simpara>hsqldb.default_table_type=cached hsqldb.cache_scale=13
        hsqldb.log_size=10; hsqldb.nio_data_file=false
        sql.enforce_strict_size=true</simpara>
      </section>
    </section>

    <section xml:id="advanced_sqlcmd_dbprops-sect">
      <title>SQL Commands for Database Properties</title>

      <para>There are some database properties that are set with dedicated SQL
      commands beginning with SET.<programlisting>SET WRITE_DELAY {{TRUE | FALSE} | &lt;seconds&gt; | &lt;milliseconds&gt; MILLIS</programlisting>The
      default is TRUE and indicates that the changes to the database that have
      been logged are synched to the file system once every 10 seconds. FALSE
      indicates there is no delay and at each commit a file synch operation is
      performed. Numeric values from 0 can also be specified for the synch
      delay.</para>

      <para>The purpose of this command is to control the amount of data loss
      in case of a total system crash. A delay of 1 second means at most the
      data written to disk during the last second before the crash is lost.
      All data written prior to this has been synced and should be
      recoverable</para>

      <para>This setting should be specified on the basis of the reliability
      of the hardware used for running the database engine, the type of disk
      system used, the possibility of power failure etc. Also the nature of
      the data stored should be considered.</para>

      <para>In general, when the system is very reliable, the setting can be
      left to the default. If it is not very reliable, or the data is critical
      a setting of 1 or 2 seconds would suffice. Only in the worst case
      scenario or with the most critical data should a setting of 0 or FALSE
      be specified as this will slow the engine down to the speed at which the
      file synch operation can be performed by the disk subsystem.</para>

      <para>Values down to 10 milliseconds can be specified by adding MILLIS
      to the command, but in practice a delay of 100 milliseconds provides
      99.99999% reliability with an average one system crash per 6
      days.</para>

      <para><programlisting>SET LOG_SIZE &lt;numeric value&gt;</programlisting>The
      engine writes out a log of all the changes to the database as they
      occur. This log is synched to the disk based on the WRITE_DELAY property
      above. The log is never reused unless there is an abnormal termination,
      i.e. the database process is terminated without SHUTDOWN, or it was
      terminated using SHUTDOWN IMMEDIATELY.</para>

      <para>The default maximum size of the .log file is 200 MB. When the
      maximum size is reached, a CHECKPOINT operation is performed. This
      operation will save the other database files in a consistent state and
      delete the old log. A value of 0 indicates no limit for the .log
      file.</para>

      <para><programlisting>SET CHECKPOINT DEFRAG &lt;numeric value&gt;</programlisting>When
      rows in CACHED tables are updated or deleted, the spaces are mostly
      reused. However, in time, some unused spaces are left in the .data file,
      especially when large tables are dropped or their structure is
      modified.</para>

      <para>A CHECKPOINT operation does not normally reclaim the empty spaces,
      whereas CHECKPOINT DEFRAG always does.</para>

      <para>This property determines when a normal CHECKPOINT, whether
      initiated by an administrator or when the size of the log exceeds its
      limit.</para>

      <para>The numeric value is the number of megabytes of recorded empty
      spaces in the .data file that would force a DEFRAG operation. Low values
      result in more frequent DEFRAG operations. A value of 0 indicates no
      automatic DEFRAG is performed. The default is 200 megabytes of lost
      space.</para>

      <para><programlisting>SET REFERENTIAL INTEGRITY { TRUE | FALSE }</programlisting>This
      is TRUE by default. If bulk data needs to be loaded into the database,
      this property can be set FALSE for the duration of bulk load operation.
      This allows loading data for related tables in any order. The property
      should be set TRUE after bulk load. If the loaded data is not guaranteed
      to conform to the referential integrity constraints, SQL queries should
      be run after loading to identify and modify any non-conforming
      rows.</para>

      <para><programlisting>SET DEFAULT TABLE TYPE { CACHED | MEMORY }</programlisting></para>

      <para>Sets the type of table created when the next CREATE TABLE
      statement is executed.</para>

      <para><programlisting>SET DATABASE EVENT LOG LEVEL { 0 | 1 | 2 }</programlisting>Sets
      the level of detail for events stored in the database applog. Zero
      indicates no logging. One indicates logging for errors only. Two
      indicates logging for all the main events, which include operations on
      database files.</para>

      <para></para>
    </section>
  </chapter>

  <chapter xml:id="deployment-chapt">
    <title>Deployment Issues</title>

    <info>
      <authorgroup>
        <author>
          <personname><firstname>Fred</firstname>
          <surname>Toussi</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Guide</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2005-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="deploymen_modes-sect">
      <title>Mode of Operation and Tables</title>

      <para>HSQLDB has many modes of operation and features that allow it to
      be used in very different scenarios. Levels of memory usage, speed and
      accessibility by different applications are influenced by how HSQLDB is
      deployed.</para>

      <section>
        <title>Mode of Operation</title>

        <para>The decision to run HSQLDB as a separate server process or as an
        <glossterm>in-process</glossterm> database should be based on the
        following:</para>

        <para><itemizedlist>
            <listitem>
              <para>When HSQLDB is run as a server on a separate machine, it
              is isolated from hardware failures and crashes on the hosts
              running the application.</para>
            </listitem>

            <listitem>
              <para>When HSQLDB is run as a server on the same machine, it is
              isolated from application crashes and memory leaks.</para>
            </listitem>

            <listitem>
              <para>Server connections are slower than
              <glossterm>in-process</glossterm> connections due to the
              overhead of streaming the data for each JDBC call.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Tables</title>

        <para>TEXT tables are designed for special applications where the data
        has to be in an interchangeable format, such as CSV. TEXT tables
        should not be used for routine storage of data.</para>

        <para>MEMORY tables and CACHED tables are generally used for data
        storage. The difference between the two is as follows:</para>

        <para><itemizedlist>
            <listitem>
              <para>The data for all MEMORY tables is read from the .script
              file when the database is started and stored in memory. In
              contrast the data for cached tables is not read into memory
              until the table is accessed. Furthermore, only part of the data
              for each CACHED table is held in memory, allowing tables with
              more data than can be held in memory.</para>
            </listitem>

            <listitem>
              <para>When the database is shutdown in the normal way, all the
              data for MEMORY tables is written out to the disk. In
              comparison, the data in CACHED tables that has changed is
              written out at shutdown, plus a compressed backup of all the
              data in all cached tables.</para>
            </listitem>

            <listitem>
              <para>The size and capacity of the data cache for all the CACHED
              tables is configurable. This makes it possible to allow all the
              data in CACHED tables to be cached in memory. In this case,
              speed of access is good, but slightly slower than MEMORY
              tables.</para>
            </listitem>

            <listitem>
              <para>For normal applications it is recommended that MEMORY
              tables are used for small amounts of data, leaving CACHED tables
              for large data sets. For special applications in which speed is
              paramount and a large amount of free memory is available, MEMORY
              tables can be used for large tables as well.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Large Objects</title>

        <para>JDBC clobs are supported as columns of the type LONGVARCHAR.
        JDBC Blobs are supported as columns of the type LONGVARBINARY. When
        large objects (LONGVARCHAR, LONGVARBINARY, OBJECT) are stored with
        table definitions that contain several normal fields, it is better to
        use two tables instead. The first table to contain the normal fields
        and the second table to contain the large object plus an identity
        field. Using this method has two benefits. (a) The first table can
        usually be created as a MEMORY table while only the second table is a
        CACHED table. (b) The large objects can be retrieved individually
        using their identity, instead of getting loaded into memory for
        finding the rows during query processing. An example of two tables and
        a select query that exploits the separation between the two
        follows:</para>

        <informalexample>
          <programlisting>CREATE MEMORY TABLE MAINTABLE(MAINID INTEGER, ......);
CREATE CACHED TABLE LOBTABLE(LOBID INTEGER, LOBDATA LONGVARBINARY);
SELECT * FROM (SELECT * FROM MAINTABLE &lt;join any other table&gt; WHERE &lt;various conditions apply&gt;) JOIN LOBTABLE ON MAINID=LOBID;</programlisting>
        </informalexample>

        <para>The inner SELECT finds the required rows without reference to
        the LOBTABLE and when it has found all the rows, retrieves the
        required large objects from the LOBTABLE.</para>
      </section>

      <section>
        <title>Deployment context</title>

        <para>The files used for storing HSQLDB database data are all in the
        same directory. New files are always created and deleted by the
        database engine. Two simple principles must be observed:</para>

        <itemizedlist>
          <listitem>
            <para>The Java process running HSQLDB must have full privileges on
            the directory where the files are stored. This include create and
            delete privileges.</para>
          </listitem>

          <listitem>
            <para>The file system must have enough spare room both for the
            'permanent' and 'temporary' files. The default maximum size of the
            .log file is 200MB. The .data file can grow to up to 8GB. The
            .backup file can be up to 50% of the .data file. The temporary
            files created at the time of a SHUTDOWN can be equal in size to
            the .script file and the .data file.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="deployment_mem_disk-sect">
      <title>Memory and Disk Use</title>

      <para>Memory used by the program can be thought of as two distinct
      pools: memory used for table data, and memory used for building result
      sets and other internal operations. In addition, when transactions are
      used, memory is utilised for storing the information needed for a
      rollback.</para>

      <para>The memory used for a MEMORY table is the sum of memory used by
      each row. Each MEMORY table row is a Java object that has 2 int or
      reference variables. It contains an array of objects for the fields in
      the row. Each field is an object such as <classname>Integer</classname>,
      <classname>Long</classname>, <classname>String</classname>, etc. In
      addition each index on the table adds a node object to the row. Each
      node object has 6 int or reference variables. As a result, a table with
      just one column of type INTEGER will have four objects per row, with a
      total of 10 variables of 4 bytes each - currently taking up 80 bytes per
      row. Beyond this, each extra column in the table adds at least a few
      bytes to the size of each row.</para>

      <para>All the rows in the result set are built in memory, so very large
      result sets may not be possible. In server mode databases, the result
      set memory is released from the server once the database server has
      returned the result set. <glossterm>in-process</glossterm> databases
      release the memory when the application program releases the
      <classname>java.sql.ResultSet</classname> object. Server modes require
      additional memory for returning result sets, as they convert the full
      result set into an array of bytes which is then transmitted to the
      client.</para>

      <para>When UPDATE and DELETE queries are performed on CACHED tables, the
      full set of rows that are affected, including those affected due to ON
      UPDATE actions, is held in memory for the duration of the operation.
      This means it may not be possible to perform deletes or updates
      involving very large numbers of rows of CACHED tables. Such operations
      should be performed in smaller sets.</para>

      <para>When transactions support is enabled with SET AUTOCOMMIT OFF,
      lists of all insert, delete or update operations are stored in memory so
      that they can be undone when ROLLBACK is issued. Transactions that span
      hundreds of modification to data will take up a lot of memory until the
      next COMMIT or ROLLBACK clears the list.</para>

      <para>Most JVM implementations allocate up to a maximum amount of memory
      (usually 64 MB by default). This amount is generally not adequate when
      large memory tables are used, or when the average size of rows in cached
      tables is larger than a few hundred bytes. The maximum amount of
      allocated memory can be set on the java ... command line that is used
      for running HSQLDB. For example, with Sun JVM version 1.3.0 the
      parameter -Xmx256m increases the amount to 256 MB.</para>

      <para>By default, all the rows in the result set are built in memory, so
      very large result sets may not be possible. In server mode databases,
      the result set memory is released from the server once the database
      server has returned the result set. <glossterm>in-process</glossterm>
      databases release the memory when the application program releases the
      <classname>java.sql.ResultSet</classname> object. Server modes require
      additional memory for returning result sets, as they convert the full
      result set into an array of bytes which is then transmitted to the
      client.</para>

      <para>**todo** updates to cover new large result support</para>

      <para>1.9.0 uses a fast cache for immutable objects such as Integer or
      String that are stored in the database. In most circumstances, this
      reduces the memory footprint still further as fewer copies of the most
      frequently-used objects are kept in memory.</para>

      <section>
        <title>Cache Memory Allocation</title>

        <para>With CACHED tables, the data is stored on disk and only up to a
        maximum number of rows are held in memory at any time. The default is
        up to 3*16384 rows. The <property>hsqldb.cache_scale</property>
        database property can be set to alter this amount. As any random
        subset of the rows in any of the CACHED tables can be held in the
        cache, the amount of memory needed by cached rows can reach the sum of
        the rows containing the largest field data. For example if a table
        with 100,000 rows contains 40,000 rows with 1,000 bytes of data in
        each row and 60,000 rows with 100 bytes in each, the cache can grow to
        contain nearly 50,000 rows, including all the 40,000 larger
        rows.</para>

        <para>An additional property,
        <property>hsqldb.cache_size_scale</property> can be used in
        conjunction with the <property>hsqldb.cache_scale</property> property.
        This puts a limit in bytes on the total size of rows that are cached.
        When the default values is used for both properties, the limit on the
        total size of rows is approximately 50MB. (This is the size of binary
        images of the rows and indexes. It translates to more actual memory,
        typically 2-4 times, used for the cache because the data is
        represented by Java objects.)</para>

        <para>If memory is limited, the
        <property>hsqldb.cache_scale</property> or
        <property>hsqldb.cache_size_scale</property> database properties can
        be reduced. In the example above, if the
        <property>hsqldb.cache_size_scale</property> is reduced from 10 to 8,
        then the total binary size limit is reduced from 50MB to 12.5 MB. This
        will allow the number of cached rows to reach 50,000 small rows, but
        only 12,500 of the larger rows.</para>
      </section>
    </section>

    <section xml:id="deployment_conns-sect">
      <title>Managing Database Connections</title>

      <para>In all running modes (server or <glossterm>in-process</glossterm>)
      multiple connections to the database engine are supported.
      <glossterm>in-process</glossterm> (standalone) mode supports connections
      from the client in the same Java Virtual Machine, while server modes
      support connections over the network from several different
      clients.</para>

      <para>Connection pooling software can be used to connect to the database
      but it is not generally necessary. With other database engines,
      connection pools are used for reasons that may not apply to
      HSQLDB.</para>

      <itemizedlist>
        <listitem>
          <para>To allow new queries to be performed while a time-consuming
          query is being performed in the background. This is not possible
          with HSQLDB 1.9.0 as it blocks while performing the first query and
          deals with the next query once it has finished it. This capability
          is under development and will be introduced in a future
          version.</para>
        </listitem>

        <listitem>
          <para>To limit the maximum number of simultaneous connections to the
          database for performance reasons. With HSQLDB this can be useful
          only if your application is designed in a way that opens and closes
          connections for each small task.</para>
        </listitem>

        <listitem>
          <para>To control transactions in a multi-threaded application. This
          can be useful with HSQLDB as well. For example, in a web
          application, a transaction may involve some processing between the
          queries or user action across web pages. A separate connection
          should be used for each HTTP session so that the work can be
          committed when completed or rolled back otherwise. Although this
          usage cannot be applied to most other database engines, HSQLDB is
          perfectly capable of handling over 100 simultaneous HTTP sessions as
          individual JDBC connections.</para>
        </listitem>
      </itemizedlist>

      <para>An application that is not both multi-threaded and transactional,
      such as an application for recording user login and logout actions, does
      not need more than one connection. The connection can stay open
      indefinitely and reopened only when it is dropped due to network
      problems.</para>

      <para>When using an <glossterm>in-process</glossterm> database with
      versions prior to 1.7.2 the application program had to keep at least one
      connection to the database open, otherwise the database would have been
      closed and further attempts to create connections could fail. This is
      not necessary since 1.7.2, which does not automatically close an
      <glossterm>in-process</glossterm> database that is opened by
      establishing a connection. An explicit SHUTDOWN command, with or without
      an argument, is required to close the database. In version 1.9.0 a
      connection property can be used to revert to the old behaviour.</para>

      <para>When using a server database (and to some extent, an
      <glossterm>in-process</glossterm> database), care must be taken to avoid
      creating and dropping JDBC Connections too frequently. Failure to
      observe this will result in unsuccessful connection attempts when the
      application is under heavy load.</para>
    </section>

    <section xml:id="deployment_upgrade-sect">
      <title>Upgrading Databases</title>

      <para>Any database that is not produced with the release version of
      HSQLDB 1.9.0 must be upgraded to this version. Some catalogs created
      with 1.8.0 can be upgraded simply by opening with HyperSQL 1.9.0. When
      this is not possible due to errors, the rest of the procedures below
      should be followed.</para>

      <para>Once a database is upgraded to 1.9.0, it can no longer be used
      with previous versions of HSQLDB.</para>

      <section xml:id="upgrade_via_script-sect">
        <title xml:id="upgrade_via_script-title">Upgrading From Older
        Versions</title>

        <para>There may be some potential legacy issues in the upgrade from
        very old versions which should be resolved by editing the
        <literal>.script</literal> file:</para>

        <itemizedlist>
          <listitem>
            <para>Version 1.9.0 does not accept duplicate names for table
            columns that were allowed before 1.7.0.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not accept duplicate names for indexes
            that were allowed before 1.7.2.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not create the same type of index for
            foreign keys as versions before 1.7.2.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not accept table or column names that are
            SQL reserved keywords without double quoting.</para>
          </listitem>
        </itemizedlist>

        <para>To upgrade from 1.7.2, 1.7.3 or 1.8.0 simply issue the SET
        SCRIPTFORMAT TEXT and SHUTDOWN SCRIPT commands with the old version,
        then open with the new version of the engine. The upgrade is then
        complete.</para>

        <para>To upgrade from older version database files (1.7.1 and older)
        that do not contain CACHED tables, simply SHUTDOWN with the older
        version and open with the new version. If there is any error in the
        <literal>.logs</literal> or <literal>.script</literal> file, try again
        after editing the <literal>.logs</literal> or
        <literal>.script</literal> file.</para>

        <para>To upgrade from older version database files (1.7.1 and older)
        that contain CACHED tables, use the SCRIPT procedure below. In all
        versions of HSQLDB, the <literal>SCRIPT 'filename'</literal> command
        (used as an SQL statement) allows you to save a full record of your
        database, including database object definitions and data, to a file of
        your choice. You can export a script file using the old version of the
        database engine and open the script as a database with 1.9.0.</para>

        <procedure>
          <title>Upgrade Using SCRIPT procedure</title>

          <step>
            <para>Open the original database in the old version of
            DatabaseManager</para>
          </step>

          <step>
            <para>Issue the SCRIPT command, for example <literal>SCRIPT
            'newversion.script'</literal> to create a script file containing a
            copy of the database.</para>
          </step>

          <step>
            <para>SHUTDOWN this database.</para>
          </step>

          <step>
            <para>Copy the original <literal>.properties</literal> file into
            <filename>newversion.properties</filename> in the same directory
            as <filename>newversion.script</filename></para>
          </step>

          <step>
            <para>Try to open the new database <filename>newversion</filename>
            using DatabaseManager.</para>
          </step>

          <step>
            <para>If there is any inconsistency in the data, the script line
            number is reported on the console and the opening process is
            aborted. Edit and correct any problems in the
            <filename>newversion.script</filename> before attempting to open
            again. Use the guidelines in the next section (Manual Changes to
            the <literal>.script</literal> File). Use a programming editor
            that is capable of handling very large files and does not wrap
            long lines of text.</para>
          </step>
        </procedure>
      </section>

      <section>
        <title>Manual Changes to the .script File</title>

        <para>In 1.9.0 the full range of ALTER TABLE commands is available to
        change the data structures and their names. However, if an old
        database cannot be opened due to data inconsistencies, or the use of
        index or column names that are not compatible with 1.9.0, manual
        editing of the <literal>.script</literal> file can be performed. Note
        that the <literal>.script</literal> file must be the result of a
        SHUTDOWN SCRIPT and must contain the full data for the
        database.</para>

        <para>The following changes can be applied so long as they do not
        affect the integrity of existing data.</para>

        <itemizedlist>
          <listitem>
            <para>Names of tables, columns and indexes can be changed.</para>
          </listitem>

          <listitem>
            <para><literal>CREATE UNIQUE INDEX ...</literal> to
            <literal>CREATE INDEX ...</literal> and vice versa</para>

            <para>A unique index can always be converted into a normal index.
            A non-unique index can only be converted into a unique index if
            the table data for the column(s) is unique in each row.</para>
          </listitem>

          <listitem>
            <para><literal>NOT NULL</literal></para>

            <para>A not-null constraint can always be removed.</para>
          </listitem>

          <listitem>
            <para><literal>PRIMARY KEY</literal></para>

            <para>A primary key constraint can be removed. It cannot be
            removed if there is a foreign key referencing the
            column(s).</para>
          </listitem>

          <listitem>
            <para><literal>UNIQUE</literal></para>

            <para>A UNIQUE constraint can be removed if there is no foreign
            key referencing the column(s).</para>
          </listitem>

          <listitem>
            <para><literal>FOREIGN KEY</literal></para>

            <para>A FOREIGN KEY constraint can always be removed.</para>
          </listitem>

          <listitem>
            <para><literal>COLUMN TYPES</literal></para>

            <para>Some changes to column types are possible. For example an
            INTEGER column can be changed to BIGINT, or DATE, TIME and
            TIMESTAMP columns can be changed to VARCHAR.</para>
          </listitem>
        </itemizedlist>

        <para>After completing the changes and saving the modified
        <literal>.script</literal> file, you can open the database as
        normal.</para>
      </section>
    </section>

    <section xml:id="deployment_backup-sect">
      <title>Backing Up Database Catalogs</title>

      <para>The database engine saves the files containing all the data in a
      file catalog when a shutdown takes place. It automatically recovers from
      an abnormal termination and preserves the data when the catalog is
      opened next time. In an ideal operating environment, where there is no
      OS crash, disk failure, bugs in code, etc. there would be no need
      regularly to backup a database. This is meant to say, the engine
      performs the routine shutdown procedure internally, therefore backing up
      catalogs is an insurance policy against all sorts of misadventure that
      are not under the control of the database engine.</para>

      <para>The data for each catalog consists of up to 5 files in the same
      directory with the endings such as <literal>*.properties</literal>,
      <literal>*.script</literal>, etc., as detailed in previous chapters
      **todo**</para>

      <simpara>HyperSQL 1.9.0 and later includes commands to backup the
      database files into a single <literal>.tar</literal> or
      <literal>.tar.gz</literal> file archive. The backup can be performed by
      a command given in a JDBC session if the target database catalog is
      running, or on the command-line if the target catalog has been
      shutdown.</simpara>

      <section>
        <title>Making Online Backups</title>

        <simpara>To back up a running catalog, obtain a JDBC connection and
        issue a <literal>BACKUP DATABASE</literal> command in SQL. In its most
        simple form, the command format below will backup the database as a
        single <literal>.tar.gz</literal> file to the given
        directory.</simpara>

        <programlisting>BACKUP DATABASE TO &lt;directory name&gt; BLOCKING</programlisting>

        <simpara>See the <remark>Add link to sqlsyntax_backup-sect</remark>
        SQL Syntax Chapter for details about the command and its options. See
        the sections below about restoring a backup.</simpara>
      </section>

      <section>
        <title>Making Offline Backups</title>

        <para>To back up an offline catalog, the catalog must be in shut down
        state. You will run a Java command like this <example>
            <title>Offline Backup Example</title>

            <screen>    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --save  \
    tar/path.tar db/base/path</screen>
          </example>where <filename>tar/path.tar</filename> is a file path to
        the <literal>*.tar</literal> or <literal>*.tar.gz</literal> file to be
        created, and <filename>db/base/path</filename> is the file path to the
        catalog file base name (in same fashion as in
        <varname>server.database.*</varname> settings and JDBC URLs with
        catalog type <glossterm>file:</glossterm>.</para>
      </section>

      <section>
        <title>Examining Backups</title>

        <para>You can list the contents of backup tar files with
        <classname>DbBackup</classname> on your operating system command line,
        or with any Pax-compliant tar or pax client (this includes GNU tar),
        <example>
            <title>Listing a backup with DbBackup</title>

            <screen>    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --list tar/path.tar</screen>
          </example>You can also give regular expressions at the end of the
        command line if you are only interested in some of the file entries in
        the backup. Note that these are real regular expressions, not shell
        globbing patterns, so you would use <literal>.+script</literal> to
        match entries ending in "script", not
        <literal>*script</literal>.</para>

        <simpara>You can examine the contents of the backup in their entirety
        by restoring the backup, as explained in the following section, to a
        temporary directory.</simpara>
      </section>

      <section>
        <title>Restoring a Backup</title>

        <para>You use <classname>DbBackup</classname> on your operating system
        command line to restore a catalog from a backup. <example>
            <title>Restoring a backup with DbBackup</title>

            <screen>    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --extract  \
    tar/path.tar db/dir</screen>
          </example>where <filename>tar/path.tar</filename> is a file path to
        the *.tar or *.tar.gz file to be read, and <filename>db/dir</filename>
        is the target directory to extract the catalog files into. Note that
        <filename>db/dir</filename> specifies a directory path, without the
        catalog file base name. The files will be created with the names
        stored in the tar file (and which you can see as described in the
        preceding section).</para>
      </section>
    </section>
  </chapter>

  <chapter xml:id="texttables-chapt">
    <title xml:id="texttables-title">Text Tables</title>

    <subtitle>Text Tables as a Standard Feature of Hsqldb</subtitle>

    <info>
      <authorgroup>
        <author>
          <personname><firstname>Bob</firstname>
          <surname>Preston</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>

        <author>
          <personname><firstname>Fred</firstname>
          <surname>Toussi</surname></personname>

          <affiliation>
            <orgname>The HSQL Development Group</orgname>
          </affiliation>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Text</keyword>

        <keyword>Tables</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Bob Preston and Fred Toussi. Permission is
        granted to distribute this document without any alteration under the
        terms of the HSQLDB license. Additional permission is granted to the
        HSQL Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <para>Text Table support for HSQLDB was originally developed by Bob
    Preston independently from the Project. Subsequently Bob joined the
    Project and incorporated this feature into version 1.7.0, with a number of
    enhancements, especially the use of conventional SQL commands for
    specifying the files used for Text Tables.</para>

    <para>In a nutshell, Text Tables are CSV or other delimited files treated
    as SQL tables. Any ordinary CSV or other delimited file can be used. The
    full range of SQL queries can be performed on these files, including
    SELECT, INSERT, UPDATE and DELETE. Indexes and unique constraints can be
    set up, and foreign key constraints can be used to enforce referential
    integrity between Text Tables themselves or with conventional
    tables.</para>

    <para>HyperSQL with Text Table support is the only comprehensive solution
    that employs the power of SQL and the universal reach of JDBC to handle
    data stored in text files and will have wide-ranging use way beyond the
    currently established Java realm of HSQLDB.</para>

    <section xml:id="texttables_impl-sect">
      <title>The Implementation</title>

      <section>
        <title>Definition of Tables</title>

        <para>Text Tables are defined similarly to conventional tables with
        the added TEXT keyword:</para>

        <programlisting>    CREATE TEXT TABLE &lt;tablename&gt; (&lt;column definition&gt; [&lt;constraint definition&gt;])</programlisting>

        <para>In addition, a SET command specifies the file and the separator
        character that the Text table uses:</para>

        <programlisting>   SET TABLE &lt;tablename&gt; SOURCE &lt;quoted_filename_and_options&gt; [DESC]</programlisting>

        <para>Text Tables cannot be created in <glossterm>mem:</glossterm>
        (all-in-memory) databases (databases that have no script file).</para>
      </section>

      <section>
        <title>Scope and Reassignment</title>

        <itemizedlist>
          <listitem>
            <para>A Text table without a file assigned to it is READ ONLY and
            EMPTY.</para>
          </listitem>

          <listitem>
            <para>A Temporary Text table has the scope and the lifetime of the
            SQL session (a JDBC Connection). **todo** (consider current lack
            of support)</para>
          </listitem>

          <listitem>
            <para>Reassigning a Text Table definition to a new file has
            implications in the following areas:</para>

            <orderedlist>
              <listitem>
                <para>The user is required to be an administrator.</para>
              </listitem>

              <listitem>
                <para>Existing transactions are committed at this
                point.</para>
              </listitem>

              <listitem>
                <para>Constraints, including foreign keys referencing this
                table, are kept intact. It is the responsibility of the
                administrator to ensure their integrity.</para>
              </listitem>
            </orderedlist>

            <para>The new source file is scanned and indexes are built when it
            is assigned to the table. At this point any violation of NOT NULL,
            UNIQUE or PRIMARY KEY constraints are caught and the assignment is
            aborted. However, foreign key constraints are not checked at the
            time of assignment or reassignment of the source file.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Null Values in Columns of Text Tables</title>

        <itemizedlist>
          <listitem>
            <para>Empty fields are treated as NULL. These are fields where
            there is nothing or just spaces between the separators.</para>
          </listitem>

          <listitem>
            <para>Quoted empty strings are treated as empty strings.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Configuration</title>

        <para>The default field separator is a comma (,). A different field
        separator can be specified within the SET TABLE SOURCE statement. For
        example, to change the field separator for the table mytable to a
        vertical bar, place the following in the SET TABLE SOURCE statement,
        for example:</para>

        <informalexample>
          <programlisting>    SET TABLE mytable SOURCE "myfile;fs=|"</programlisting>
        </informalexample>

        <para>Since HSQLDB treats CHAR's, VARCHARs, and LONGVARCHARs the same,
        the ability to assign different separators to the latter two is
        provided. When a different separator is assigned to a VARCHAR or
        LONGVARCHAR field, it will terminate any CSV field of that type. For
        example, if the first field is CHAR, and the second field LONGVARCHAR,
        and the separator fs has been defined as the pipe (|) and vs as the
        period (.) then the data in the CSV file for a row will look
        like:</para>

        <screen>    First field data|Second field data.Third field data</screen>

        <para>The following example shows how to change the default separator
        to the pipe (|), VARCHAR separator to the period (.) and the
        LONGVARCHAR separator to the tilde (~). Place the following within the
        SET TABLE SOURCE statement, for example:</para>

        <informalexample>
          <programlisting>    SET TABLE mytable SOURCE "myfile;fs=|;vs=.;lvs=~"</programlisting>
        </informalexample>

        <para>HSQLDB also recognises the following special indicators for
        separators:</para>

        <variablelist>
          <title>special indicators for separators</title>

          <varlistentry>
            <term>\semi</term>

            <listitem>
              <para>semicolon</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\quote</term>

            <listitem>
              <para>single-quote</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\space</term>

            <listitem>
              <para>space character</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\apos</term>

            <listitem>
              <para>apostrophe</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\n</term>

            <listitem>
              <para>newline - Used as an end anchor (like $ in regular
              expressions)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\r</term>

            <listitem>
              <para>carriage return</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\t</term>

            <listitem>
              <para>tab</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\\</term>

            <listitem>
              <para>backslash</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\u####</term>

            <listitem>
              <para>a Unicode character specified in hexadecimal</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Furthermore, HSQLDB provides csv file support with three
        additional boolean options: <varname>ignore_first</varname>,
        <varname>quoted</varname> and <varname>all_quoted</varname>. The
        <varname>ignore_first</varname> option (default false) tells HSQLDB to
        ignore the first line in a file. This option is used when the first
        line of the file contains column headings. The
        <varname>all_quoted</varname> option (default false) tells the program
        that it should use quotes around all character fields when writing to
        the source file. The <varname>quoted</varname> option (default true)
        uses quotes only when necessary to distinguish a field that contains
        the separator character. It can be set to false to prevent the use of
        quoting altogether and treat quote characters as normal characters.
        These options may be specified within the <literal>SET TABLE
        SOURCE</literal> statement:</para>

        <programlisting>    SET TABLE mytable SOURCE "myfile;ignore_first=true;all_quoted=true"</programlisting>

        <para>When the default options <literal>all_quoted=</literal>
        <literal>false</literal> and <literal>quoted=true</literal> are in
        force, fields that are written to a line of the csv file will be
        quoted only if they contain the separator or the quote character. The
        quote character is doubled when used inside a string. When
        <literal>all_quoted=false</literal> and
        <literal>quoted=false</literal> the quote character is not doubled.
        With this option, it is not possible to insert any string containing
        the separator into the table, as it would become impossible to
        distinguish from a separator. While reading an existing data source
        file, the program treats each individual field separately. It
        determines that a field is quoted only if the first character is the
        quote character. It interprets the rest of the field on this
        basis.</para>

        <para>The character encoding for the source file is<literal> ASCII
        </literal>by default. To support UNICODE or source files prepared with
        different encodings this can be changed to <literal>UTF-8</literal> or
        any other encoding. The default is <literal>encoding=ASCII
        </literal>and the option <literal>encoding=UTF-8</literal> or other
        supported encodings can be used.</para>

        <para>Finally, HSQLDB provides the ability to read a text file from
        the bottom up and make it READ ONLY, by placing the keyword "DESC" at
        the end of the SET TABLE SOURCE statement: *** not supported now
        **</para>

        <programlisting>    SET TABLE mytable SOURCE "myfile" DESC</programlisting>

        <para>This feature provides functionality similar to the Unix tail
        command, by re-reading the file each time a select is executed. Using
        this feature sets the table to read-only mode. Afterwards, it will no
        longer be possible to change the read-only status with <literal>SET
        TABLE &lt;tablename&gt; READONLY TRUE</literal>.</para>

        <para>Text table source files are cached in memory. The maximum number
        of rows of data that are in memory at any time is controlled by the
        <varname>textdb.cache_scale</varname> property. The default value for
        <varname>textdb.cache_scale</varname> is 10 and can be changed by
        setting the property in the .properties file for the database. The
        number of rows in memory is calculated as 3*(2**scale), which
        translates to 3072 rows for the default textdb.cache_scale setting
        (10). The property can also be set for individual text tables:</para>

        <programlisting>    SET TABLE mytable SOURCE "myfile;ignore_first=true;all_quoted=true;cache_scale=12"</programlisting>
      </section>

      <section xml:id="disconnecting_text_tables">
        <title>Disconnecting Text Tables</title>

        <para>Text tables may be <emphasis>disconnected</emphasis> from their
        underlying data source, i.e. the text file.</para>

        <para>You can explicitly disconnect a text table from its file by
        issuing the following statement: <programlisting>    SET TABLE mytable SOURCE OFF</programlisting></para>

        <para>Subsequently, <literal>mytable</literal> will be empty and
        read-only. However, the data source description will be preserved, and
        the table can be re-connected to it with <programlisting>    SET TABLE mytable SOURCE ON</programlisting></para>

        <para>When a database is opened, if the source file for an existing
        text table is missing the table remains disconnected from its data
        source, but the source description is preserved. This allows the
        missing source file to be added to the directory and the table
        re-connected to it with the above command.</para>
      </section>
    </section>

    <section xml:id="texttables_issues-sect">
      <title>Text File Issues</title>

      <itemizedlist>
        <title>Text File Issues</title>

        <listitem>
          <para>File locations are restricted to below the directory that
          contains the database, unless the
          <varname>textdb.allow_full_path</varname> property is set true in
          the database properties file.</para>
        </listitem>

        <listitem>
          <para>Blank lines are allowed anywhere in the text file, and are
          ignored.</para>
        </listitem>

        <listitem>
          <para>The file location for a text table created with ** not
          supported now **</para>

          <programlisting>    SELECT &lt;select list&gt; INTO TEXT &lt;tablename&gt; FROM</programlisting>

          <para>is the directory that contains the database and the file name
          is based on the table name. The table name is converted into the
          file name by replacing all the non-alphanumeric characters with the
          underscore character, conversion into lowercase, and adding the
          ".csv" suffix.</para>
        </listitem>

        <listitem>
          <para>It is possible to define a primary key or identity column for
          text tables.</para>
        </listitem>

        <listitem>
          <para>When a table source file is used with the<literal>
          ignore_first=true </literal>option, the first, ignored line is
          replaced with a blank line after a SHUTDOWN COMPACT.</para>
        </listitem>

        <listitem>
          <para>An existing table source file may include CHARACTER fields
          that do not begin with the quote character but contain instances of
          the quote character. These fields are read as literal strings.
          Alternatively, if any field begins with the quote character, then it
          is interpreted as a quoted string that should end with the quote
          character and any instances of the quote character within the string
          is doubled. When any field containing the quote character or the
          separator is written out to the source file by the program, the
          field is enclosed in quote character and any instance of the quote
          character inside the field is doubled.</para>
        </listitem>

        <listitem>
          <para>Inserts or updates of CHARACTER type field values are allowed
          with strings that contains the linefeed or the carriage return
          character. This feature is disabled when both quoted and all_quoted
          properties are false.</para>
        </listitem>

        <listitem>
          <para>ALTER TABLE commands that add or drop columns are not
          supported with non-empty text tables.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="texttables_globalprops-sect">
      <title>Text File Global Properties</title>

      <itemizedlist>
        <title>Complete list of supported global properties in *.properties
        files</title>

        <listitem>
          <para><varname>textdb.fs</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.lvs</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.quoted</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.all_quoted</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.ignore_first</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.encoding</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.cache_scale</varname></para>
        </listitem>

        <listitem>
          <para><varname>textdb.allow_full_path</varname></para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <xi:include href="databaseobjects.xml" />

  <chapter>
    <title>Session and Transactions</title>

    <section>
      <title>Overview</title>

      <para>All SQL statements are executed in sessions.</para>
    </section>
  </chapter>

  <chapter>
    <title>Data Access and Change</title>

    <section>
      <title>Overview</title>

      <para>SQL statements are used to access the data and to change the
      data.</para>
    </section>
  </chapter>

  <xi:include href="sqlroutines.xml" />

  <chapter xml:id="builtin_functions-chapt">
    <title>Built In Functions</title>

    <section xml:id="builtin_functions_intro-sect">
      <title>Overview</title>

      <para>HyperSQL supports a wide range of built-in functions and allows
      user-defined functions written in SQL and Java languages.</para>

      <para>The built-in functions fall into three groups:</para>

      <para><itemizedlist>
          <listitem>
            <para>SQL Standard Functions</para>

            <para>A wide rang of functions defined by SQL/Foundation are
            supported. SQL/Foundation functions that have no parameter are
            called without empty parentheses. Functions with multiple
            parameters often use keywords instead of commas to separate the
            parameters. Many functions are overloaded. Among these, some have
            one or more optional parameters that can be omitted, while the
            return type of some functions is dependent upon the type of one of
            the parameters.</para>
          </listitem>

          <listitem>
            <para>JDBC Open Group CLI Functions</para>

            <para>These functions were defined as an extension to the CLI
            standard, which is the basis for ODBC and JDBC and supported by
            many database products. JDBC supports an escape mechanism to
            specify function calls in SQL statements in a manner that is
            independent of the function names supported by the target database
            engine. For example <literal>SELECT {fn DAYOFMONTH (dateColumn)}
            FROM myTable</literal> can be used in JDBC and is translated to
            Standard SQL as <literal>SELECT EXTRACT (DAY_OF_MONTH FORM
            dateColumn) FROM myTable</literal> if a database engine supports
            the Standard syntax. If a database engine does not support
            Standard SQL, then the translation will be different. HSQLDB
            supports all the function names specified in the JDBC
            specifications as native functions. Therefore, there is no need to
            use the <literal>{fn FUNC_NAME ( ... ) }</literal> escape with
            HSQLDB. If a JDBC function is supported by the SQL Standard in a
            different form, the SQL Standard form is the preferred form to
            use.</para>
          </listitem>

          <listitem>
            <para>HSQLDB Built-In Functions</para>

            <para>A few additional built-in functions are available for some
            useful operations.</para>
          </listitem>
        </itemizedlist></para>

      <para>User defined functions are covered in a separate chapter.</para>

      <para>In the BNF specification used here, words in capital letters are
      actual tokens. Syntactic elements such as expressions are enclosed in
      angle brackets. The <literal>&lt;left paren&gt;</literal> and
      <literal>&lt;right paren&gt;</literal> tokens are represented with the
      actual symbol. Optional elements are enclosed with square brackets (
      <literal>&lt;left bracket&gt;</literal> and <literal>&lt;right
      bracket&gt;</literal> ). Multiple options for a required element are
      enclosed with braces (<literal> &lt;left brace&gt;</literal> and
      <literal>&lt;right brace&gt;</literal> )<literal>.</literal> Alternative
      tokens are separated with the vertical bar ( <literal>&lt;vertical
      bar&gt;</literal> ). At the end of each function definition, the
      standard which specifies the function is noted in parentheses as
      SQL/Foundation, JDBC or HSQLDB.</para>
    </section>

    <section xml:id="builtin_functions_string-sect">
      <title>String and Binary String Functions</title>

      <para>In SQL, there are three kinds of string: character, binary and
      bit. The units are respectively characters, octets, and bits. Each kind
      of string can be in different data types. CHAR, VARCHAR and CLOB are the
      character data types. BINARY, VARBINARY and BLOB are the binary data
      types. BIT and BIT VARYING are the bit string types. In all string
      functions, the position of a unit of the string within the whole string
      is specified from 1 to the length of the whole string. In the BNF,
      <literal>&lt;char value expr&gt; </literal>indicates any valid SQL
      expression that evaluates to a character type. Likewise,
      <literal>&lt;binary value expr&gt; </literal>indicates a binary type
      and<literal> &lt;num value expr&gt; </literal>indicates a numeric
      type.</para>

      <para><literal>ASCII ( &lt;char value expr&gt; )</literal></para>

      <para>Returns an INTEGER equal to the ASCII code value of the first
      character of <literal>&lt;char value expr&gt;</literal>. (JDBC)</para>

      <para><literal>CHAR ( &lt;UNICODE code&gt; ) </literal></para>

      <para>The argument is an INTEGER. Returns a character string containing
      a single character that has the specified<literal> &lt;UNICODE
      code&gt;</literal>, which is an integer. ASCII codes are a subset of the
      allowed values for <literal>&lt;UNICODE code&gt;</literal>.
      (JDBC)</para>

      <para><literal>CONCAT ( &lt;char value expr 1&gt;, &lt;char value expr
      2&gt; )</literal></para>

      <para><literal>CONCAT ( &lt;binary value expr 1&gt;, &lt;binary value
      expr 2&gt; )</literal></para>

      <para>The arguments are character strings or binary strings. Returns a
      string formed by concatenation of the arguments. Equivalent to the SQL
      concatenation expression <literal>&lt;value expr 1&gt; || &lt;value expr
      2&gt;</literal>. (JDBC)</para>

      <para><literal>DIFFERENCE ( &lt;char value expr 1&gt;, &lt;char value
      expr 2&gt; )</literal></para>

      <para>The arguments are character strings. Converts the arguments into
      SOUNDEX codes, and returns an INTEGER between 0-3 which indicates how
      many letters of the two SOUNDEX value are different. (JDBC)</para>

      <para><literal>INSERT ( &lt;char value expr 1&gt;, &lt;offset&gt;,
      &lt;length&gt;, &lt;char value expr 2&gt; )</literal></para>

      <para>Returns a character string based on <literal>&lt;char value expr
      1&gt;</literal> in which <literal>&lt;length&gt;</literal> characters
      have been removed from the <literal>&lt;offset&gt;</literal> position
      and in their place, the whole <literal>&lt;char value expr
      2&gt;</literal> is copied. Equivalent to SQL/Foundation
      <literal>OVERLAY( &lt;char value expr1&gt; PLACING &lt; char value
      expr2&gt; FROM &lt;offset&gt; FOR &lt;length&gt; )</literal> .
      (JDBC)</para>

      <para><literal>HEXTORAW( &lt;char value expr&gt; )</literal></para>

      <para>Returns a BINARY string formed by translation of hexadecimal
      digits and letters in the &lt;char value expr&gt;. Each character of the
      &lt;char value expr&gt; must be a digit or a letter in the A | B | C | D
      | E | F set. Each byte of the retured binary string is formed by
      translating two hex digits into one byte. (HSQLDB)</para>

      <para><literal>LCASE ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns a character string that is the lower case version of the
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>LOWER (&lt;char value expr&gt;)</literal>. (JDBC)</para>

      <para><literal>LEFT ( &lt;char value expr&gt;, &lt;length&gt; )
      </literal></para>

      <para>Returns a character string consisting of the first
      <literal>&lt;length&gt;</literal> characters of <literal>&lt;char value
      expr&gt;</literal>. Equivalent to SQL/Foundation<literal>
      SUBSTRING(&lt;char value expr&gt; FROM 0 FOR &lt;length&gt;)</literal>.
      (JDBC)</para>

      <para><literal>LENGTH ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns as a BIGINT value the number of characters in
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>CHAR_LENGTH(&lt;char value expr&gt;)</literal>. (JDBC)</para>

      <para><literal>LOCATE ( &lt;char value expr 1&gt;, &lt;char value expr
      2&gt; [ , &lt;offset&gt; ] ) </literal></para>

      <para>Returns as a BIGINT value the starting position of the first
      occurrence of <literal>&lt;char value expr 1&gt;</literal> within
      <literal>&lt;char value expr 2&gt;</literal>. If
      <literal>&lt;offset</literal>&gt; is specified, the search begins with
      the position indicated by <literal>&lt;offset&gt;</literal>. If the
      search is not successful, 0 is returned. Equivalent to SQL/Foundation
      <literal>POSITION(&lt;char value expr 1&gt; IN &lt;char value expr
      2&gt;)</literal>. (JDBC)</para>

      <para><literal>LTRIM ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns a character string based on <literal>&lt;char value
      expr&gt;</literal> with the leading space characters removed. Equivalent
      to SQL/Foundation <literal>TRIM( LEADING ' ' FROM &lt;char value
      expr&gt; )</literal>. (JDBC)</para>

      <para><literal>RAWTOHEX( &lt;binary value expr&gt; )</literal></para>

      <para>Returns a character string composed of hexadecimal digits
      representing the bytes in the &lt;binary value expr&gt;. Each byte of
      the &lt;binary value expr&gt; is translated into two hex digits.
      (HSQLDB)</para>

      <para><literal>REPEAT ( &lt;char value expr&gt;, &lt;count&gt; )
      </literal></para>

      <para>Returns a character string based on<literal> &lt;char value
      expr&gt;</literal>, repeated <literal>&lt;count&gt;</literal> times.
      (JDBC)</para>

      <para><literal>REPLACE ( &lt;char value expr 1&gt;, &lt;char value expr
      2&gt;, &lt;char value expr 3&gt; )</literal></para>

      <para>Returns a character string based on <literal>&lt;char value expr
      1&gt;</literal> where each occurrence of <literal>&lt;char value expr
      2&gt;</literal> has been replaced with a copy of <literal>&lt;char value
      expr 3&gt;</literal>. (JDBC)</para>

      <para><literal>RIGHT ( &lt;char value expr&gt;, &lt;count&gt; )
      </literal></para>

      <para>Returns a character string consisting of the last
      <literal>&lt;count&gt;</literal> characters of <literal>&lt;char value
      expr&gt;</literal>. (JDBC)</para>

      <para><literal>RTRIM ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns a character string based on <literal>&lt;char value
      expr&gt;</literal> with the trailing space characters removed.
      Equivalent to SQL/Foundation <literal>TRIM(TRAILING ' ' FROM
      &lt;character string&gt;)</literal>. (JDBC)</para>

      <para><literal>SOUNDEX ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns a four character code representing the sound of
      <literal>&lt;char value expr&gt;</literal>. The US census algorithm is
      used. For example the soundex value for Washington is W252.
      (JDBC)</para>

      <para><literal>SPACE ( &lt;count&gt; ) </literal></para>

      <para>Returns a character string consisting of <literal>&lt;count&gt;
      </literal>spaces. (JDBC)</para>

      <para><literal>{ SUBSTR | SUBSTRING } ( &lt;char value expr&gt;,
      &lt;offset&gt;, &lt;length&gt; )</literal></para>

      <para>The JDBC version of SQL/Foundation <literal>SUBSTRING</literal>
      returns a character string that consists of
      <literal>&lt;length&gt;</literal> characters from <literal>&lt;char
      value expr&gt; </literal>starting at the
      <literal>&lt;offset&gt;</literal> position. (JDBC)</para>

      <para><literal>UCASE ( &lt;char value expr&gt; ) </literal></para>

      <para>Returns a character string that is the lower case version of the
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>UPPER( &lt;char value expr&gt; )</literal> . (JDBC)</para>

      <para><literal>{ CHAR_LENGTH | CHARACTER_LENGTH } ( &lt;char value
      expression&gt; [ USING { CHARACTERS | OCTETS } ] )</literal></para>

      <para><literal>OCTET_LENGTH ( &lt;string value expression&gt;
      )</literal></para>

      <para><literal>BIT_LENGTH ( &lt;string value expression&gt;
      )</literal></para>

      <para>The CHAR_LENGTH or CHARACTER_LENGTH function can be used with
      character strings, while OCTET_LENGTH can be used with character or
      binary strings and BIT_LENGTH can be used with character, binary and bit
      strings.</para>

      <para>All functions return a BIGINT value that measures the length of
      the string in the given unit. CHAR_LENGTH counts characters,
      OCTET_LENGTH counts octets and BIT_LENGTH counts bits in the string. For
      CHAR_LENGTH, if <literal>[ USING OCTETS ] </literal>is specified, the
      octet count is returned. (Foundation)</para>

      <para><literal>OVERLAY ( &lt;char value expr 1&gt; PLACING &lt;char
      value expr 2&gt;</literal></para>

      <para><literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ]
      [ USING CHARACTERS ] )</literal></para>

      <para><literal>OVERLAY ( &lt;binary value expr 1&gt; PLACING &lt;binary
      value expr 2&gt;</literal></para>

      <para><literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ]
      )</literal></para>

      <para>The character version of OVERLAY returns a character string based
      on <literal>&lt;char value expr 1&gt;</literal> in which
      <literal>&lt;string length&gt;</literal> characters have been removed
      from the <literal>&lt;start position&gt;</literal> and in their place,
      the whole <literal>&lt;char value expr 2&gt;</literal> is copied.</para>

      <para>The binary version of OVERLAY returns a binary string formed in
      the same manner as the character version. (Foundation)</para>

      <para><literal>POSITION ( &lt;char value expr 1&gt; IN &lt;char value
      expr 2&gt; [ USING CHARACTERS ] )</literal></para>

      <para><literal>POSITION ( &lt;binary value expr 1&gt; IN &lt;binary
      value expr 2&gt; )</literal></para>

      <para>The character and binary versions of POSITION search the string
      value of the second argument for the first occurrence of the first
      argument string. If the search is successful, the position in the string
      is returned as a BIGINT. Otherwise zero is returned.</para>

      <para><literal>SUBSTRING ( &lt;char value expr&gt; FROM &lt;start
      position&gt; [ FOR &lt;string length&gt; ] [ USING CHARACTERS ]
      )</literal></para>

      <para><literal>SUBSTRING ( &lt;binary value expr&gt; FROM &lt;start
      position&gt; [ FOR &lt;string length&gt; ] )</literal></para>

      <para>The character version of SUBSTRING returns a character string that
      consists of the characters of the <literal>&lt;char value expr&gt;
      </literal>from <literal>&lt;start position&gt;</literal>. If the
      optional<literal> &lt;string length&gt;</literal> is specified, only
      <literal>&lt;string length&gt; </literal>characters are returned.</para>

      <para>The binary version of SUBSTRING returns a binary string in the
      same manner. (Foundation)</para>

      <para><literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim
      character&gt; ] FROM ] &lt;char value expr&gt; )</literal></para>

      <para><literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim
      octet&gt; ] FROM ] &lt;binary value expr&gt; )</literal></para>

      <para>The character version of TRIM returns a character string based on
      <literal>&lt;char value expr&gt;</literal>. Consecutive instances of
      <literal>&lt;trim character&gt; </literal>are removed from the
      beginning, the end or both ends of the<literal>&lt;char value expr&gt;
      </literal>depending on the value of the optional first qualifier
      <literal>[ LEADING | TRAILING | BOTH ]</literal>. If no qualifier is
      specified, <literal>BOTH </literal>is used as default. If <literal>[
      &lt;trim character&gt; ]</literal> is not specified, the space character
      is used as default.</para>

      <para>The binary version of TRIM returns a binary string based on
      <literal>&lt;binary value expr&gt;</literal>. Consecutive instances of
      <literal>&lt;trim octet&gt; </literal>are removed in the same manner as
      in the character version. If<literal> [ &lt;trim octet&gt; ]</literal>
      is not specified, the 0 octet is used as default. (Foundation)</para>
    </section>

    <section xml:id="builtin_functions_numeric-sect">
      <title>Numeric Functions</title>

      <para><literal>ABS ( &lt;num value expr&gt; | &lt;interval value
      expr&gt; ) </literal></para>

      <para>Returns the absolute value of the argument as a value of the same
      type. (JDBC and Foundation)</para>

      <para><literal>ACOS ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the arc-cosine of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para><literal>ASIN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the arc-sine of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para><literal>ATAN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the arc-tangent of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para><literal>ATAN2 ( &lt;num value expr 1&gt;, &lt;num value expr
      2&gt; ) </literal></para>

      <para>The <literal>&lt;num value expr 1&gt;</literal> and
      <literal>&lt;num value expr 2&gt;</literal> express the
      <varname>x</varname> and <varname>y</varname> coordinates of a point.
      Returns the angle, in radians, representing the angle coordinate of the
      point in polar coordinates, as a value of DOUBLE type. (JDBC)</para>

      <para><literal>{ CEIL | CEILING } ( &lt;num value expr&gt; )
      </literal></para>

      <para>Returns the smallest integer greater than or equal to the
      argument. If the argument is exact numeric then the result is exact
      numeric with a scale of 0. If the argument is approximate numeric, then
      the result is of DOUBLE type. (JDBC and Foundation)</para>

      <para><literal>BITOR ( &lt;num value expr 1&gt;, &lt;num value expr
      2&gt; )</literal></para>

      <para><literal>BITAND ( &lt;num value expr 1&gt;, &lt;num value expr
      2&gt; )</literal></para>

      <para><literal>BITXOR ( &lt;num value expr 1&gt;, &lt;num value expr
      2&gt; )</literal></para>

      <para>These three functions perform the bit operations: OR, AND, XOR, on
      two integer values. The result is an integer value. (HSQLDB)</para>

      <para><literal>COS ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the cosine of the argument (an angle expressed in radians)
      as a value of DOUBLE type. (JDBC)</para>

      <para><literal>COT ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the cotangent of the argument as a value of DOUBLE type.
      The <literal>&lt;num value expr&gt;</literal> represents an angle
      expressed in radians. (JDBC)</para>

      <para><literal>DEGREES ( &lt;num value expr&gt; ) </literal></para>

      <para>Converts the argument (an angle expressed in<literal>
      radians</literal>) into degrees and returns the value in the DOUBLE
      type. (JDBC)</para>

      <para><literal>EXP ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the exponential value of the argument as a value of DOUBLE
      type. (JDBC and Foundation)</para>

      <para><literal>FLOOR ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the largest integer that is less than or equal to the
      argument. If the argument is exact numeric then the result is exact
      numeric with a scale of 0. If the argument is approximate numeric, then
      the result is of DOUBLE type. (JDBC and Foundation)</para>

      <para><literal>LN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the natural logarithm of the argument, as a value of
      DOUBLE type. (Foundation)</para>

      <para><literal>LOG ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the natural logarithm of the argument, as a value of
      DOUBLE type. (JDBC)</para>

      <para><literal>LOG10 ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the base 10 logarithm of the argument as a value of DOUBLE
      type. (JDBC)</para>

      <para><literal>MOD ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
      ) </literal></para>

      <para>Returns the remainder (modulus) of <literal>&lt;num value expr
      1&gt;</literal> divided by <literal>&lt;num value expr 2&gt;.</literal>
      The data type of the returned value is the same as the second argument.
      (JDBC and Foundation)</para>

      <para><literal>PI () </literal></para>

      <para>Returns the constant pi as a value of DOUBLE type. (JDBC)</para>

      <para><literal>POWER ( &lt;num value expr 1&gt;, &lt;num value expr
      2&gt; ) </literal></para>

      <para>Returns the value of <literal>&lt;num value expr 1&gt;</literal>
      raised to the power of <literal>&lt;int value expr 2&gt;</literal> as a
      value of DOUBLE type. (JDBC and Foundation)</para>

      <para><literal>RADIANS ( &lt;num value expr&gt; ) </literal></para>

      <para>Converts the argument (an angle expressed in<literal>
      degrees</literal>) into radians and returns the value in the DOUBLE
      type. (JDBC)</para>

      <para><literal>RAND ( [ &lt;int value expr&gt; ] ) </literal></para>

      <para>Returns a random value in the DOUBLE type. The optional <literal>[
      &lt;int value expr&gt; ]</literal> is used as seed value. In HSQLDB each
      session has a separate random number generator. (JDBC)</para>

      <para><literal>ROUND ( &lt;num value expr&gt;, &lt;int value expr&gt; )
      </literal></para>

      <para>The <literal>&lt;num value expr&gt; </literal>is of the DOUBLE
      type. The function returns a DOUBLE value which is the value of the
      argument rounded to <literal>&lt;int value expr&gt;</literal> places
      right of the decimal point. If <literal>&lt;int value expr&gt;</literal>
      is negative, the first argument is rounded to <literal>&lt;int value
      expr&gt;</literal> places to the left of the decimal point.
      (JDBC)</para>

      <para><literal>SIGN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns an INTEGER, indicating the sign of the argument. If the
      argument is negative then -1 is returned. If it is equal to zero then 0
      is returned. If the argument is positive then 1 is returned.
      (JDBC)</para>

      <para><literal>SIN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the sine of the argument (an angle expressed in radians)
      as a value of DOUBLE type. (JDBC)</para>

      <para><literal>SQRT ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the square root of the argument as a value of DOUBLE type.
      (JDBC and Foundation)</para>

      <para><literal>TAN ( &lt;num value expr&gt; ) </literal></para>

      <para>Returns the tangent of the argument (an angle expressed in
      radians) as a value of DOUBLE type. (JDBC)</para>

      <para><literal>TRUNCATE ( &lt;num value expr&gt;, &lt;int value expr&gt;
      ) </literal></para>

      <para>Returns a value in the same type as <literal>&lt;num value
      expr&gt;</literal>. The value is rounded by replacing digits with zeros
      from <literal>&lt;int value expr&gt;</literal> places right of the
      decimal point to the end. If <literal>&lt;int value expr&gt;</literal>
      is negative, <literal>ABS( &lt;int value expr&gt; )</literal> digits to
      left of the decimal point and all digits to the right of the decimal
      points are replaced with zeros. Results of calling TRUNCATE with
      12345.6789 with (-2, 0, 2, 4) are (12300.0000, 12345.0000, 12345.6700,
      12345.6789). (JDBC)</para>
    </section>

    <section xml:id="builtin_functions_datetime-sect">
      <title>Date Time and Interval Functions</title>

      <para><literal>EXTRACT ( &lt;extract field&gt; FROM &lt;extract
      source&gt; )</literal></para>

      <para><literal>&lt;extract field&gt; ::= YEAR | MONTH | DAY | HOUR |
      MINUTE | DAY_OF_WEEK | WEEK_OF_YEAR | QUARTER | DAY_OF_YEAR |
      DAY_OF_MONTH |</literal></para>

      <para><literal>TIMEZONE_HOUR | TIMEZONE_MINUTE | SECOND |
      SECONDS_MIDNIGHT |</literal></para>

      <para><literal>DAY_NAME | MONTH_NAME</literal></para>

      <para><literal>&lt;extract source&gt; ::= &lt;datatime value expr&gt; |
      &lt;interval value expr&gt;</literal></para>

      <para>The EXTRACT function returns a field or element of the
      <literal>&lt;extract source&gt;</literal>. The <literal>&lt;extract
      source&gt;</literal> is a datetime or interval expression. The type of
      the return value is BIGINT for most of the<literal> &lt;extract
      field&gt;</literal> options, except for <literal>SECOND </literal>where
      a DECIMAL value is returned and <literal>DAY_NAME </literal>or<literal>
      MONTH_NAME </literal>where a character string is returned. When
      <literal>MONTH_NAME</literal> is specified, a string in the range
      January - December is returned. When <literal>DAY_NAME </literal>is
      specified, a string in the range Sunday -Saturday is returned.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      &lt;datatime value expr&gt;</literal>, different groups of
      <literal>&lt;extract source&gt;</literal> can be used depending on the
      data type of the expression. The <literal>TIMEZONE_HOUR |
      TIMEZONE_MINUTE</literal> options are valid only for TIME WITH TIMEZONE
      and TIMESTAMP WITH TIMEZONE data types. The <literal>HOUR | MINUTE |
      SECOND | SECONDS_MIDNIGHT</literal> options, are valid for TIME and
      TIMESTAMP types. The rest of the fields are valid for DATE and TIMESTAMP
      types.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      &lt;interval value expr&gt;</literal>, the <literal>&lt;extract
      field&gt;</literal> must be one of the fields of the INTERVAL type of
      the expressions. The <literal>YEAR | MONTH</literal> options may be
      valid for INTERVAL types based on months. The<literal>DAY | HOUR |
      MINUTE | SECOND | SECONDS_MIDNIGHT</literal> options may be valid for
      INTERVAL types based on seconds. For example,<literal> DAY | HOUR |
      MINUTE</literal> are the only valid fields for the INTERVAL DAY TO
      MINUTE data type. (Foundation with HSQLDB extensions)</para>

      <para><literal>CURRENT_DATE</literal></para>

      <para><literal>CURRENT_TIME [ ( &lt;time precision&gt; )
      ]</literal></para>

      <para><literal>LOCALTIME [ ( &lt;time precision&gt; ) ]</literal></para>

      <para><literal>CURRENT_TIMESTAMP [ ( &lt;timestamp precision&gt; )
      ]</literal></para>

      <para><literal>LOCALTIMESTAMP [ ( &lt;timestamp precision&gt; )
      ]</literal></para>

      <para>These datetime functions return the datetime value representing
      the moment the function is called. CURRENT_DATE returns a value of DATE
      type. CURRENT_TIME returns a value of TIME WITH TIME ZONE type.
      LOCALTIME returns a value of TIME type. CURRENT_TIMESTAMP returns a
      value of TIMESTAMP WITH TIME ZONE type. LOCALTIMESTAMP returns a value
      of TIMESTAMP type. If the optional <literal>[ ( &lt;time precision&gt; )
      ]</literal> or<literal> [ ( &lt;timestamp precision&gt; ) ]</literal> is
      used, then the returned value has the specified fraction of the second
      precision. (Foundation)</para>

      <para><literal>CURDATE ()</literal></para>

      <para>This function is equivalent to<literal> CURRENT_DATE.
      </literal>(JDBC)</para>

      <para><literal>CURTIME ()</literal></para>

      <para>This function is equivalent to<literal> LOCALTIME</literal>.
      (JDBC)</para>

      <para><literal>DAYNAME ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_NAME FROM
      ... ) </literal>Returns a string in the range of Sunday - Saturday.
      (JDBC)</para>

      <para><literal>DAYOFMONTH ( &lt;datatime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_OF_MONTH
      FROM ... ) </literal>Returns an integer value in the range of 1-31.
      (JDBC)</para>

      <para><literal>DAYOFWEEK ( &lt;datatime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_WEEK FROM
      ... ) </literal>Returns an integer value in the range of 1-7. The first
      day of the week is Sunday. (JDBC)</para>

      <para><literal>DAYOFYEAR ( &lt;datatime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_YEAR FROM
      ... ) </literal>Returns an integer value in the range of 1-366.
      (JDBC)</para>

      <para><literal>HOUR ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( HOUR FROM ... )
      </literal>Returns an integer value in the range of 0-23. (JDBC)</para>

      <para><literal>MINUTE ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( MINUTE FROM ...
      ) </literal>Returns an integer value in the range of 0 - 59.
      (JDBC)</para>

      <para><literal>MONTH ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( MONTH FROM ... )
      </literal>Returns an integer value in the range of 1-12. (JDBC)</para>

      <para><literal>MONTHNAME ( &lt;datatime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( NAME_OF_MONTH
      FROM ... ) </literal>Returns a string in the range of January -
      December. (JDBC)</para>

      <para><literal>NOW ()</literal></para>

      <para>This function is equivalent to
      <literal>LOCAL_TIMESTAMP.</literal></para>

      <para><literal>QUARTER ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( QUARTER FROM ...
      ) </literal>Returns an integer in the range of 1 - 4. (JDBC)</para>

      <para><literal>SECOND ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( SECOND FROM ...
      ) </literal>Returns an integer in the range of 0 - 59. (JDBC)</para>

      <para><literal>SECONDS_SINCE_MIDNIGHT ( &lt;datatime value expr&gt;
      )</literal></para>

      <para>This function is equvalent to<literal> EXTRACT (
      SECONDS_SINCE_MIDNIGHT FROM ... ) </literal>Returns an integer in the
      range of 0 - 86399. (HSQLDB)</para>

      <para><literal>WEEK ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equvalent to<literal> EXTRACT ( WEEK_OF_YEAR FROM
      ... ) </literal>Returns an integer in the range of 1 - 54. (JDBC)</para>

      <para><literal>YEAR ( &lt;datatime value expr&gt; )</literal></para>

      <para>This function is equvalent to<literal> EXTRACT ( YEAR FROM ... )
      </literal>Returns an integer in the range of 1 - 9999. (JDBC)</para>

      <para><literal>TIMESTAMPADD ( &lt;datetime value expr&gt;, &lt;numeric
      value expression&gt;, &lt;tsi datetime field&gt; )</literal></para>

      <para><literal>TIMESTAMPDIFF ( &lt;datetime value expr 1&gt;, datetime
      value expr 2&gt;, &lt;tsi datetime field&gt; )</literal></para>

      <para><literal>&lt;tsi datetime field&gt; ::= SQL_TSI_FRAC_SECOND |
      SQL_TSI_SECOND | SQL_TSI_MINUTE | SQL_TSI_HOUR | SQL_TSI_DAY |
      SQL_TSI_WEEK | SQL_TSI_MONTH | SQL_TSI_QUARTER |
      SQL_TSI_YEAR</literal></para>

      <para>HSQLDB supports full SQL Standard dateteime features. It supports
      adding integers representing units of time directly to datetime values
      using the arithmetic plus operator. It also supports subtracting one
      <literal>&lt;datetime value expr&gt;</literal> from another in the given
      units of days using the minus operator. An example of
      <literal>&lt;datetime value expr&gt; + &lt;numeric value expression&gt;
      &lt;datetime field&gt; </literal>is <literal>LOCAL_TIMESTAMP + 5
      DAY</literal>. An example of <literal>( &lt;datetime value expr&gt; -
      &lt;numeric value expression&gt; ) &lt;datetime field&gt; </literal>is
      <literal>(CURRENT_DATE - DATE '2008-08-8') MONTH </literal>which returns
      the number of calendar months between the two dates.</para>

      <para>The two JDBC functions, <literal>TIMESTAMPADD </literal>and
      <literal>TIMESTAMPDIFF</literal> perform the same function as above SQL
      expressions. The field names are different from those used in the
      EXTRACT functions. These names are valid for use only when calling these
      two functions. The return value for TIMESTAMPADD is of the same type as
      the datetime argument used. The return type for TIMESTAMPDIFF is always
      BIGINT, regardless of the type of arguments. The two datetime arguments
      of TIMESTAMPDIFF should be of the same type. (JDBC)</para>

      <para><literal>DATEDIFF ( &lt;datetime value expr 1&gt;, datetime value
      expr 2&gt;, &lt;field&gt; )</literal></para>

      <para><literal>&lt;field&gt; ::= 'yy' | 'mm' | 'dd' | 'hh' | 'mi' | 'ss'
      | 'ms'</literal></para>

      <para>The DATEDIFF function is an alternative to TIMESTAMPDIFF, with
      fewer available field options. The fields translate to YEAR, MONTH, DAY,
      HOUR, MINUTE, SECOND and MILLISECOND. (HSQLDB}</para>

      <para><literal>TO_CHAR( &lt;datetime value expr&gt;, &lt;char value
      expr&gt; )</literal></para>

      <para>This function formats a datetime or numeric value to the format
      specified by the pattern given in the second argument. The pattern can
      contain pattern elements from the list given below, plus punctuation and
      space characters. An example, including the result, is given
      below:</para>

      <programlisting>TO_CHAR ( TIMESTAMP'2008-02-01 20:30:40', 'YYYY BC MONTH, DAY HH')

2008 AD February, Friday 8
</programlisting>

      <para>The format is internally translated to a
      <classname>java.text.SimpleDateFormat</classname> format string. Any
      character sequences not listed below are included in the Java format
      string and may cause unexpected results or errors. The supported format
      components are as follows:</para>

      <table colsep="1" frame="all" pgwide="0">
        <title>TO CHAR Values</title>

        <tgroup cols="2">
          <colspec colwidth="5cm" />

          <colspec />

          <tbody>
            <row>
              <entry><literal>BC | B.C. | AD | A.D.</literal></entry>

              <entry>Returns <literal>AD</literal> for common era and
              <literal>BC</literal> for before common era</entry>
            </row>

            <row>
              <entry><literal>RRRR</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>YYYY</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>IYYY</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>YY</literal></entry>

              <entry><para>2 digit year</para></entry>
            </row>

            <row>
              <entry><literal>IY</literal></entry>

              <entry><para>2 digit year</para></entry>
            </row>

            <row>
              <entry><literal>IYYY</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>MM</literal></entry>

              <entry><para>Month (01-12)</para></entry>
            </row>

            <row>
              <entry><literal>MON</literal></entry>

              <entry><para>Short three-letter name of month</para></entry>
            </row>

            <row>
              <entry><literal>MONTH</literal></entry>

              <entry><para>Name of month</para></entry>
            </row>

            <row>
              <entry><literal>WW</literal></entry>

              <entry><para>Week of year (1-53) where week 1 starts on the
              first day of the year and continues to the seventh day of the
              year.</para></entry>
            </row>

            <row>
              <entry><literal>W</literal></entry>

              <entry><para>Week of month (1-5) where week 1 starts on the
              first day of the month and ends on the seventh.</para></entry>
            </row>

            <row>
              <entry><literal>IW</literal></entry>

              <entry><para>Week of year (1-52 or 1-53) based on the ISO
              standard.</para></entry>
            </row>

            <row>
              <entry><literal>DAY</literal></entry>

              <entry><para>Name of day.</para></entry>
            </row>

            <row>
              <entry><literal>DD</literal></entry>

              <entry><para>Day of month (1-31).</para></entry>
            </row>

            <row>
              <entry><literal>DDD</literal></entry>

              <entry><para>Day of year (1-366).</para></entry>
            </row>

            <row>
              <entry><literal>DY</literal></entry>

              <entry><para>Short three-letter name of day.</para></entry>
            </row>

            <row>
              <entry><literal>HH</literal></entry>

              <entry><para>Hour of day (0-11).</para></entry>
            </row>

            <row>
              <entry><literal>HH12</literal></entry>

              <entry><para>Hour of day (0-11).</para></entry>
            </row>

            <row>
              <entry><literal>HH24</literal></entry>

              <entry><para>Hour of day (0-23).</para></entry>
            </row>

            <row>
              <entry><literal>MI</literal></entry>

              <entry><para>Minute (0-59).</para></entry>
            </row>

            <row>
              <entry><literal>SS</literal></entry>

              <entry><para>Second (0-59).</para></entry>
            </row>

            <row>
              <entry><literal>FF</literal></entry>

              <entry><para>Fractional seconds.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="builtin_functions_sysfunc-sect">
      <title>System Functions</title>

      <para><literal>DATABASE ()</literal></para>

      <para>Returns the file name (without directory information) of the
      database. (JDBC)</para>

      <para><literal>IDENTITY()</literal></para>

      <para>Returns the last IDENTITY value inserted into a row by the current
      session. (HSQLDB)</para>

      <para><literal>IFNULL( &lt;value expr 1&gt;, &lt;value expr 2&gt;
      )</literal></para>

      <para>Returns <literal>&lt;value expr 1&gt;</literal> if it is not null,
      otherwise returns <literal>&lt;value expr 2&gt;</literal>. The type of
      both arguments must be the same. Equivalent to SQL Standard
      <literal>COALESCE(&lt;value expr 1&gt;, &lt;value expr 2&gt;)</literal>
      function. (JDBC)</para>

      <para><literal>USER ()</literal></para>

      <para>Equivalent to the SQL function <literal>CURRENT_USER</literal>.
      (JDBC)</para>

      <para><literal>CONVERT ( &lt;value expr&gt; , &lt;data type&gt;
      )</literal></para>

      <para><literal>&lt;data type&gt; ::= { SQL_BIGINT | SQL_BINARY | SQL_BIT
      |SQL_BLOB | SQL_BOOLEAN | SQL_CHAR | SQL_CLOB | SQL_DATE | SQL_DECIMAL |
      SQL_DATALINK |SQL_DOUBLE | SQL_FLOAT | SQL_INTEGER | SQL_LONGVARBINARY |
      SQL_LONGNVARCHAR | SQL_LONGVARCHAR | SQL_NCHAR | SQL_NCLOB | SQL_NUMERIC
      | SQL_NVARCHAR | SQL_REAL | SQL_ROWID | SQL_SQLXML | SQL_SMALLINT |
      SQL_TIME | SQL_TIMESTAMP | SQL_TINYINT | SQL_VARBINARY | SQL_VARCHAR} [
      ( &lt;precision, length or scale parameters&gt; ) ]</literal></para>

      <para>The CONVERT function is a JDBC escape function, equivalent to the
      SQL standard CAST expression. It converts the <literal>&lt;value
      expr&gt;</literal> into the given <literal>&lt;data type&gt;</literal>
      and returns the value. The <literal>&lt;data type&gt;</literal> options
      are synthetic names made by prefixing type names with
      <literal>SQL_</literal>. Some of the <literal>&lt;data
      type&gt;</literal> options represent valid SQL types, but some are are
      based on non-standard type names, namely <literal>{ SQL_LONGNVARCHAR |
      SQL_LONGVARBINARY |SQL_LONGNVARCHAR | SQL_TINYINT }</literal>. None of
      the synthetic names can be used in any other context than the CONVERT
      function.</para>

      <para>The definition of CONVERT in the JDBC Standard does not allow the
      precision, scale or length to be specified. This is required by the SQL
      standard for BINARY, BIT, BLOB, CHAR, CLOB, VARBINARY and VARCHAR types
      and is often needed for DECIMAL and NUMERIC. Therefore, HSQLDB allows
      the use of precision, scale or length for the type definition when they
      are valid for the type definition. HSQLDB also allows the use of real
      type names (without the <literal>SQL_</literal> prefix). (JDBC)</para>

      <para><literal>CURRENT_USER</literal></para>

      <para><literal>CURRENT_ROLE</literal></para>

      <para><literal>SESSION_USER</literal></para>

      <para><literal>SYSTEM_USER</literal></para>

      <para><literal>CURRENT_SCHEMA</literal></para>

      <para><literal>CURRENT_CATALOG</literal></para>

      <para>These functions return the named current session attribute. They
      are all SQL Standard functions.</para>

      <para>The CURRENT_USER is the user that connected to the database, or a
      user subsequently set by the SET AUTHORIZATION statement.</para>

      <para>SESSION_USER is the same as CURRENT_USER</para>

      <para>SYSTEM_USER is the user that connected to the database. It is not
      changed with any command until the session is closed.</para>

      <para>CURRENT_SCHEMA is default schema of the user, or a schema
      subsequently set by the SET SCHEMA command.</para>

      <para>CURRENT_CATALOG is always the same within a given HSQLDB database
      and indicates the name of the catalog.</para>
    </section>
  </chapter>

  <xi:include href="filelinks-app.xml" />

  <index type="sql" xml:id="sql-ind">
    <title>SQL Index</title>
  </index>

  <index xml:id="book-ind">
    <title>General Index</title>
  </index>
</book>
