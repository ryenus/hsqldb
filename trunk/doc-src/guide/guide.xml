<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->

<!DOCTYPE book [
  <!ENTITY COPYRIGHT_YEAR "2008">
  <!ENTITY % dummy22 SYSTEM "../entities/global.ent"> %dummy22;
  <!ENTITY % dummy23 SYSTEM "../entities/addresses.ent"> %dummy23;
]>

<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:ns5="http://www.w3.org/1998/Math/MathML"
      xmlns:ns4="http://www.w3.org/2000/svg"
      xmlns:ns3="http://www.w3.org/1999/xhtml"
      xmlns:ns="http://docbook.org/ns/docbook">
  <!-- We declare the default namespace + those for prefixes xlink: and xi: in
       the root element, so we can use them anywhere in this file. -->

  <title>HyperSQL User Guide</title>

  <subtitle>HyperSQL Database Engine, aka HSQLDB</subtitle>

  <info>
    <authorgroup>
      <editor>
        <orgname>The HSQLDB Development Group</orgname>
      </editor>

      <editor>
        <personname>
          <firstname>Blaine</firstname>

          <surname>Simpson</surname>
        </personname>

        <email>&blaine_addr;</email>

        <affiliation>
          <orgname>HSQLDB Development Group</orgname>
        </affiliation>
      </editor>

      <editor>
        <personname>
          <firstname>Fred</firstname>

          <surname>Toussi</surname>
        </personname>

        <email>&fred_addr;</email>

        <affiliation>
          <orgname>HSQLDB Development Group</orgname>
        </affiliation>
      </editor>
    </authorgroup>

    <edition>$Revision$</edition>

    <pubdate>$Date$</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>Hypersonic</keyword>

      <keyword>Database</keyword>

      <keyword>JDBC</keyword>

      <keyword>Java</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2002-2009 HSQLDB Development Group. Permission is
      granted to distribute this document without any alteration under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <preface xml:id="book-pref">
    <title>Preface</title>

    <para>If you notice any mistakes in this document, please email the author
    listed at the beginning of the chapter. If you have problems with the
    procedures themselves, please use the HSQLDB support facilities which are
    listed at <link
    xlink:href="http://hsqldb.org/web/hsqlSupport.html">**todo**</link>.</para>

    <xi:include href="../altformats-sect.xml" />
  </preface>

  <chapter xml:id="running-chapt">
    <title>Running and Using HyperSQL</title>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Guide</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="running_jar-sect">
      <title>The HSQLDB Jar</title>

      <para>The HSQLDB jar package is located in the /lib directory of the ZIP
      package and contains several components and programs.</para>

      <itemizedlist>
        <title>Components of the Hsqldb jar package</title>

        <listitem>
          <para>HyperSQL RDBMS Engine (HSQLDB)</para>
        </listitem>

        <listitem>
          <para>HyperSQL JDBC Driver</para>
        </listitem>

        <listitem>
          <para>Database Manager (GUI database access tool, with Swing and AWT
          versions)</para>
        </listitem>

        <listitem>
          <para>Sql Tool (command line database access tool)</para>
        </listitem>
      </itemizedlist>

      <para>The HyperSQL RDBMS and JDBC Driver provide the core functionality.
      The rest are general-purpose database tools that can be used with any
      database engine that has a JDBC driver.</para>
    </section>

    <section xml:id="running_tools-sect">
      <title>Running Database Access Tools</title>

      <para>The tools are used for interactive user access to databases,
      including creation of a database, inserting or modifying data, or
      querying the database. All tools are run in the normal way for Java
      programs. In the following example the Swing version of the Database
      Manager is executed. The <filename>hsqldb.jar</filename> is located in
      the directory <filename>../lib</filename> relative to the current
      directory.</para>

      <screen>
    java -cp ../lib/hsqldb.jar org.hsqldb.util.DatabaseManagerSwing</screen>

      <para>If <filename>hsqldb.jar</filename> is in the current directory,
      the command would change to:</para>

      <screen>
    java -cp hsqldb.jar org.hsqldb.util.DatabaseManagerSwing</screen>

      <itemizedlist>
        <title>Main classes for the Hsqldb tools</title>

        <listitem>
          <para>
            <classname>org.hsqldb.util.DatabaseManager</classname>
          </para>
        </listitem>

        <listitem>
          <para>
            <classname>org.hsqldb.util.DatabaseManagerSwing</classname>
          </para>
        </listitem>

        <listitem>
          <para>
            <classname>org.hsqldb.cmdline.SqlTool</classname>
          </para>
        </listitem>
      </itemizedlist>

      <para>When a tool is up and running, you can connect to a database (may
      be a new database) and use SQL commands to access and mofidy the
      data.</para>

      <para>Tools can use command line arguments. You can add the command line
      argument --help to get a list of available arguments for these
      tools.</para>
    </section>

    <section xml:id="running_db-sect">
      <title>A HyperSQL Database</title>

      <para>Each HyperSQL database is called a catalog. There are three types
      of catalog depending on how the data is stored.</para>

      <itemizedlist>
        <title>Types of catalog data</title>

        <listitem>
          <para><glossterm>mem:</glossterm> stored entirely in RAM - without
          any persistence beyond the JVM process's life</para>
        </listitem>

        <listitem>
          <para><glossterm>file:</glossterm> stored in filesystem files</para>
        </listitem>

        <listitem>
          <para><glossterm>res:</glossterm> stored in a Java resource, such as
          a Jar and always read-only</para>
        </listitem>
      </itemizedlist>

      <para>All-in-memory, <glossterm>mem:</glossterm> catalogs can be used
      for test data or as sophisticated caches for an application. These
      databases do not have any files.</para>

      <para>A <glossterm>file</glossterm>: catalog consists of between 2 to 5
      files, all named the same but with different extensions, located in the
      same directory. For example, the database named "test" consists of the
      following files:</para>

      <itemizedlist>
        <listitem>
          <para>
            <filename>test.properties</filename>
          </para>
        </listitem>

        <listitem>
          <para>
            <filename>test.script</filename>
          </para>
        </listitem>

        <listitem>
          <para>
            <filename>test.log</filename>
          </para>
        </listitem>

        <listitem>
          <para>
            <filename>test.data</filename>
          </para>
        </listitem>

        <listitem>
          <para>
            <filename>test.backup</filename>
          </para>
        </listitem>
      </itemizedlist>

      <para>The properties file contains general settings about the database.
      The script file contains the definition of tables and other database
      objects, plus the data for non-cached tables. The log file contains
      recent changes to the database. The data file contains the data for
      cached tables and the backup file is a compressed backup of the last
      known consistent state of the data file. All these files are essential
      and should never be deleted. For some catalogs, the
      <filename>test.data</filename> and <filename>test.backup</filename>
      files will not be present. In addition to those files, a HyperSQL
      database may link to any formatted text files, such as CSV lists,
      anywhere on the disk.</para>

      <para>While the "test" catalog is open, a <filename>test.log</filename>
      file is used to write the changes made to data. This file is removed at
      a normal SHUTDOWN. Otherwise (with abnormal shutdown) this file is used
      at the next startup to redo the changes. A <filename>test.lck
      </filename>file is also used to record the fact that the database is
      open. This is deleted at a normal SHUTDOWN.</para>

      <note>
        <para>When the engine closes the database at a shutdown, it creates
        temporary files with the extension <literal>.new</literal> which it
        then renames to those listed above. In some circumstances, a
        <filename>test.data.old</filename> is created and deleted
        afterwards.</para>
      </note>

      <para>A <glossterm>res:</glossterm> catalog consists of the files for a
      small, read-only database that can be stored inside a Java resource such
      as a ZIP or JAR archive and distributed as part of a Java application
      program.</para>
    </section>

    <section xml:id="running_inprocess-sect">
      <title>In-Process Access to Database Catalogs</title>

      <para>In general, JDBC is used for all access to databases. This is done
      by making a connection to the database, then using various methods of
      the <classname>java.sql.Connection</classname> object that is returned
      to access the data. Access to an <glossterm>in-process</glossterm>
      database is started from JDBC, with the database path specified in the
      connection URL. For example, if the <glossterm>file:
      </glossterm>database name is "testdb" and its files are located in the
      same directory as where the command to run your application was issued,
      the following code is used for the connection:</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:testdb", "SA", "");</programlisting>

      <para>The database file path format can be specified using forward
      slashes in Windows hosts as well as Linux hosts. So relative paths or
      paths that refer to the same directory on the same drive can be
      identical. For example if your database path in Linux is
      <filename>/opt/db/testdb</filename> and you create an identical
      directory structure on the <literal>C:</literal> drive of a Windows
      host, you can use the same URL in both Windows and Linux:</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb", "SA", "");</programlisting>

      <para>When using relative paths, these paths will be taken relative to
      the directory in which the shell command to start the Java Virtual
      Machine was executed. Refer to Javadoc for <link
          xlink:href="../src/org/hsqldb/jdbc/JDBCConnection.html">
          <classname>JDBCConnection</classname>
        </link> for more details.</para>

      <para>A <glossterm>mem:</glossterm> database is specified by the
      <glossterm>mem:</glossterm> protocol. For <glossterm>mem:</glossterm>
      databases, the path is simply a name. Several
      <glossterm>mem:</glossterm> databases can exist at the same time and
      distinguished by their names. In the example below, the database is
      called "mymemdb":</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:mem:mymemdb", "SA", "");</programlisting>

      <para>A <glossterm>res:</glossterm> database, is specified by the
      <glossterm>res:</glossterm> protocol. As it is a Java resource, the
      database path is a Java URL (similar to the path to a class). In the
      example below, "resdb" is the root name of the database files, which
      exists in the directory "org/my/path" within the classpath (probably in
      a Jar). A Java resource is stored in a compressed format and is
      decompressed in memory when it is used. For this reason, a
      <glossterm>res:</glossterm> database should not contain large amounts of
      data and is always read-only.</para>

      <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:res:org.my.path.resdb", "SA", "");</programlisting>

      <para>The first time <glossterm>in-process</glossterm> connection is
      made to a database, some general data structures are initialised and a
      few helper threads are started. After this, creation of connections and
      calls to JDBC methods of the connections execute as if they are part of
      the Java application that is making the calls. When the SQL command
      "SHUTDOWN" is executed, the global structures and helper threads for the
      database are destroyed.</para>

      <para>Note that only one Java process at a time can make
      <glossterm>in-process</glossterm> connections to a given
      <glossterm>file:</glossterm> database. However, if the
      <glossterm>file:</glossterm> database has been made read-only, or if
      connections are made to a <glossterm>res:</glossterm> database, then it
      is possible to make <glossterm>in-process</glossterm> connections from
      multiple Java processes.</para>
    </section>

    <section xml:id="running_modes-sect">
      <title>Listener / Server Modes</title>

      <para>For most applications, <glossterm>in-process</glossterm> access is
      faster, as the data is not converted and sent over the network. The main
      drawback is that it is not possible by default to connect to the
      database from outside your application. As a result you cannot check the
      contents of the database with external tools such as Database Manager
      while your application is running.</para>

      <para>Server modes provide the maximum accessibility. The database
      engine runs in a JVM and and opens one or more
      <glossterm>in-process</glossterm> catalogs. It listens for connections
      from programs on the same computer or other computers on the network. It
      translates these connections into <glossterm>in-process</glossterm>
      connections to the databases.</para>

      <para>Several different programs can connect to the server and retrieve
      or update information. Applications programs (clients) connect to the
      server using the HyperSQL JDBC driver. In most server modes, the server
      can serve an unlimited number of databases that are specified at the
      time of running the server, or optionally, as a connection request is
      received.</para>

      <para>There are three server modes, based on the protocol used for
      communications between the client and server, and briefly disucssed
      below. More details on servres is provided in a separate chapter.</para>

      <section xml:id="running_hsqlserver-sect">
        <title>HyperSQL HSQL Server</title>

        <para>This is the preferred way of running a database server and the
        fastest one. A proprietary communications protocol is used for this
        mode. A command similar to those used for running tools and described
        above is used for running the server. The following example of the
        command for starting the server starts the server with one (default)
        database with files named "mydb.*" and the public name of
        "xdb".</para>

        <informalexample>
          <screen>
    java -cp ../lib/hsqldb.jar org.hsqldb.server.Server --database.0 file:mydb --dbname.0 xdb</screen>
        </informalexample>

        <para>The command line argument <literal>--help</literal> can be used
        to get a list of available arguments.</para>
      </section>

      <section xml:id="running_httpserver-sect">
        <title>HyperSQL HTTP Server</title>

        <para>This method of access is used when the computer hosting the
        database server is restricted to the HTTP protocol. The only reason
        for using this method of access is restrictions imposed by firewalls
        on the client or server machines and it should not be used where there
        are no such restrictions. The HyperSQL HTTP Server is a special web
        server that allows JDBC clients to connect via HTTP. The server can
        also act as a small general-purpose web server for static
        pages.</para>

        <para>To run an HTTP server, replace the main class for the server in
        the example command line above with the following:</para>

        <informalexample>
          <screen>
    org.hsqldb.server.WebServer</screen>
        </informalexample>

        <para>The command line argument <literal>--help</literal> can be used
        to get a list of available arguments.</para>
      </section>

      <section xml:id="running_servlet-sect">
        <title>HyperSQL HTTP Servlet</title>

        <para>This method of access also uses the HTTP protocol. It is used
        when a separate servlet engine (or application server) such as Tomcat
        or Resin provides access to the database. The Servlet Mode cannot be
        started independently from the servlet engine. The
        <filename>Servlet</filename> class, in the HSQLDB jar, should be
        installed on the application server to provide the connection. The
        database is specified using an application server property. Refer to
        the source file <link xlink:href="org.hsqldb.server.Servlet.java"/> to
        see the details.</para>

        <para>Both HTTP Server and Servlet modes can only be accessed using
        the JDBC driver at the client end. They do not provide a web front end
        to the database. The Servlet mode can serve only a single
        database.</para>

        <para>Please note that you do not normally use this mode if you are
        using the database engine in an application server. In this situation,
        connections to a catalog are usually made
        <glossterm>in-process</glossterm>, or using a Server</para>
      </section>

      <section xml:id="running_connecting-sect">
        <title>Connecting to a Database Server</title>

        <para>When a HyperSQL server is running, client programs can connect
        to it using the HSQLDB JDBC Driver contained in
        <filename>hsqldb.jar</filename>. Full information on how to connect to
        a server is provided in the Java Documentation for <link
            xlink:href="../src/org/hsqldb/jdbc/JDBCConnection.html">
            <classname>JDBCConnection</classname>
          </link> (located in the <filename>/doc/src</filename> directory of
        HSQLDB distribution. A common example is connection to the default
        port (9001) used for the <glossterm>hsql:</glossterm> protocol on the
        same machine:</para>

        <example>
          <title>Java code to connect to the local hsql Server</title>

          <programlisting>
    try {
        Class.forName("org.hsqldb.jdbc.JDBCDriver" );
    } catch (Exception e) {
        System.out.println("ERROR: failed to load HSQLDB JDBC driver.");
        e.printStackTrace();
        return;
    }

    Connection c = DriverManager.getConnection("jdbc:hsqldb:hsql://localhost/xdb", "SA", "");</programlisting>
        </example>

        <para>If the HyperSQL HTTP server is used, the protocol is
        <glossterm>http:</glossterm> and the URL will be different:</para>

        <example>
          <title>Java code to connect to the local http Server</title>

          <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:http://localhost/xdb", "SA", "");</programlisting>
        </example>

        <para>Note in the above connection URL, there is no mention of the
        database file, as this was specified when running the server. Instead,
        the public name defined for dbname.0 is used. Also, see the <link
        endterm="advanced-title" linkend="advanced-chapt" />**todo** chapter
        for the connection URL when there is more than one database per server
        instance.</para>
      </section>

      <section xml:id="running_security-sect">
        <title>Security Considerations</title>

        <para>When a HyperSQL server is run, network access should be
        adequately protected. Source IP addresses may be restricted by use of
        TCP filtering or firewall programs, or standalone firewalls.<link
        endterm="tls-sect-title" linkend="listeners_tls-sect" /> Only secure
        passwords should be used-- most importantly, the password for the
        default system user should be changed from the default empty string.
        If you are purposefully providing data to the public, then the
        wide-open public network connection should be used exclusively to
        access the public data via read-only accounts. (i.e., neither secure
        data nor privileged accounts should use this connection). These
        considerations also apply to HSQLDB servers run with the HTTP
        protocol.</para>

        <para>HyperSQL provides two optional security mechanisms. The
        encrypted SSL protocol, and Access Control Lists. Both mechanisms can
        be specified when running the Server or WebServer. From the client,
        the URL's co connect to an SSL server is slightly different:</para>

        <para><example>
            <title>Java code to connect to the local secure SSL hsql and http
            Servers</title>

            <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:hsqls://localhost/xdb", "SA", "");
    Connection c = DriverManager.getConnection("jdbc:hsqldb:https://localhost/xdb", "SA", "");
</programlisting>
          </example>The security features are discussed in detail in
        **todo**.</para>
      </section>

      <section xml:id="running_multiple_db-sect">
        <title>Using Multiple Databases</title>

        <para>A server can provide connections to more than one database. In
        the examples above, more than one set of database names can be
        specified on the command line. It is also possible to specify all the
        databases in a <literal>.properties</literal> file, instead of the
        command line. These capabilities are covered in the ** todo **
        chapter.</para>
      </section>
    </section>

    <section xml:id="running-data-access-sect">
      <title>Accessing the Data</title>

      <para>As shown so far, a <classname>java.sql.Connection</classname>
      object is always used to access the database. But the speed and
      performance depends on the type of connection.</para>

      <para>Establishing a connection and closing it has some overheads,
      therefore it is not good practice to create a new connection to perform
      a small number of operations. A connection should be reused as much as
      possible and closed only when it is not going to be used again for a
      long while.</para>

      <para>Reuse is more important for server connections. A server
      connection uses a TCP port for communications. Each time a connection is
      made, a port is allocated by the operating system and deallocated after
      the connection is closed. If many connections are made from a single
      client, the operating system may not be able to keep up and may refuse
      the connection attempt.</para>

      <para>A <classname>java.sql.Connection</classname> object has some
      methods that return further <classname>java.sql.*</classname> objects.
      All these objects belong to the connection that returned them and are
      closed when the connection is closed. These objects can be reused, but
      if they are not needed after performing the operations, they should be
      closed.</para>

      <para>A <classname>java.sql.DatabaseMetaData</classname> object is used
      to get metadata for the database.</para>

      <para>A <classname>java.sql.Statement</classname> object is used to
      execute queries and data change statements. A
      <classname>java.sql.Statement</classname> can be reused to execute a
      different statement each time.</para>

      <para>A <classname>java.sql.PreparedStatement</classname> object is used
      to execute a single statement repeatedly. The SQL statement usually
      contains parameters, which can be set to new values before each reuse.
      When a <classname>java.sql.PreparedStatement</classname> object is
      created, the engine keeps the compiled SQL statement for reuse, until
      the <classname>java.sql.PreparedStatement</classname> object is closed.
      As a result, repeated use of a
      <classname>java.sql.PreparedStatement</classname> is much faster than
      using a <classname>java.sql.Statement</classname> object.</para>

      <para>A <classname>java.sql.CallableStatement</classname> object is used
      to execute an SQL CALL statement. The SQL CALL statement may contain
      parameters, which should be be set to new values before each reuse.
      Similar to <classname>java.sql.PreparedStatement</classname>, the engine
      keeps the compiled SQL statement for reuse, until the
      <classname>java.sql.CallableStatement</classname> object is
      closed.</para>

      <para>A <classname>java.sql.Connection</classname> object also has some
      methods for transaction control.</para>

      <para>The <methodname>commit()</methodname> method performs a
      <literal>COMMIT</literal> while the <methodname>rollback()</methodname>
      method performs a <literal>ROLLBACK</literal> SQL statement.</para>

      <para>The <methodname>setSavepoint(String name)</methodname> method
      performs a <literal>SAVEPOINT &lt;name&gt;</literal> SQL statement and
      returns a <classname>java.sql.Savepoint</classname> object. The
      <literal>rollback(Savepoint name)</literal> method performs a
      <literal>ROLLBACK TO SAVEPOINT &lt;name&gt;</literal> SQL
      statement.</para>

      <para>The Javadoc for <link
          xlink:href="../src/org/hsqldb/jdbc/JDBCConnection.html">
          <classname>JDBCConnection</classname>
        </link>, <link xlink:href="../src/org/hsqldb/jdbc.JDBCDriver.html">
          <classname>JDBCDriver</classname>
        </link>, <link
          xlink:href="../src/org/hsqldb/jdbc/JDBCDatabaseMetaData.html">
          <classname>JDBCDatabaseMetadata</classname>
        </link>, <link xlink:href="../src/org/hsqldb/jdbc/JDBCResultSet.html">
          <classname>JDBCResultSet</classname>
        </link>, <link xlink:href="../src/org/hsqldb/jdbc/JDBCStatement.html">
          <classname>JDBCStatement</classname>
        </link>, and <link
          xlink:href="../src/org/hsqldb/jdbc/JDBCPreparedStatement.html">
          <classname>JDBCPreparedStatement</classname>
        </link> list all the supported JDBC methods together with information
      that is specific to HSQLDB.</para>
    </section>

    <section xml:id="running_closing-sect">
      <title>Closing the Database</title>

      <para>All databases running in different modes can be closed with the
      SHUTDOWN command, issued as an SQL statement.</para>

      <para>When SHUTDOWN is issued, all active transactions are rolled back.
      The catalog files are then saved in a form that can be opened quickly
      the next time the catalog is opened.</para>

      <para>A special form of closing the database is via the SHUTDOWN COMPACT
      command. This command rewrites the <literal>.data</literal> file that
      contains the information stored in CACHED tables and compacts it to its
      minimum size. This command should be issued periodically, especially
      when lots of inserts, updates or deletes have been performed on the
      cached tables. Changes to the structure of the database, such as
      dropping or modifying populated CACHED tables or indexes also create
      large amounts of unused file space that can be reclaimed using this
      command.</para>

      <para>Databases are not closed when the last connection to the database
      is explicitly closed via JDBC. A connection property,
      <literal>shutdown=true</literal>, can be specified on the first
      connection to the database (the connection that opens the database) to
      force a shutdown when the last connection closes.</para>

      <para><example>
          <title>specifying a connection property to shutdown the database
          when the last connection is closed</title>

          <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb;shutdown=true", "SA", "");</programlisting>
        </example>This feature is useful for running tests, where it may not
      be practical to shutdown the database after each test. But it is not
      recommended for application programs.</para>
    </section>

    <section xml:id="running_newdb-sect">
      <title>Creating a New Database</title>

      <para>When a server instance is started, or when a connection is made to
      an <glossterm>in-process</glossterm> database, a new, empty database is
      created if no database exists at the given path.</para>

      <para>This feature has a side effect that can confuse new users. If a
      mistake is made in specifying the path for connecting to an existing
      database, a connection is nevertheless established to a new database.
      For troubleshooting purposes, you can specify a connection property
      <property>ifexists</property>=<literal>true</literal> to allow
      connection to an existing database only and avoid creating a new
      database. In this case, if the database does not exist, the
      <methodname>getConnection()</methodname> method will throw an
      exception.</para>

      <para>
        <example>
          <title>specifying a connection property to disallow creating a new
          database</title>

          <programlisting>    Connection c = DriverManager.getConnection("jdbc:hsqldb:file:/opt/db/testdb;ifexists=true", "SA", "");</programlisting>
        </example>
      </para>
    </section>
  </chapter>

  <chapter xml:id="sqlissues-chapt">
    <title xml:id="sqlissues-title">SQL Issues</title>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>SQL</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="sqlissues_standards-sect">
      <title>Standards Support</title>

      <para>HSQLDB 1.9.0 supports the dialect of SQL defined by SQL standards
      92, 1999, 2003 and 200n. This means where a feature of the standard is
      supported, e.g. left outer join, the syntax is that specified by the
      standard text. Almost all syntactic features of SQL-92 up to Advanced
      Level are supported, as well as SQL 200n core and many optional features
      of this standard. Work is in progress for a formal declaration of
      conformance.</para>

      <para><citetitle>The SQL Syntax chapter of this guide </citetitle><link
      endterm="sqlsyntax-title" linkend="sqlsyntax-chapt">**todo**</link>
      lists all the keywords and most of the syntax that is supported. When
      writing or converting existing SQL DDL (Data Definition Language), DML
      (Data Manipulation Language) or DQL (Data Query Language) statements for
      HSQLDB, you should consult the supported syntax and modify the
      statements accordingly. Some statements written for older versions may
      have to be modified.</para>

      <para>Over 300 words are reserved by the standard and should not be used
      as table or column names. For example, the word POSITION is reserved as
      it is a function defined by the Standards with a similar role as
      <methodname>String.indexOf()</methodname> in Java. HyperSQL does not
      currently prevent you from using a reserved word if it does not support
      its use or can distinguish it. For example CUBE is a reserved words that
      is not currently supported by HyperSQL and is allowed as a table or
      column name. You should avoid using such names as future versions of
      HyperSQL are likely to support the reserved words and may reject your
      table definitions or queries. The full list of SQL reserved words is in
      the source of the <classname>org.hsqldb.Tokens</classname> class.</para>

      <para>If you have to use a reserved keyword as the name of a database
      object, you can enclose it in double quotes.</para>

      <para>HyperSQL also supports enhancements with keywords and expressions
      that are not part of the SQL standard. Expressions such as
      <literal>SELECT TOP 5 FROM ..</literal>, <literal>SELECT LIMIT 0 10 FROM
      ...</literal> or <literal>DROP TABLE mytable IF EXISTS</literal> are
      among such constructs.</para>

      <para>For a well-written basic guide to SQL with examples, you can
      consult <link
      xlink:href="http://www.postgresql.org/files/documentation/books/aw_pgsql/index.html">PostgreSQL:
      Introduction and Concepts</link> by Bruce Momjian, which is available on
      the web. Most of the core SQL coverage in the book applies also to
      HyperSQL. There are some differences in keywords supported by one and
      not the other engine (OUTER, OID's, etc.) or used differently
      (IDENTITY/SERIAL, TRIGGER, SEQUENCE, etc.).</para>

      <para>In version 1.9.0, all features of JDBC4 that apply to the
      capabilities of HSQLDB are fully supported. The relevant JDBC classes
      are thoroughly documented with additional clarifications and HyperSQL
      specific comments. See the JavaDoc for <link
      xlink:href="../src/index.html">org.hsqldb.jdbc.JDBCXXXX</link>
      classes.</para>
    </section>

    <section xml:id="sqlissues_tabletypes-sect">
      <title>Different Types of Tables</title>

      <para>HSQLDB supports TEMP tables and three types of persistent
      tables.</para>

      <para>TEMP tables are not written to disk and last only for the lifetime
      of the Connection object. The contents of each TEMP table is visible
      only from the Connection that was used to populate it; other concurrent
      connections to the database will have access to their own copies of the
      table. Since 1.8.0 the definition of TEMP tables conforms to the GLOBAL
      TEMPORARY type in the SQL standard. The definition of the table persists
      but each new connections sees its own copy of the table, which is empty
      at the beginning. When the connection commits, the contents of the table
      are cleared by default. If the table definition statements includes ON
      COMMIT PRESERVE ROWS, then the contents are kept when a commit takes
      place.</para>

      <para>The three types of persistent tables are MEMORY tables, CACHED
      tables and TEXT tables.</para>

      <para>Memory tables are the default type when the CREATE TABLE command
      is used. Their data is held entirely in memory but any change to their
      structure or contents is written to the
      <filename>&lt;dbname&gt;.script</filename> file. The script file is read
      the next time the database is opened, and the MEMORY tables are
      recreated with all their contents. So unlike TEMP table, the default,
      MEMORY tables are persistent.</para>

      <para>CACHED tables are created with the CREATE CACHED TABLE command.
      Only part of their data or indexes is held in memory, allowing large
      tables that would otherwise take up to several hundred megabytes of
      memory. Another advantage of cached tables is that the database engine
      takes less time to start up when a cached table is used for large
      amounts of data. The disadvantage of cached tables is a reduction in
      speed. Do not use cached tables if your data set is relatively small. In
      an application with some small tables and some large ones, it is better
      to use the default, MEMORY mode for the small tables.</para>

      <para>TEXT tables use a CSV (Comma Separated Value) or other delimited
      text file as the source of their data. You can specify an existing CSV
      file, such as a dump from another database or program, as the source of
      a TEXT table. Alternatively, you can specify an empty file to be filled
      with data by the database engine. TEXT tables are efficient in memory
      usage as they cache only part of the text data and all of the indexes.
      The Text table data source can always be reassigned to a different file
      if necessary. Two commands are needed to set up a TEXT table as detailed
      in the <link endterm="texttables-title"
      linkend="texttables-chapt">**todo**</link> chapter.</para>

      <para>With all-in-memory databases (see above), both MEMORY table and
      CACHED table declarations are treated as declarations for non-persistent
      memory tables. TEXT table declarations are not allowed in this
      mode.</para>

      <para>The default type of table resulting from future CREATE TABLE
      statements can be specified with the SQL command:</para>

      <para><programlisting>    SET DEFAULT TABLE TYPE { CACHED | MEMORY };</programlisting>The
      type of an existing table can be changed with the SQL command:</para>

      <para><programlisting>    SET TABLE &lt;table name&gt; TYPE { CACHED | MEMORY };</programlisting>SQL
      statements access different types of tables uniformly. No change to
      statements is needed to access different types of table.</para>
    </section>

    <section xml:id="sqlissues_constr_indexes-sect">
      <title>Constraints and Indexes</title>

      <para>HyperSQL supports PRIMARY KEY, NOT NULL, UNIQUE, CHECK and FOREIGN
      KEY constraints. This support is fairly comprehensive and covers
      multi-column constraints and indexes, plus cascading updates and deletes
      for foreign keys.</para>

      <para>The engine creates indexes internally to support PRIMARY KEY,
      UNIQUE and FOREIGN KEY constraints: a unique index is created for each
      PRIMARY KEY or UNIQUE constraint; an ordinary index is created for each
      FOREIGN KEY constraint. Because of this, you should not create duplicate
      user-defined indexes on the same column sets covered by these
      constraints. This would result in unnecessary memory and speed
      overheads. See the discussion in the <link endterm="sqlissues-title"
      linkend="sqlissues-chapt">**todo**</link> chapter for more
      information.</para>

      <para>Indexes are crucial for adequate query speed. When queries joining
      multiple tables are used, there must be an index on each joined column
      of each table. When range or equality conditions are used e.g.
      <literal>SELECT ... WHERE acol &gt;10 AND bcol = 0</literal>, an index
      is required on the acol column used in the condition. Indexes have no
      effect on ORDER BY clauses or some LIKE conditions. As a rule of thumb,
      HSQLDB is capable of internal processing of queries at over 100,000 rows
      per second. Any query that runs into several seconds should be checked
      and indexes should be added to the relevant columns of the tables if
      necessary.</para>

      <section>
        <title>Primary Key Constraints</title>

        <para>A PRIMARY KEY constraint is equivalent to a UNIQUE constraint
        with NOT NULL constraints on all it columns.</para>
      </section>

      <section>
        <title>Unique Constraints</title>

        <para>According to the SQL standards, a unique constraint on a single
        column means no two values are equal unless one of them is NULL. This
        means you can have one or more rows where the column value is
        NULL.</para>

        <para>A unique constraint on multiple columns (c1, c2, c3, ..) means
        that no two sets of values for the columns are equal unless at lease
        one of them is NULL. Each single column taken by itself can have
        repeat values. The following example satisfies a UNIQUE constraint on
        the two columns:</para>

        <example>
          <title>Column values which satisfy a 2-column UNIQUE
          constraint</title>

          <simplelist columns="2" type="horiz">
            <member>1,</member>

            <member>2</member>

            <member>2,</member>

            <member>1</member>

            <member>2,</member>

            <member>2</member>

            <member>NULL,</member>

            <member>1</member>

            <member>NULL,</member>

            <member>1</member>

            <member>1,</member>

            <member>NULL</member>

            <member>NULL,</member>

            <member>NULL</member>

            <member>NULL,</member>

            <member>NULL</member>
          </simplelist>
        </example>
      </section>

      <section>
        <title>Unique Indexes</title>

        <para>In 1.9.0, user-defined UNIQUE indexes can still be declared but
        they are deprecated. You should use a UNIQUE constraint
        instead.</para>

        <para><literal>CONSTRAINT &lt;name&gt; UNIQUE</literal> always creates
        internally a unique index on the columns, as with previous versions,
        so it has the same effect as the deprecated UNIQUE INDEX
        declaration.</para>
      </section>

      <section>
        <title>FOREIGN KEYS</title>

        <para>HSQLDB features single and multiple column foreign keys. A
        foreign key can also be specified to reference a target table without
        naming the target column(s). In this case the primary key column(s) of
        the target table is used as the referenced column(s). Each pair of
        referencing and referenced columns in any foreign key should be of
        identical type. When a foreign key is declared, a unique constraint
        (or primary key) must exist on the referenced columns in the primary
        key table. A non-unique index is automatically created on the
        referencing columns. For example:</para>

        <informalexample>
          <programlisting>    CREATE TABLE child(c1 INTEGER, c2 VARCHAR, FOREIGN KEY (c1, c2) REFERENCES parent(p1, p2));</programlisting>
        </informalexample>

        <para>There must be a UNIQUE constraint on columns
        <literal>(p1,p2)</literal> in the table named "parent". A non-unique
        index is automatically created on columns <literal>(c1, c2)</literal>
        in the table named "child". Columns <literal>p1</literal> and
        <literal>c1</literal> must be of the same type (INTEGER). Columns
        <literal>p2</literal> and <literal>c2</literal> must be of the same
        type (VARCHAR).</para>
      </section>

      <section>
        <title>Indexes and Query Speed</title>

        <para>HSQLDB does not use indexes to improve sorting of query results.
        But indexes have a crucial role in improving query speed. If no index
        is used in a query on a single table, such as a DELETE query, then all
        the rows of the table must be examined. With an index on one of the
        columns that is in the WHERE clause, it is often possible to start
        directly from the first candidate row and reduce the number of rows
        that are examined.</para>

        <para>Indexes are even more important in joins between multiple
        tables. <literal>SELECT ... FROM t1 JOIN t2 ON t1.c1 = t2.c2
        </literal> is performed by taking rows of t1 one by one and finding a
        matching row in t2. If there is no index on t2.c2 then for each row of
        t1, all the rows of t2 must be checked. Whereas with an index, a
        matching row can be found in a fraction of the time. If the query also
        has a condition on t1, e.g., <literal>SELECT ... FROM t1 JOIN t2 ON
        t1.c1 = t2.c2 WHERE t1.c3 = 4</literal> then an index on t1.c3 would
        eliminate the need for checking all the rows of t1 one by one, and
        will reduce query time to less than a millisecond per returned row. So
        if t1 and t2 each contain 10,000 rows, the query without indexes
        involves checking 100,000,000 row combinations. With an index on
        t2.c2, this is reduced to 10,000 row checks and index lookups. With
        the additional index on t2.c2, only about 4 rows are checked to get
        the first result row.</para>

        <para>Indexes are automatically created for PRIMARY KEY, UNIQUE, and
        FOREIGN KEY columns. Otherwise you should define an index using the
        CREATE INDEX command.</para>

        <para>Note that in HSQLDB a unique index on multiple columns can be
        used internally as a non-unique index on the first column in the list.
        For example: <literal>CONSTRAINT name1 UNIQUE (c1, c2, c3); </literal>
        means there is the equivalent of <literal>CREATE INDEX name2 ON
        atable(c1);</literal>. So you do not need to specify an extra index if
        you require one on the first column of the list.</para>

        <para>In 1.9.0, a multi-column index will speed up queries that
        contain joins or values on ALL the columns. You need NOT declare
        additional individual indexes on those columns unless you use queries
        that search only on a subset of the columns. For example, rows of a
        table that has a PRIMARY KEY or UNIQUE constraint on three columns or
        simply an ordinary index on those columns can be found efficiently
        when values for all three columns are specified in the WHERE clause.
        For example, <literal>SELECT ... FROM t1 WHERE t1.c1 = 4 AND t1.c2 = 6
        AND t1.c3 = 8 </literal>will use an index on
        <literal>t1(c1,c2,c3)</literal> if it exists.</para>

        <para>As a result of the improvements to multiple key indexes, the
        order of declared columns of the index or constraint has little affect
        on the speed of searches.</para>

        <para>A multi-column index will not speed up queries on the second or
        third column only. The first column must be specified in the JOIN ..
        ON or WHERE conditions.</para>

        <para>Query speed depends a lot on the order of the tables in the JOIN
        .. ON or FROM clauses. For example the second query below should be
        faster with large tables (provided there is an index on
        <literal>TB.COL3</literal>). The reason is that
        <literal>TB.COL3</literal> can be evaluated very quickly if it applies
        to the first table (and there is an index on
        <literal>TB.COL3</literal>):</para>

        <informalexample>
          <programlisting>
    (TB is a very large table with only a few rows where TB.COL3 = 4)

    SELECT * FROM TA JOIN TB ON TA.COL1 = TB.COL2 AND TB.COL3 = 4;

    SELECT * FROM TB JOIN TA ON TA.COL1 = TB.COL2 AND TB.COL3 = 4;</programlisting>
        </informalexample>

        <para>The general rule is to put first the table that has a narrowing
        condition on one of its columns.</para>

        <para>HyperSQL features automatic, on-the-fly indexes for views and
        subselects that are used in a query.</para>
      </section>

      <section>
        <title>Where Condition or Join</title>

        <para>Unlike previous versions, HyperSQL 1.9.0 can use any relevant
        indexes for query processing, whether the query condition is specified
        in the <literal>WHERE</literal> clause or in a <literal>JOIN</literal>
        condition. It is better to use <literal>JOIN</literal> conditions, as
        they make queries more readable.</para>
      </section>

      <section>
        <title>Subqueries and Inline tables in Joins</title>

        <para>New capabilities in HSQLDB 1.9.0 **todo**...</para>

        <example>
          <title>query example</title>

          <programlisting>

    SELECT ... FROM (SELECT MAX(TB.COL2) C1 FROM TB WHERE TB.COL3 = 4) T2 JOIN TA ON TA.COL1 = T2.C1</programlisting>
        </example>

        <para>More on new capabilities...</para>
      </section>
    </section>

    <section xml:id="sqlissues_types_ops-sect">
      <title>Types and Arithmetic Operations</title>

      <para>Table columns of all types supported by HSQLDB can be indexed and
      can feature in comparisons. Types can be explicitly converted using the
      CAST expression, but in most cases they are converted automatically. It
      is recommended not to use indexes on LONGVARBINARY, LONGVARCHAR and
      OTHER columns, as these indexes will probably not be allowed in future
      versions.</para>

      <para>The following rules govern operations on numbers:</para>

      <para>TINYINT, SMALLINT, INTEGER, BIGINT, NUMERIC and DECIMAL (without a
      decimal point) are supported integral types. They correspond
      respectively to <classname>short</classname>,
      <classname>int</classname>, <classname>long</classname>,
      <classname>BigDecimal</classname> and <classname>BigDecimal</classname>
      Java types in the range of values that they can represent (NUMERIC and
      DECIMAL are equivalent). The SQL type dictates the maximum and minimum
      values that can be held in a field of each type. For example the value
      range for TINYINT is -128 to +127, although the actual Java type used
      for handling TINYINT is <classname>java.lang.Integer</classname>.</para>

      <para>REAL, FLOAT, DOUBLE are equivalent and all mapped to
      <classname>double</classname> in Java.</para>

      <para>DECIMAL and NUMERIC with decimal fractions are mapped to
      <classname>java.math.BigDecimal</classname> and can have very large
      numbers of digits.</para>

      <section>
        <title>Integral Types</title>

        <para>TINYINT, SMALLINT, INTEGER, BIGINT, NUMERIC and DECIMAL (without
        a decimal point) are fully interchangeable internally, and no data
        narrowing takes place. Depending on the types of the operands, the
        result of the operations is returned in a JDBC
        <classname>ResultSet</classname> in any of related Java types:
        <classname>Integer</classname>, <classname>Long</classname> or
        <classname>BigDecimal</classname>. The
        <methodname>ResultSet.getXXXX()</methodname> methods can be used to
        retrieve the values so long as the returned value can be represented
        by the resulting type. This type is deterministically based on the
        query, not on the actual rows returned. The type does not change when
        the same query that returned one row, returns many rows as a result of
        adding more data to the tables.</para>

        <para>If the SELECT statement refers to a simple column or function,
        then the return type is the type corresponding to the column or the
        return type of the function. For example:</para>

        <informalexample>
          <programlisting>    CREATE TABLE t(a INTEGER, b BIGINT);
    SELECT MAX(a), MAX(b) FROM t;</programlisting>
        </informalexample>

        <para>will return a <classname>ResultSet</classname> where the type of
        the first column is <classname>java.lang.Integer</classname> and the
        second column is <classname>java.lang.Long</classname>.
        However,</para>

        <informalexample>
          <programlisting>    SELECT MAX(a) + 1, MAX(b) + 1 FROM t;</programlisting>
        </informalexample>

        <para>will return <classname>java.lang.Long</classname> and
        <classname>BigDecimal</classname> values, generated as a result of
        uniform type promotion for all the return values. Note that type
        promotion to <classname>BigDecimal</classname> ensures the correct
        value is returned if <literal>MAX(b)</literal> evaluates to
        <literal>Long.MAX_VALUE</literal>.</para>

        <para>There is no built-in limit on the size of intermediate integral
        values in expressions. As a result, you should check for the type of
        the <classname>ResultSet</classname> column and choose an appropriate
        <methodname>getXXXX()</methodname> method to retrieve it. Alternatively, you
        can use the <methodname>getObject()</methodname> method, then cast the
        result to <classname>java.lang.Number </classname> and use the
        <methodname>intValue()</methodname> or
        <methodname>longValue()</methodname> methods on the result.</para>

        <para>When the result of an expression is stored in a column of a
        database table, it has to fit in the target column, otherwise an error
        is returned. For example when <literal>1234567890123456789012 /
        12345687901234567890</literal> is evaluated, the result can be stored
        in any integral type column, even a TINYINT column, as it is a small
        value.</para>
      </section>

      <section>
        <title>Other Numeric Types</title>

        <para>In SQL statements, numbers with a decimal point are treated as
        DECIMAL unless they are written with an exponent. Thus
        <literal>0.2</literal> is considered a DECIMAL value but
        <literal>0.2E0</literal> is considered a DOUBLE value.</para>

        <para>When <methodname>PreparedStatement.setDouble()</methodname> or
        <methodname>setFloat()</methodname> is used, the value is treated as a
        DOUBLE automatically.</para>

        <para>When a REAL, FLOAT or DOUBLE (all synonymous) is part of an
        expression, the type of the result is DOUBLE.</para>

        <para>Otherwise, when no DOUBLE value exists, if a DECIMAL or NUMERIC
        value is part an expression, the type of the result is DECIMAL. The
        result can be retrieved from a <classname>ResultSet</classname> in the
        required type so long as it can be represented. This means DECIMAL
        values can be converted to DOUBLE unless they are beyond the
        <literal>Double.MIN_VALUE - Double.MAX_VALUE</literal> range. Similar
        to integral values, when the result of an expression is stored in a
        table column, it has to fit in the target column, otherwise an error
        is returned.</para>

        <para>The distinction between DOUBLE and DECIMAL is important when a
        division takes place. When the terms are DECIMAL, the result is a
        value with a scale (number of digits to the right of the decimal
        point) equal to the larger of the scales of the two terms. With a
        DOUBLE term, the scale will reflect the actual result of the
        operation. For example, <literal>10.0/8.0</literal> (DECIMAL) equals
        <literal>1.2</literal> but <literal>10.0E0/8.0E0</literal> (DOUBLE)
        equals <literal>1.25</literal>. Without division operations, DECIMAL
        values represent exact arithmetic; the resulting scale is the sum of
        the scales of the two terms when multiplication is performed.</para>

        <para>REAL, FLOAT and DOUBLE values are all stored in the database as
        <classname>java.lang.Double</classname> objects. Special values such
        as NaN and +-Infinity are also stored and supported. These values can
        be submitted to the database via JDBC PreparedStatement methods and
        are returned in <classname>ResultSet</classname> objects.</para>
      </section>

      <section>
        <title>Bit and Boolean Types</title>

        <para>In previous versions, BIT was simply an alias for BOOLEAN. In
        1.9.0 BIT is a single-bit bit map, while BIT(n) and BIT VARYING(n) are
        strings of bits..</para>

        <para>The primary representation of BOOLEAN column is
        <literal>'true'</literal> or <literal>'false'</literal> either as the
        boolean type or as strings when used from JDBC. This type of column
        can also be initialised using values of any numeric type. In this case
        <literal>0</literal> is translated to <literal>false</literal> and any
        other value such as 1 is translated to <literal>true</literal>.</para>

        <para>The BOOLEAN type conforms to the SQL standards and supports the
        UNDEFINED state in addition to TRUE or FALSE. NULL values are treated
        as undefined. The three-value logic is sometimes misunderstood. For
        example, x IN (1, 2, NULL) does not return true if x is NULL. See the
        test text file, TestSelfNot.txt, for some examples of queries and the
        expected results.</para>
      </section>

      <section>
        <title>Storage and Handling of Java Objects</title>

        <para>Any serializable JAVA Object can be inserted directly into a
        column of type OTHER using any variation of
        <methodname>PreparedStatement.setObject()</methodname> methods.</para>

        <para>For comparison purposes and in indexes, any two Java Objects are
        considered equal unless one of them is NULL. You cannot search for a
        specific object or perform a join on a column of type OTHER.</para>

        <para>Please note that HSQLDB is not an object-relational database.
        Java Objects can simply be stored internally and no operations should
        be performed on them other than assignment between columns of type
        OTHER or tests for NULL. Tests such as <literal>WHERE object1 =
        object2</literal>, or <literal>WHERE object1 = ? </literal>do not mean
        what you might expect, as any non-null object would satisfy such a
        tests. But <literal>WHERE object1 IS NOT NULL</literal> is perfectly
        acceptable.</para>

        <para>The engine does not allow normal column values to be assigned to
        Java Object columns (for example assigning an INTEGER or STRING to
        such a column with an SQL statement such as <literal>UPDATE mytable
        SET objectcol = intcol WHERE ...</literal>).</para>
      </section>

      <section>
        <title>Type Size, Precision and Scale</title>

        <para>In older version of HSQLDB, all table column type definitions
        with a column size, precision or scale qualifier were accepted and
        ignored. HSQLDB 1.8.0 enforced correctness but included an option to
        enforce the size, precision or scale.</para>

        <para>In 1.9.0, size, precision and scale qualifiers are always
        enforced.</para>

        <para>String types, including all BIT, BINARY and CHAR string types
        plus CLOB and BLOB, are generally defined with a size. If no size is
        specified, the default size is 1.</para>

        <para>TIME and TIMESTAMP types can be defined with a fractional second
        precision between 0 and 9. INTERVAL type definition may have precision
        and, in some cases, fraction second precision. DECIMAL and NUMERIC
        types may be defined with precision and scale. For all of these types
        a default precision or scale value is used if one is not
        specified.</para>

        <para>Values are be changed from one type to another in two different
        ways: by using explicit CAST expression or by implicit conversion used
        in assignment, comparison and aggregation.</para>

        <para>String values cannot be assigned to VARCHAR columns if they are
        longer than the defined type size. For CHARACTER columns, a long
        string can be inserted (with truncation) only if all the characters
        after the size are spaces. Shorter strings are padded with the space
        character when inserted into a CHARACTER column. Similar rules are
        applied to VARBINARY and BINARY columns. For BINARY columns, the
        padding and truncation rules are applied with zero bytes, instead of
        spaces.</para>

        <para>Explicit CAST of a value to a CHARACTER or VARCHAR type will
        result in forced truncation or padding. So a test such as
        <literal>CAST (mycol AS VARCHAR(2)) = 'xy'</literal> will find the
        values beginning with 'xy'. This is the equivalent of
        <literal>SUBSTRING(mycol FROM 1 FOR 2)= 'xy'</literal>.</para>

        <para>For all numeric types, the rules of explicit cast and implicit
        conversion are the same. If cast or conversion causes any digits to be
        lost from the fractional part, it can take place. If the
        non-fractional part of the value cannot be represented in the new
        type, cast or conversion cannot take place and will result in a data
        exception.</para>

        <para>There are special rules for DATE, TIME, TIMESTAMP and INTERVAL
        casts and conversions.</para>
      </section>
    </section>

    <section xml:id="sqlissies_seq_identitis-sect">
      <title>Sequences and Identity</title>

      <para>The SEQUENCE objects and IDENTITY columns are supported fully
      according to the latest SQL 200n Standard syntax.</para>

      <section>
        <title>Identity Auto-Increment Columns</title>

        <para>Each table can contain a single auto-increment column, known as
        the IDENTITY column. An IDENTITY column is a SMALLINT, INTEGER,
        BIGINT, DECIMAL or NUMERIC column with its value generated by a
        sequence generator.</para>

        <para>In HyperSQL 1.9.0, an IDENTITY column is not by default treated
        as the primary key for the table (as a result, multi-column primary
        keys are possible with an IDENTITY column present).</para>

        <para>The SQL standard syntax is used, which allows the initial value
        and other options to be specified.<programlisting>    &lt;colname&gt; INTEGER GENERATED { BY DEFAULT | ALWAYS} AS IDENTITY [( &lt;options&gt; )] [PRIMARY KEY]</programlisting></para>

        <para>When you add a new row to such a table using an <literal>INSERT
        INTO &lt;tablename&gt; ...; </literal>statement, you can use the NULL
        value for the IDENTITY column, which results in an auto-generated
        value for the column. The <literal>IDENTITY() </literal>function
        returns the last value inserted into any IDENTITY column by this
        connection. Use <literal>CALL IDENTITY(); </literal>as an SQL
        statement to retrieve this value. If you want to use the value for a
        field in a child table, you can use <literal>INSERT INTO
        &lt;childtable&gt; VALUES (...,IDENTITY(),...);</literal>. Both types
        of call to<literal> IDENTITY()</literal> must be made before any
        additional update or insert statements are issued on the
        database.</para>

        <para>The next IDENTITY value to be used can be set with following
        command: <programlisting>    ALTER TABLE ALTER COLUMN &lt;column name&gt; RESTART WITH &lt;new value&gt;;</programlisting>For
        backward compatibility, support has been retained for <literal>CREATE
        TABLE &lt;tablename&gt;(&lt;colname&gt; IDENTITY, ...)</literal> as a
        shortcut which defines the column both as an IDENTITY column and a
        PRIMARY KEY column.</para>
      </section>

      <section>
        <title>Sequences</title>

        <para>The SQL 200n syntax and usage is different from what is
        supported by many existing database engines. Sequences are created
        with the <literal>CREATE SEQUENCE</literal> command and their current
        value can be modified at any time with <literal>ALTER
        SEQUENCE</literal>. The next value for a sequence is retrieved with
        the <literal>NEXT VALUE FOR &lt;name&gt;</literal> expression. This
        expression can be used for inserting and updating table rows.</para>

        <example>
          <title>inserting the next sequence value into a table row</title>

          <programlisting>    INSERT INTO mytable VALUES 2, 'John', NEXT VALUE FOR mysequence;</programlisting>
        </example>

        <para>You can also use it in select statements. For example, if you
        want to number the returned rows of a SELECT in sequential order, you
        can use:</para>

        <example>
          <title>numbering returned rows of a SELECT in sequential
          order</title>

          <programlisting>    SELECT NEXT VALUE FOR mysequence, col1, col2 FROM mytable WHERE ...</programlisting>
        </example>

        <para>In version 1.9.0, the semantics of sequences is exactly as
        defined by SQL 200n. If you use the same sequence twice in the same
        row in an INSERT statement, you will get the same value as required by
        the Standard.</para>

        <para>You can query the SEQUENCES table for the next value that will
        be returned from any of the defined sequences. The SEQUENCE_NAME
        column contains the name and the NEXT_VALUE column contains the next
        value to be returned. Note that this is only for getting information
        and you should not do this for using the sequence value.</para>
      </section>
    </section>

    <section xml:id="sqlissues_trans_cc-sect">
      <title>Transactions and Concurrency Control</title>

      <para>Before version 1.9, HSQLDB supported READ UNCOMMITTED transaction
      isolation. Al this isolation level, uncommitted changes made to the data
      by a session are visible to other, concurrent sessions.</para>

      <para>HyperSQL 2.0 supports 4 levels of transaction isolation: READ
      UNCOMMITTED, READ COMMITTED, REPEATABLE READ and SERIALIZABLE. It also
      supports two concurrency control modes, two-phased-locking (2PL) and
      multiversion concurrency control (MVCC). The isolation level is a
      property of each SQL session, so different sessions can have different
      isolation levels. The concurrency control strategy governs all the
      sessions and is set for the database, as opposed for individual
      sessions. Isolation levels above READ UNCOMMITTED avoid the "dirty read"
      phenomenon and do not read uncommitted changes made to rows by other
      transactions.</para>

      <section>
        <title>Two Phased Locking</title>

        <para>In the 2PL mode, each table that is read by a transaction is
        locked with a shared lock, and each table that is written to is locked
        with an exclusive lock. If two sessions read and modify different
        tables then both go through simultaneously. If one session tries to
        lock a table that has been exclusively locked by the other, the engine
        will put it in wait, or it will invalidate the action it is attempting
        to perform, depending on the locks.</para>

        <para>When a transaction is running in read-only mode (or the session
        is in read-only mode), then it will not lock the tables and will go
        ahead and complete regardless of what other transactions may do. The
        READ UNCOMMITTED isolation level can be used in this mode for
        read-only operations.</para>

        <para>If a table is read-only, it will not be locked by any
        transaction.</para>
      </section>

      <section>
        <title>MVCC</title>

        <para>In MVCC mode, there are no shared, read locks. Exclusive locks
        are used on individual rows, but their use is different. Transactions
        can read and modify the same table simultaneously, generally without
        waiting for other transactions.</para>

        <para>When transactions are running in READ COMMITTED mode, no
        conflict will occur. If a transaction that runs in this mode wants to
        modify a row that has been modified by another uncommitted
        transaction, then the engine puts the transaction in wait, until the
        other transaction has committed. The transaction then continues
        automatically.</para>

        <para>When transactions are running in REPEATABLE READ or SERIALIZABLE
        isolation modes, conflict can happen. There is no difference in
        operation between these two isolation modes. If a transaction that
        runs in this mode wants to modify a row that has been modified by
        another uncommitted transaction, the engine allows it to go ahead
        despite the conflict. When one of the conflicting sessions commits,
        the commit goes through. But when committing, the engine will
        invalidate the other, conflicting transaction and roll back all its
        changes.</para>

        <para>In this mode, READ UNCOMMITTED is promoted to READ COMMITTED, as
        the new architecture is based on multi-version rows for uncommitted
        data and more than one version may exist for some rows.</para>

        <para>In all isolation modes, when a transaction only reads data, then
        it will go ahead and complete regardless of what other transactions
        may do. This does not depend on the transaction being
        read-only.</para>
      </section>

      <section>
        <title>Commands</title>

        <para>The following SQL command switches the concurrency control mode
        for the database. It can be issued only when all sessions have been
        committed or rolled back.</para>

        <para><programlisting>SET DATABASE TRANSACTION CONTROL { LOCKS | MVCC }</programlisting>The
        default isolation level for a session is READ COMMITTED. This can be
        changed using the JDBC <classname>java.sql.Connection</classname>
        object and its <methodname>setTransactionIsolation(int
        level)</methodname> method. The session can be put in read-only mode
        using the <methodname>setReadOnly(boolean readOnly)</methodname>
        method. Both methods can be invoked only after a commit or a
        rollback.</para>

        <para>The isolation level and / or the read only mode of a transaction
        can be modified using the same SQL command. You can use the command to
        change only the isolation mode, only the read-only mode, or both at
        the same time. This command can be issued only after a commit or
        rollback.</para>

        <para><programlisting>SET TRANSACTION &lt;transaction characteristic&gt; [ &lt;comma&gt; &lt;transaction characteristic&gt; ]

&lt;transaction characteristic&gt; :=
{ ISOLATION LEVEL { READ COMMITTED | REPEATABLE READ | SERIALIZABLE } } | { READ ONLY | READ WRITE }
</programlisting>More on transactions</para>
      </section>
    </section>
  </chapter>

  <chapter xml:id="server-chapt">
    <title xml:id="server-title">HyperSQL Network Listeners</title>

    <subtitle>Server, WebServer, and Servlet</subtitle>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Server</keyword>

        <keyword>Listener</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="listeners-sect">
      <title>Listeners</title>

      <para>As described in the **todo** chapter, network listeners or servers
      provide connectivity to catalogs from different JVM processes.</para>

      <section xml:id="listeners_hsqlserver-sect">
        <title>HyperSQL Server</title>

        <para>This is the preferred way of running a database server and the
        fastest one. This mode uses the proprietary
        <glossterm>hsql:</glossterm> communications protocol. The following
        example of the command for starting the server starts the server with
        one (default) database with files named "mydb.*" and the public name
        (alias) of "xdb".</para>

        <informalexample>
          <screen>
    java -cp ../lib/hsqldb.jar org.hsqldb.server.Server --database.0 file:mydb --dbname.0 xdb</screen>
        </informalexample>

        <para>Alternatively, a server.properties file can be used for passing
        the arguments to the server. This file must be located in the
        directory where the command is issued.</para>

        <screen>
    java -cp ../lib/hsqldb.jar org.hsqldb.server.Server</screen>

        <para>The contents of the server.properties file is described in the
        next section.</para>
      </section>

      <section xml:id="listeners_httpserver-sect">
        <title>HyperSQL HTTP Server</title>

        <para>This method of access is used when the computer hosting the
        database server is restricted to the HTTP protocol. The only reason
        for using this method of access is restrictions imposed by firewalls
        on the client or server machines and it should not be used where there
        are no such restrictions. The HyperSQL HTTP Server is a special web
        server that allows JDBC clients to connect via HTTP. The server can
        also act as a small general-purpose web server for static
        pages.</para>

        <para>To run an HTTP server, replace the main class for the server in
        the example command line above with the following:</para>

        <informalexample>
          <screen>
    java -cp ../lib/hsqldb.jar org.hsqldb.server.Server</screen>
        </informalexample>

        <para>The contents of the server.properties file is described in the
        next section.</para>
      </section>

      <section xml:id="listeners_servlet-sect">
        <title>HyperSQL HTTP Servlet</title>

        <para>This method of access also uses the HTTP protocol. It is used
        when a separate servlet engine (or application server) such as Tomcat
        or Resin provides access to the database. The Servlet Mode cannot be
        started independently from the servlet engine. The
        <filename>Servlet</filename> class, in the HSQLDB jar, should be
        installed on the application server to provide the connection. The
        database is specified using an application server property. Refer to
        the source file <filename>org.hsqldb.server.Servlet.java</filename> to
        see the details.</para>

        <para>Both HTTP Server and Servlet modes can only be accessed using
        the JDBC driver at the client end. They do not provide a web front end
        to the database. The Servlet mode can serve only a single
        database.</para>

        <para>Please note that you do not normally use this mode if you are
        using the database engine in an application server. In this situation,
        connections to a catalog are usually made
        <glossterm>in-process</glossterm>, or using an external HSQL Server
        instance.</para>
      </section>
    </section>

    <section xml:id="listeners_server_props-sect">
      <title>Server and Web Server Properties</title>

      <para>Properties files for running the servers are not created
      automatically. You should create your own files that contain
      <property>server.property</property>=<literal>value</literal> pairs for
      each property. The <filename>server.properties</filename> or
      <filename>webserver.properties</filename> files must be located in the
      directory where the command to run the
      <classname>org.hsqldb.server.Server</classname> class is issued.</para>

      <para>In all properties files, values are case-sensitive. All values
      apart from names of files or pages are required in lowercase (e.g.
      <property>server.silent</property>=<literal>FALSE</literal> will have no
      effect, but <property>server.silent</property>=<literal>false</literal>
      will work). Supported properties and their default values (if any) are
      as follows:</para>

      <table frame="all" pgwide="1" tocentry="1">
        <title>common server and webserver properties</title>

        <tgroup align="left" cols="3">
          <thead>
            <row>
              <entry>Value</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>
                <property>server.database.0</property>
              </entry>

              <entry>
                <literal>file:test</literal>
              </entry>

              <entry>the catalog type, path and file name of the first
              database file to use</entry>
            </row>

            <row>
              <entry>
                <property>server.dbname.0</property>
              </entry>

              <entry>
                <literal>""</literal>
              </entry>

              <entry>lowercase server alias for the first database
              file</entry>
            </row>

            <row>
              <entry>
                <property>server.urlid.0</property>
              </entry>

              <entry>
                <literal>NO DEFAULT</literal>
              </entry>

              <entry>SqlTool urlid used by UNIX init script. (This property is
              not used if your are running Server/Webserver on a platform
              other than UNIX, or if you are not using our UNIX init
              script).</entry>
            </row>

            <row>
              <entry>
                <property>server.database.n</property>
              </entry>

              <entry>
                <literal>NO DEFAULT</literal>
              </entry>

              <entry>the catalog type, path and file name of the n'th database
              file in use</entry>
            </row>

            <row>
              <entry>
                <property>server.dbname.n</property>
              </entry>

              <entry>
                <literal>NO DEFAULT</literal>
              </entry>

              <entry>lowercase server alias for the n'th database file</entry>
            </row>

            <row>
              <entry>
                <property>server.silent</property>
              </entry>

              <entry>
                <literal>true</literal>
              </entry>

              <entry>no extensive messages displayed on console</entry>
            </row>

            <row>
              <entry>
                <property>server.trace</property>
              </entry>

              <entry>
                <literal>false</literal>
              </entry>

              <entry>JDBC trace messages displayed on console</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In 1.9.0, each server can serve an unlimited number databases
      simultaneously. The <property>server.database.0</property> property
      defines the filename / path whereas the
      <property>server.dbname.0</property> defines the lowercase alias used by
      clients to connect to that database. The digit 0 is incremented for the
      second database and so on. Values for the
      <property>server.database.n</property> property can use the
      <glossterm>mem:</glossterm>, <glossterm>file:</glossterm> or
      <glossterm>res:</glossterm> prefixes and connection properties as discussed
      under CONNECTIONS. For example, <informalexample>
          <programlisting>
    database.0=mem:temp;sql.enforce_strict_size=true;</programlisting>
        </informalexample></para>

      <para>Properties or default values specific to
      <filename>server.properties</filename> are:</para>

      <table frame="all" pgwide="1" tocentry="1">
        <title>server properties</title>

        <tgroup align="left" cols="3">
          <thead>
            <row>
              <entry>Value</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>
                <property>server.port</property>
              </entry>

              <entry>
                <literal>9001 (normal) or 554 (if TLS encrypted)</literal>
              </entry>

              <entry>TCP/IP port used for talking to clients. All databases
              are served on the same port.</entry>
            </row>

            <row>
              <entry>
                <property>server.no_system_exit</property>
              </entry>

              <entry>
                <literal>true</literal>
              </entry>

              <entry>no <literal>System.exit()</literal> call when the
              database is closed</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Properties or default values specific to
      <filename>webserver.properties</filename> are:</para>

      <table frame="all" pgwide="1" tocentry="1">
        <title>webserver properties</title>

        <tgroup align="left" cols="3">
          <thead>
            <row>
              <entry>Value</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>
                <property>server.port</property>
              </entry>

              <entry>
                <literal>80</literal>
              </entry>

              <entry>TCP/IP port used for talking to clients</entry>
            </row>

            <row>
              <entry>
                <property>server.default_page</property>
              </entry>

              <entry>
                <literal>index.html</literal>
              </entry>

              <entry>the default web page for server</entry>
            </row>

            <row>
              <entry>
                <property>server.root</property>
              </entry>

              <entry>
                <literal>./</literal>
              </entry>

              <entry>the location of served pages</entry>
            </row>

            <row>
              <entry>
                <property>.&lt;extension&gt;</property>
              </entry>

              <entry>
                <literal>NO DEFAULT</literal>
              </entry>

              <entry>multiple entries such as
              <literal>.html=text/html</literal> define the mime types of the
              static files served by the web server. See the source for
              <filename>WebServer.java</filename> for a list.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>An example of the contents of a
      <filename>server.properties</filename> file is given below:</para>

      <programlisting>
    server.database.0=file:/opt/db/accounts
    server.dbname.0=accounts

    server.database.1=file:/opt/db/mydb
    server.dbname.1=enrollments

    server.database.2=mem:adatabase
    server.dbname.2=quickdb</programlisting>

      <para>In the above example, the <filename>server.properties</filename>
      file indicates that the server provides access to 3 different databases.
      Two of the databases are file-based, while the third is all-in-memory.
      The aliases for the databases that the users connect to are
      <literal>accounts</literal>, <literal>enrollments</literal> and
      <literal>quickdb</literal>.</para>

      <para>All the above properties and their values can be specified on the
      command line to start the server by omitting the
      <literal>server.</literal> prefix. If a property/value pair is specified
      on the command line, it overrides the property value specified in the
      <filename>server.properties</filename> or
      <filename>webserver.properties</filename> file.</para>

      <note>
        <para>Upgrading: If you have existing custom properties files, change
        the values to the new naming convention. Note the use of digits at the
        end of <property>server.database.n</property> and
        <property>server.dbname.n</property> properties.</para>
      </note>
    </section>

    <section xml:id="listeners_appstart-sect">
      <title>Starting a Server from your application</title>

      <para>If you want to start the server from within your application, as
      opposed to the command line or batch files, you should create an
      instance of Server or Web Server, then assign the properties and start
      the Server. An working example of this can be found in the
      <classname>org.hsqldb.test.TestBase</classname> source. The example
      below sets the same properties as in the server.properties file
      example.</para>

      <programlisting>
    HsqlProperties p = new HsqlProperties();
    p.setProperty("server.database.0","file:/opt/db/accounts");
    p.setProperty("server.dbname.0","an_alias");
    // set up the rest of properties
    Server server = new Server();
    server.setProperties(p);
    server.setLogWriter(null); // can use custom writer
    server.setErrWriter(null); // can use custom writer
    server.start();
</programlisting>

      <para>The Server object has several alternative methods for setting
      databases and their public names. The server should be shutdown using
      the shutdown() method.</para>

      <para>**todo** restart on shutdown etc. modes</para>

      <para />
    </section>

    <section xml:id="listeners_tls-sect">
      <title xml:id="tls-sect-title">TLS Encryption</title>

      <subtitle>Listener TLS Support (a. k. a. SSL)</subtitle>

      <info>
        <authorgroup>
          <author>
            <personname>
              <firstname>Blaine</firstname>

              <surname>Simpson</surname>
            </personname>

            <email>&blaine_addr;</email>

            <affiliation>
              <orgname>HSQLDB Development Group</orgname>
            </affiliation>
          </author>
        </authorgroup>

        <edition>$Revision$</edition>

        <pubdate>$Date: 2008-12-04 20:36:53 +0000 (Thu, 04 Dec 2008)
        $</pubdate>

        <keywordset>
          <keyword>HyperSQL</keyword>

          <keyword>HSQLDB</keyword>

          <keyword>TLS</keyword>

          <keyword>SSL</keyword>

          <keyword>JSSE</keyword>

          <keyword>Security</keyword>
        </keywordset>
      </info>

      <para>This section explains how to encrypt the stream between JDBC
      network clients and HyperSQL Listeners. If you are running an
      <glossterm>in-process</glossterm> (non-Listener) setup, this chapter
      does not apply to you.</para>

      <section>
        <title>Requirements</title>

        <itemizedlist>
          <title>Hsqldb TLS Support Requirements</title>

          <listitem>
            <para>Sun Java 2.x and up. (This is probably possible with IBM's
            Java, but I don't think anybody has attempted to run HSQLDB with
            TLS under IBM's Java, and I'm sure that nobody in the HSQLDB
            Development Group has documented how to set up the
            environment).</para>
          </listitem>

          <listitem>
            <para>If Java 2.x or 3.x, then you will need to <link
            linkend="jsse-sect">install JSSE</link>. Your server and/or client
            will start up much slower than that of Java 4.x users. Client-side
            users will not be able to use the https: JDBC protocol (because
            the https protocol handler is not implemented in 2.x/3.x Java
            JSSE; if there is demand, we could work around this).</para>
          </listitem>

          <listitem>
            <para>A <link linkend="privatekey-sect">JKS keystore containing a
            private key</link>, in order to run a Listener.</para>
          </listitem>

          <listitem>
            <para>If you are running the listener side, then you'll need to
            run a HSQLDB Server or WebServer Listener instance. It doesn't
            matter if the underlying database catalogs are new, and it doesn't
            matter if you are making a new Listener configuration or
            encrypting an existing Listener configuration. (You can turn
            encryption on and off at will).</para>
          </listitem>

          <listitem>
            <para>You need a HSQLDB jar file that was built with JSSE present.
            If you obtained your HSQLDB 1.7.2-or-later distribution from us,
            you are all set, because we build with Java 1.4 or later (which
            contains JSSE). If you build your own jar file with Java 1.3, make
            sure to install JSSE first.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Encrypting your JDBC connection</title>

        <para>At this time, only 1-way, server-cert encryption is
        tested.</para>

        <section>
          <title>Client-Side</title>

          <para>Just use one of the following protocol prefixes.</para>

          <itemizedlist>
            <title>Hsqldb TLS URL Prefixes</title>

            <listitem>
              <para>
                <literal>jdbc:hsqldb:hsqls://</literal>
              </para>
            </listitem>

            <listitem>
              <para>
                <literal>jdbc:hsqldb:https://</literal>
              </para>
            </listitem>
          </itemizedlist>

          <para>At this time, the latter will only work for clients running
          with Java 1.4 or later.</para>

          <para>If the listener you wish to connect to is using a certificate
          approved by your default trust keystore, then there is nothing else
          to do. If not, then you need to tell Java to "trust" the server
          cert. (It's a slight over-simplification to say that if the server
          certificate was purchased, then you are all set; if somebody "signed
          their own" certificate by self-signing or using a private ca
          certificate, then you need to set up trust).</para>

          <para>First, you need to obtain the cert (only the "public" part of
          it). Since this cert is passed to all clients, you could obtain it
          by writing a java client that dumps it to file, or perhaps by using
          <emphasis>openssl s_client</emphasis>. Since in most cases, if you
          want to trust a non-commercial cert, you probably have access to the
          server keystore, I'll show an example of how to get what you need
          from the server-side JKS keystore.</para>

          <para>You may already have an X509 cert for your server. If you have
          a server keystore, then you can generate a X509 cert like this.
          <example>
              <title>Exporting certificate from the server's keystore</title>

              <screen>
    keytool -export -keystore server.store -alias existing_alias -file server.cer</screen>
            </example> In this example, <filename>server.cer</filename> is the
          X509 certificate that you need for the next step.</para>

          <para>Now, you need to add this cert to one of the system trust
          keystores or to a keystore of your own. See <link
          xlink:href="http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CustomizingStores">
          the Customizing Stores section in JSSERefGuide.html</link> to see
          where your system trust keystores are. You can put private keystores
          anywhere you want to. The following command will add the cert to an
          existing keystore, or create a new keystore if
          <filename>client.store</filename> doesn't exist.</para>

          <example>
            <title>Adding a certificate to the client keystore</title>

            <screen>
    keytool -import -trustcacerts -keystore trust.store -alias new_alias -file server.cer</screen>
          </example>

          <para>If you are making a new keystore, you probably want to start
          with a copy of your system default keystore which you can find
          somewhere under your <varname>JAVA_HOME</varname> directory (typically
          jre/lib/security/cacerts for a JDK, but I forget exactly where it is
          for a JRE).</para>

          <para>Unless your OS can't stop other people from writing to your
          files, you probably do not want to set a password on the trust
          keystore.</para>

          <para>If you added the cert to a system trust store, then you are
          finished. Otherwise you will need to specify your custom trust
          keystore to your client program. The generic way to set the trust
          keystore is to set the system property
          <classname>javax.net.ssl.trustStore</classname> every time that you
          run your client program. For example <example>
              <title>Specifying your own trust store to a JDBC client</title>

              <screen>
    java -Djavax.net.ssl.trustStore=/home/blaine/trust.store -jar /path/to/hsqldb.jar dest-urlid</screen>
            </example> This example runs the program <link
          linkend="unix-chapt">SqlTool</link>. SqlTool has built-in TLS
          support however, so, for SqlTool you can set
          <varname>truststore</varname> on a per-urlid basis in the SqlTool
          configuration file.</para>

          <para>Note: The hostname in your database URL must match the
          <emphasis>Common Name</emphasis> of the server's certificate
          exactly. That means that if a site certificate is
          <literal>admc.com</literal>, you can not use
          <literal>jdbc:hsqldb:hsqls://localhost</literal> or
          <literal>jdbc:hsqldb:hsqls://www.admc.com:1100</literal> to connect
          to it.</para>

          <para>If you want more details on anything, see JSSERefGuide.html on
          <link
          xlink:href="http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">
          Sun's site</link>, or in the subdirectory
          <filename>docs/guide/security/jsse</filename> of your Java SE
          docs.</para>
        </section>

        <section>
          <title>Server-Side, aka Listener-Side</title>

          <simpara>Get yourself a <link linkend="privatekey-sect">JKS keystore
          containing a private key</link>. Then set properties
          <varname>system.javax.net.ssl.keyStore</varname> and
          <varname>system.javax.net.ssl.keyStorePassword</varname> in your
          <filename>server.properties</filename> or
          <filename>webserver.properties</filename> file. Set
          <varname>system.javax.net.ssl.keyStore</varname> to the path of the
          private key JKD keystore, and
          <varname>system.javax.net.ssl.keyStorePassword</varname> to the
          password (of both the keystore and the private key record-- they
          must be the same).</simpara>

          <caution xml:id="tlspassword-caution">
            <para>If you set any password in a .properties (or any other)
            file, you need to restrict access to the file. On a good operating
            system, you can do this like so: <informalexample>
                <screen>
    chmod 600 path/to/server.properties</screen>
              </informalexample></para>
          </caution>

          <simpara>The values and behavior of these .properties settings
          exactly match the usage documented for
          <varname>javax.net.ssl.keyStorePassword</varname> and
          <varname>avax.net.ssl.keyStore</varname> in the JSSE docs.</simpara>

          <note>
            <simpara>Before version 1.9, HyperSQL depended on directly setting
            the corresponding JSSE properties. The new idiom is more secure
            and easier to manage. If you have an old password in your config
            file, you should remove it.</simpara>
          </note>
        </section>
      </section>

      <section xml:id="jsse-sect">
        <title>JSSE</title>

        <para>If you are running Java 4.x or later, then you are all set. Java
        1.x users, you are on your own (Sun does not provide a JSSE that will
        work with 1.x). Java 2.x and 3.x users continue...</para>

        <para>Go to <link
        xlink:href="http://java.sun.com/products/jsse/index-103.html" />. If
        you agree to the terms and meet the requirements, download the
        domestic or global JSSE software. All you need from the software
        distro is the three jar files. If you have a JDK installation, then
        move the 3 jar files into the directory
        <filename>$JAVA_HOME/jre/lib/ext</filename>. If you have a JRE
        installation, then move the 3 jar files into the directory
        <filename>$JAVA_HOME/lib/ext</filename>.</para>

        <para>Pretty painless.</para>
      </section>

      <section xml:id="privatekey-sect">
        <title>Making a Private-key Keystore</title>

        <para>There are two main ways to do this. Either you can use a
        certificate signed by a certificate authority, or you can make your
        own. One thing that you need to know in both cases is, the
        <emphasis>Common Name</emphasis> of the cert has to be the exact
        hostname that JDBC clients will use in their database URL.</para>

        <section>
          <title>CA-Signed Cert</title>

          <para>I'm not going to tell you how to get a CA-signed SSL
          certificate. That is well documented at many other places.</para>

          <para>Assuming that you have a standard pem-style private key
          certificate, here's how you can use <link
          xlink:href="http://www.openssl.org">openssl</link> and the program
          <classname>DERImport</classname> to get it into a JKS
          keystore.</para>

          <para>Because I have spent a lot of time on this document already, I
          am just giving you an example.</para>

          <example>
            <title>Getting a pem-style private key into a JKS keystore</title>

            <screen>
    openssl pkcs8 -topk8 -outform DER -in Xpvk.pem -inform PEM -out Xpvk.pk8 -nocrypt

    openssl x509 -in Xcert.pem -out Xcert.der -outform DER

    java DERImport new.keystore NEWALIAS Xpvk.pk8 Xcert.der</screen>
          </example>

          <important>
            <para>Make sure to set the password of the key exactly the same as
            the password for the keystore!</para>
          </important>

          <para>You need the program <filename>DERImport.class</filename> of
          course. Do some internet searches to find
          <filename>DERImport.java</filename> or
          <filename>DERImport.class</filename> and download it.</para>

          <para>If DERImport has become difficult to obtain, I can write a
          program to do the same thing-- just let me know.</para>
        </section>

        <section>
          <title>Non-CA-Signed Cert</title>

          <para>Run <literal>man keytool</literal> or see <link
          xlink:href="http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CreateKeystore">
          the Creating a Keystore section of JSSERefGuide.html</link>.</para>
        </section>
      </section>

      <section>
        <title>Automatic Server or WebServer startup on UNIX</title>

        <para>If you are on UNIX and want to automatically start and stop a
        Server or WebServer running with encryption, set the
        <varname>system.javax.net.ssl.keyStore</varname> and
        <varname>system.javax.net.ssl.keyStorePassword</varname> properties as
        instructed above, and follow the instructions in the <link
        endterm="unix-title" linkend="unix-chapt" /> chapter, paying close
        attention to the TLS-related comments in the template config
        file.</para>

        <para>If you are using a private server certificate, make sure to also
        set the trust store filepath for relevant urlids in your RC file, as
        explained in the sample config file.</para>
      </section>
    </section>

    <section xml:id="listeners_acl-sect">
      <title>Network Access Control</title>

      <subtitle>Aka Server ACLs</subtitle>

      <simpara>JDBC connections will always be denied if the supplied user and
      password are not found in the target catalog. But an HyperSQL listener
      can also restrict access at the listener level, even protecting private
      catalogs which have insecure (or default) passwords. If you have an
      <glossterm>in-process</glossterm> setup, this section of the Guide
      doesn't apply to you.</simpara>

      <simpara>Many (in fact, most) distributed database applications don't
      have application clients connect directly to the database, but instead
      encapsulate access in a controlling process. For example, a web app will
      usually access the data source on behalf of users, with end-user web
      browsers never accessing the database directly. In these cases and
      others, the security benefits of restricting listener access to specific
      source addresses is well worth the effort. ACLs work by restricting
      access according to the source address of the incoming connection
      request. This is efficient because the database engine never even gets
      the request until it is approved by the ACL filter code.</simpara>

      <para>The sample file located at <filename>sample/acl.txt</filename> in
      your HyperSQL distribution explains how to write an ACL file.
      <programlisting><xi:include href="../verbatim/sample/acl.txt"
            parse="text" /></programlisting> You put your file wherever it is
      convenient for you, and specify that path with the property
      <varname>server.acl</varname> or <varname>webserver.acl</varname> in
      your <filename>server.properties</filename> or
      <filename>webserver.properties</filename> file (depending on whether
      your listener instance is a <classname>Server</classname> or
      <classname>WebServer</classname>. You can specify the ACL file path with
      an absolute or relative path. If you use a relative path, it must be
      relative to the <filename>.properties</filename> file. It's often
      convenient to name the ACL file <filename>acl.txt</filename>, in the
      same directory as your <filename>.properties</filename> file and specify
      the property value as just <filename>acl.txt</filename>. This file name
      is intuitive, and things will continue to work as expected if you move
      or copy the entire directory.</para>

      <warning>
        <simpara>If your <classname>Server</classname> or
        <classname>WebServer</classname> was started with a
        <varname>*.acl</varname> property, changes afterwards to the ACL file
        will be picked up immediately by your listener instance. You are
        advised to use the procedure below to prevent partial edits or
        mistakes from crippling your running server.</simpara>
      </warning>

      <para>When you edit your ACL file, it is both more convenient and more
      secure to test it as explained here before activating it. You could, of
      course, test an ACL file by editing it in-place, then trying to connect
      to your listener with JDBC clients from various source addresses.
      Besides being mightily laborious and boring, with this method it is very
      easy to accidentally open access to all source addresses or to deny
      access to all users until you fix incorrect ACL entries.</para>

      <para>The suggested method of creating or changing ACLs is to work with
      an inactive file (for new ACL files, just don't enable the
      <varname>*.acl</varname> property yet; for changing an existing file,
      just copy it to a temporary file and edit the temporary file). Then use
      the <classname>ServerAcl</classname> class to test it. <example>
          <title>Validating and Testing an ACL file</title>

          <screen>
    java -cp path/to/hsqldb.jar org.hsqldb.server.ServerAcl path/to/acl.txt</screen>
        </example> If the specified ACL file fails validation, you will be
      given details about the problem. Otherwise, the validated rules will be
      displayed (including the implicit, default deny rules). You then type in
      host names and addresses, one-per-line. Each name or address is tested
      as if it were a HyperSQL network client address, using the same exact
      method that the HyperSQL listener will use. (HyperSQL listeners use this
      same <classname>ServerAcl</classname> class to test incoming source
      addresses). <classname>ServerAcl</classname> will report the rule which
      matches and whether access is denied or allowed to that address.</para>

      <simpara>If you have edited a copy of an existing ACL file (as suggested
      above), then overwrite your live ACL file with your new, validated ACL
      file. I.e., copy your temp file over top of your live ACL
      file.</simpara>

      <simpara><classname>ServerAcl</classname> can be run in the same exact
      way described above, to troubleshoot runtime access issues. If you use
      an ACL file and a user or application can't get a connection to the
      database, you can run <classname>ServerAcl</classname> to quickly and
      definitively find if the client is being prohibited by an ACL
      rule.</simpara>
    </section>
  </chapter>

  <chapter xml:id="unix-chapt">
    <title xml:id="unix-title">HyperSQL on UNIX</title>

    <subtitle>How to quickly get a HyperSQL (aka HSQLDB) Listener up and
    running on UNIX, including Mac OS X</subtitle>

    <info>
      <author>
        <personname>
          <firstname>Blaine</firstname>

          <surname>Simpson</surname>
        </personname>

        <email>&blaine_addr;</email>

        <affiliation>
          <orgname>HSQLDB Development Group</orgname>
        </affiliation>
      </author>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>HyperSQL</keyword>

        <keyword>HSQLDB</keyword>

        <keyword>UNIX</keyword>

        <keyword>Linux</keyword>

        <keyword>HOWTO</keyword>
      </keywordset>
    </info>

    <section xml:id="unix_purpose-sect">
      <title>Purpose</title>

      <simpara>This chapter explains how to quickly install, run, and use a
      HyperSQL Listener (aka Server) on UNIX.</simpara>

      <simpara>Note that, unlike traditional databases, there are many use
      cases where it makes sense to run HyperSQL without any listener. This
      type of setup is called <glossterm>in-process</glossterm>, and is not
      covered here, since there is no UNIX-specific setup in that
      case.</simpara>

      <simpara>HyperSQL has lots of great optional features. I intend to cover
      very few of them. I do intend to cover what I think is the most common
      UNIX setup: To run a multi-user, externally-accessible catalog with
      permanent data persistence. (By the latter I mean that data is stored to
      disk so that the catalog data will persist across process shutdowns and
      startups). I also cover how to run the Listener as a system
      daemon.</simpara>

      <simpara>When I give sample shell commands below, I use commands which
      will work in Bourne-compatible shells, including Bash and Korn. Users
      who insist on using the inferior C-shells will need to
      convert.</simpara>
    </section>

    <section xml:id="unix_install-sect">
      <title>Installation</title>

      <simpara>Go to <link
      xlink:href="http://sourceforge.net/projects/hsqldb" /> and click on the
      "files" link. You want the current version. This will be the highest
      numbered version under the plain black "hsqldb" heading. See if there's
      a distribution for the current HSQLDB version in the format that you
      want.</simpara>

      <simpara>If you want a binary package and we either don't provide it, or
      you prefer somebody else's build, you should still find out the current
      version of HSQLDB as described in the previous paragraph. It's very
      likely that you can find a binary package for your UNIX variant with
      your OS distributor, <link xlink:href="http://www.jpackage.org/" />
      <link xlink:href="http://sunfreeware.com/" />, etc. Nowadays, most
      UNIXes have software package management systems which check Internet
      repositories. Just search the repositories for "hsqldb" and "hypersql".
      The challenge is finding an <emphasis>up-to-date</emphasis> package. You
      will get better features and support if you work with the current stable
      release of HyperSQL. Pay attention to what JVM versions your binary
      package supports.</simpara>

      <note>
        <simpara>It could very well happen that some of the file formats which
        I discuss below are not in fact offered. If so, then we have not
        gotten around to building them.</simpara>
      </note>

      <simpara>Binary installation depends on the package format that you
      downloaded.</simpara>

      <variablelist>
        <varlistentry>
          <term>Installing from a .pkg.Z file</term>

          <listitem>
            <para>This package is only for use by a Solaris super-user. It's a
            System V package. Download then uncompress the package with
            uncompress or gunzip <informalexample>
                <screen>
    uncompress filename.pkg.Z</screen>
              </informalexample> You can read about the package by running
            <informalexample>
                <screen>
    pkginfo -l -d filename.pkg</screen>
              </informalexample> Run pkgadd as root to install.</para>

            <informalexample>
              <screen>
    pkgadd -d filename.pkg</screen>
            </informalexample>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Installing from a BSD Port or Package</term>

          <listitem>
            <simpara>You're on your own. I find everything much easier when I
            install software to BSD without their package management
            systems.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Installing from a .rpm file</term>

          <listitem>
            <para>Just skip this section if you know how to install an RPM. If
            you found the RPM using a software management system, then just
            have it install it. The remainder of item explains a generic
            command-line method which should work with any Linux variant.
            After you download the rpm, you can read about it by running
            <informalexample>
                <screen>
    rpm -qip /path/to/file.rpm</screen>
              </informalexample></para>

            <para>Rpms can be installed or upgraded by running
            <informalexample>
                <screen>
    rpm -Uvh /path/to/file.rpm</screen>
              </informalexample> as root. Suse users may want to keep Yast
            aware of installed packages by running rpm through Yast:
            <literal>yast2 -i /path/to/file.rpm</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Installing from a .zip file</term>

          <listitem>
            <simpara>Extract the zip file in an ancestor directory of the new
            HSQLDB home. You don't need to create the
            <varname>HSQLDB_HOME</varname> directory because the
            extraction will create a version-labelled directory, and the
            subdirectory "hsqldb". This "hsqldb" directory is your
            <varname>HSQLDB_HOME</varname>, and you can move it to
            wherever you wish. If you will be upgrading or maintaining
            multiple versions of HyperSQL, you will want to retain the version
            number in the directory tree somehow.</simpara>

            <informalexample>
              <screen>
    cd ancestor/of/new/hsqldb/home
    unzip /path/to/file.zip</screen>
            </informalexample>

            <simpara>All the files in the zip archive will be extracted to
            underneath a new subdirectory named like
            <filename>hsqldb-1.9.2a/hsqldb</filename>.</simpara>
          </listitem>
        </varlistentry>
      </variablelist>

      <simpara>Take a look at the files you installed. (Under
      <filename>hsqldb</filename> for zip file installations. Otherwise, use
      the utilities for your packaging system). The most important file of the
      HyperSQL system is <filename>hsqldb.jar</filename>, which resides in the
      subdirectory <filename>lib</filename>.</simpara>

      <important>
        <simpara>For the purposes of this chapter, I define
          <varname>HSQLDB_HOME</varname> to be the parent directory of the
        lib directory that contains <filename>hsqldb.jar</filename>. E.g., if
        your path to <filename>hsqldb.jar</filename> is
        <filename>/a/b/hsqldb/lib/hsqldb.jar</filename>, then your
        <varname>HSQLDB_HOME</varname> is
        <filename>/a/b/hsqldb</filename>.</simpara>
      </important>

      <simpara>If the description of your distribution says that the
      hsqldb.jar file will work for your Java version, then you are finished
      with installation. Otherwise you need to build a new hsqldb.jar
      file.</simpara>

      <simpara>If you followed the instructions above and you still don't know
      what Java version your <filename>hsqldb.jar</filename> supports, then
      read <varname>HSQLDB_HOME</varname><filename>/readme.txt</filename> and
      <varname>HSQLDB_HOME</varname><filename>/index.html</filename>. If
      that still doesn't help, then you can just try your hsqldb.jar and see
      if it works, or build your own.</simpara>

      <simpara>To use the supplied <filename>hsqldb.jar</filename>, just skip
      to the <link linkend="unix_cat_setup-sect"> next section of this
      document</link>. Otherwise build a new
      <filename>hsqldb.jar</filename>.</simpara>

      <procedure>
        <title>Building hsqldb.jar</title>

        <step>
          <para>If you don't already have Ant, download the latest stable
          binary version from <link xlink:href="http://ant.apache.org" />. cd
          to where you want Ant to live, and extract from the archive with
          <informalexample>
              <screen>
    unzip /path/to/file.zip</screen>
            </informalexample>or<informalexample>
              <screen>
    tar -xzf /path/to/file.tar.gz</screen>
            </informalexample>or<informalexample>
              <screen>
    bunzip2 -c /path/to/file.tar.bz2 | tar -xzf -</screen>
            </informalexample> Everything will be installed into a new
          subdirectory named <filename>apache-ant- + version</filename>. You
          can rename the directory after the extraction if you wish.</para>
        </step>

        <step>
          <para>Set the environmental variable <varname>JAVA_HOME</varname> to
          the base directory of your Java JRE or SDK, like <informalexample>
              <screen>
    export JAVA_HOME; JAVA_HOME=/usr/java/j2sdk1.4.0</screen>
            </informalexample> The location is entirely dependent upon your
          variety of UNIX. Sun's rpm distributions of Java normally install to
          <filename>/usr/java/something</filename>. Sun's System V package
          distributions of Java (including those that come with Solaris)
          normally install to <filename>/usr/something</filename>, with a
          sym-link from <filename>/usr/java</filename> to the default version
          (so for Solaris you will usually set JAVA_HOME to
          <filename>/usr/java</filename>).</para>
        </step>

        <step>
          <simpara>Remove the existing file <varname>HSQLDB_HOME</varname>
          <filename>/lib/hsqldb.jar</filename>.</simpara>
        </step>

        <step>
          <para>cd to <varname>HSQLDB_HOME</varname><filename>/build</filename>.
          Make sure that the bin directory under your Ant home is in your search
          path. Run the following command. <informalexample>
              <screen>
    ant hsqldb</screen>
          </informalexample> This will build a new
          <varname>HSQLDB_HOME</varname><filename>/lib/hsqldb.jar</filename>.</para>
        </step>
      </procedure>

      <simpara>
        <remark>Restore building appendix link</remark>
      </simpara>

      <!--
      <simpara>See the <link endterm="building-title"
      linkend="building-app" /> appendix if you want to build anything
      other than <filename>hsqldb.jar</filename> with all default
      settings.</simpara>
      -->
    </section>

    <section xml:id="unix_cat_setup-sect">
      <title>Setting up a HyperSQL Persistent Database Catalog and a HyperSQL
      Network Listener</title>

      <titleabbrev>Setting up Database Catalog and Listener</titleabbrev>

      <simpara>If you installed from an OS-specific package, you may already
      have a catalog and listener pre-configured. See if your package includes
      a file named <filename>server.properties</filename> (make use of your
      packaging utilities). If you do, then I suggest that you still read this
      section while you poke around, in order to understand your
      setup.</simpara>

      <procedure>
        <step>
          <simpara>Select a UNIX user to run the database process (JVM) as. If
          this database is for the use of multiple users, or is a production
          system (or to emulate a production system), you should dedicate a
          UNIX user for this purpose. In my examples, I use the user name
          <literal>hsqldb</literal>. In this chapter, I refer to this user as
          the <varname>HSQLDB_OWNER</varname>, since that user
          will own the database catalog files and the JVM processes.</simpara>

          <para>If the account doesn't exist, then create it. On all system-5
          UNIXes and most hybrids (including Linux), you can run (as root)
          something like <informalexample>
              <screen>
    useradd -c 'HSQLDB Database Owner' -s /bin/bash -m hsqldb</screen>
            </informalexample> (BSD-variant users can use a similar
          <literal>pw useradd hsqldb...</literal> command).</para>
        </step>

        <step>
          <simpara>Become the <varname>HSQLDB_OWNER</varname>.
          Copy the sample file
          <varname>HSQLDB_HOME</varname><filename>/sample/server.properties</filename>
          to the <varname>HSQLDB_OWNER</varname>'s home
          directory and rename it to
          <filename>server.properties</filename>.</simpara>

          <programlisting><xi:include
              href="../verbatim/sample/server.properties" parse="text" /></programlisting>

          <simpara>Since the value of the first database
          (<property>server.database.0</property>) begins with
          <glossterm>file:</glossterm>, the catalog will be persisted to a set of
          files in the specified directory with names beginning with the
          specified name. Set the path to whatever you want (relative paths
          will be relative to the directory containing the properties file).
          You can read about how to specify other catalogs of various types,
          and how to make settings for the listen port and many other things
          in other chapters of this guide.</simpara>
        </step>

        <step>
          <para>Set and export the environmental variable
          <varname>CLASSPATH</varname> to the value of
          <varname>HSQLDB_HOME</varname> (as described above) plus
          "/lib/hsqldb.jar", like <informalexample>
              <screen>
    export CLASSPATH; CLASSPATH=/path/to/hsqldb/lib/hsqldb.jar</screen>
    </informalexample> In <varname>HSQLDB_OWNER</varname>'s home directory,
    run</para>
          <informalexample>
            <screen>
    nohup java org.hsqldb.server.Server &amp;</screen>
          </informalexample>

          <simpara>This will start the Listener process in the background, and
          will create your new database catalog "db0". Continue on when you
          see the message containing <literal>HSQLDB server... is
          online</literal>. <literal>nohup</literal> just makes sure that the
          command will not quit when you exit the current shell (omit it if
          that's what you want to do).</simpara>
        </step>
      </procedure>
    </section>

    <section xml:id="unix_access-sect">
      <title>Accessing your Database</title>

      <simpara>Copy the file
      <varname>HSQLDB_HOME</varname><filename>/sample/sqltool.rc</filename>
      to the <varname>HSQLDB_OWNER</varname>'s home directory.
      Use <literal>chmod</literal> to make the file readable and writable only
      to <varname>HSQLDB_OWNER</varname>.</simpara>

      <programlisting><xi:include href="../verbatim/sample/sqltool.rc"
          parse="text" /></programlisting>

      <simpara>We will be using the "localhost-sa" sample urlid definition
      from the config file. The JDBC URL for this urlid is
      <literal>jdbc:hsqldb:hsql://localhost</literal>. That is the URL for the
      default catalog of a HyperSQL Listener running on the default port of
      the local host. You can read about URLs to connect to other catalogs
      with and without listeners in other chapters of this guide.</simpara>

      <para>Run <classname>SqlTool</classname>. <informalexample>
          <screen>
    java -jar path/to/hsqldb.jar localhost-sa</screen>
        </informalexample> If you get a prompt, then all is well. If security
      is of any concern to you at all, then you should change the privileged
      password in the database. Use the command <link
      linkend="set_password-sect">SET PASSWORD</link> command to change SA's
      password. <informalexample>
          <programlisting>
    SET PASSWORD 'newpassword';</programlisting>
        </informalexample></para>

      <simpara>Note that with SQL-conformant databases like HyperSQL 1.9, user
      names and passwords are case sensitive. If you don't quote the name, it
      will be interpreted as upper-case, like any named SQL object.</simpara>

      <simpara>When you're finished playing, exit with the command
      <literal>\q</literal>.</simpara>

      <simpara>If you changed the SA password, then you need to fix the
      password in the <filename>sqltool.rc</filename> file
      accordingly.</simpara>

      <simpara>You can, of course, also access the database with any JDBC
      client program. <remark>Restore firstclient appendix link</remark> <!--
    See the <link
    endterm="firstclient-title" linkend="firstclient-app" /> appendix.
    --> You will need to modify your classpath to include
      <filename>hsqldb.jar</filename> as well as your client class(es). You
      can also use the other HSQLDB client programs, such as
      <classname>org.hsqldb.util.DatabasManagerSwing</classname>, a graphical
      client with a similar purpose to
      <classname>SqlTool</classname>.</simpara>

      <simpara>You can use any normal UNIX account to run the JDBC clients,
      including <classname>SqlTool</classname>, as long as the account has
      read access to the <filename>hsqldb.jar</filename> file and to an
      <filename>sqltool.rc</filename> file. See the Utilities Guide about
      where to put <filename>sqltool.rc</filename>, how to execute sql files,
      and other <classname>SqlTool</classname> features.</simpara>
    </section>

    <section xml:id="unix_addl_accts-sect">
      <title>Create additional Accounts</title>

      <simpara>Connect to the database as SA (or any other Administrative
      user) and run <link linkend="create_user-sect">CREATE USER</link> to
      create new accounts for your catalog. HSQLDB accounts are
      database-catalog-specific, not
      <classname>Listener</classname>-specific.</simpara>

      <simpara>In SQL-compliant databases, all database objects are created in
      a <emphasis>schema</emphasis>. If you don't specify a schema, then the
      new object will be created in the default schema. To create a database
      object, your account (the account that you connected with) must have the
      role <literal>DBA</literal>, or your account must have authorization for
      the target schema (see the CREATE SCHEMA command about this last). When
      you first create a HyperSQL catalog, it has only one database user-- SA,
      a DBA account, with an empty string password. You should set a password
      (as described above). You can create as many additional users as you
      wish. To make a user a DBA, you can use the "ADMIN" option to the <link
      linkend="create_user-sect">CREATE USER</link> command, or GRANT the DBA
      Role to the account after creating it.</simpara>

      <simpara>Once an object is created, the object creator and users with
      the DBA role will have all privileges to work with that object. Other
      users will have only the rights which the pseudo-user PUBLIC has. To
      give specific users more permissions, even rights to read objects, you
      can GRANT permissions for specific objects, grant Roles (which encompass
      a set of permissions), or grant the DBA Role itself.</simpara>

      <simpara>Since only people with a database account may do anything at
      all with the database, it is often useful to permit other database users
      to view the data in your tables. To optimize performance, reduce
      contention, and minimize administration, it is often best to grant
      SELECT to PUBLIC on any object that needs to be accessed by multiple
      database users (with the significant exception of any data which you
      want to keep secret).</simpara>
    </section>

    <section xml:id="unix_shutdown-sect">
      <title>Shutdown</title>

      <para>Do a clean database shutdown when you are finished with the
      database catalog. You need to connect up as SA or some other Admin user,
      of course. With SqlTool, you can run <informalexample>
          <screen>
    java -jar path/to/hsqldb.jar --sql 'shutdown;' localhost-sa</screen>
        </informalexample> You don't have to worry about stopping the
      <classname>Listener</classname> because it shuts down automatically when
      all served database catalogs are shut down.</para>
    </section>

    <section xml:id="unix_daemon-sect">
      <title>Running Hsqldb as a System Daemon</title>

      <simpara>You can, of course, run HSQLDB through inittab on System V
      UNIXes, but usually an init script is more convenient and manageable.
      This section explains how to set up and use our UNIX init script. Our
      init script is only for use by root. (That is not to say that the
      <emphasis>Listener</emphasis> will run as root-- it usually should
      not).</simpara>

      <simpara>The main purpose of the init script is to start up a Listener
      for the database catalogs specified in your
      <filename>server.properties</filename> file; and to gracefully shut down
      these same catalogs. For each catalog defined by a
      <varname>server.database.X</varname> setting in your .properties file,
      you must define an administrative "urlid" in your
      <filename>sqltool.rc</filename> (these are used to access the catalogs
      for validation and shutdown purposes). Finally, you list the urlid names
      in your init script config file. If, due to firewall issues, you want to
      run a WebServer instead of a Server, then make sure you have a healthy
      WebServer with a webserver.properties set up, adjust your URLs in
      <filename>sqltool.rc</filename>, and set TARGET_CLASS in the config
      file.</simpara>

      <simpara>By following the commented examples in the config file, you can
      start up any number of Server and/or WebServer listener instances with
      or without TLS encryption, and each listener instance can serve any
      number of HyperSQL catalogs (independent data sets), all with optimal
      efficiency from a single JVM process. There are instructions in the init
      script itself about how to run multiple, independently-configured JVM
      processes. Most UNIX installations, however, will run a single JVM with
      a single Listener instance which serves multiple catalogs, for easier
      management and more efficient resource usage.</simpara>

      <simpara>After you have the init script set up, root can use it anytime
      to start or stop HSQLDB. (I.e., not just at system bootup or
      shutdown).</simpara>

      <section>
        <title>Portability of <filename>hsqldb</filename> init script</title>

        <simpara>The primary design criterion of the init script is
        portability. It does not print pretty color startup/shutdown messages
        as is common in late-model Linuxes and HPUX; and it does not keep
        subsystem state files or use the startup/shutdown functions supplied
        by many UNIXes, because these features are all non-portable.</simpara>

        <simpara>Offsetting these limitations, this one script does it's
        intended job great on the UNIX varieties I have tested, and can easily
        be modified to accommodate other UNIXes. While you don't have tight
        integration with OS-specific daemon administration guis, etc., you do
        have a well tested and well behaved script that gives good,
        utilitarian feedback.</simpara>
      </section>

      <section>
        <title>Init script Setup Procedure</title>

        <simpara>The strategy taken here is to get the init script to run your
        single Server or WebServer first (as specified by TARGET_CLASS). After
        that's working, you can customize the JVM that is run by running
        additional Listener instances in it, running your own application in
        it (embedding), or even overriding HSQLDB behavior with your own
        overriding classes.</simpara>

        <procedure>
          <step>
            <simpara>Copy the init script <filename>hsqldb.init</filename>
            from
            <varname>HSQLDB_HOME</varname><filename>/sample</filename> to
            <filename>hsqldb</filename> in the directory where init scripts
            live on your variety of UNIX. The most common locations are
            <filename>/etc/init.d</filename> or
            <filename>/etc/rc.d/init.d</filename> on System V style UNIXes,
            <filename>/usr/local/etc/rc.d</filename> on BSD style UNIXes, and
            <filename>/Library/StartupItems/hsqldb</filename> on OS X (you'll
            need to create the directory for the last).</simpara>
          </step>

          <step>
            <para>View your <filename>server.properties</filename> file. Make
            a note of every catalog define by a
            <varname>server.database.X</varname> setting. A couple steps down,
            you will need to set up administrative access for each of these
            catalogs. If you are using our sample
            <filename>server.properties</filename> file, you just need to know
            that you need to set up access for the catalog specified with
            <literal>file:db0/dbo</literal>.</para>

            <note>
              <simpara>Pre-1.9 versions of the hsqldb init script required use
              of .properties settings of the
              form<varname>server.urlid.X</varname>. These settings are not
              obsolete and should be removed.</simpara>
            </note>
          </step>

          <step>
            <simpara>Either copy <varname>HSQLDB_OWNER</varname>'s
            <filename>sqltool.rc</filename> file into root's home directory,
            or set the value of AUTH_FILE to the absolute path of
            <varname>HSQLDB_OWNER</varname>'s
            <filename>sqltool.rc</filename> file. This file is read directly
            by root, even if you run hsqldb as non-root (by setting
            <varname>HSQLDB_OWNER</varname> in the config file).
            If you copy the file, make sure
            to use <literal>chmod</literal> to restrict permissions on the new
            copy. The init script will abort with an appropriate exhortation
            if you have the permissions set incorrectly.</simpara>

            <simpara>You need to set up a urlid stanza in your
            <filename>sqltool.rc</filename> file for network access (i.e. JDBC
            URL with hsql:, hsqls:, http:, or https:) for each catalog in your
            <filename>server.properties</filename> file. For our example, you
            need to define a stanza for the <literal>file:db0/db0</literal>
            catalog. You must supply for this catalog, a hsql: JDBC URL, an
            administrative user name, and the password.</simpara>

            <example>
              <title>example sqltool.rc stanza</title>

              <programlisting>
    urlid localhostdb1
    url jdbc:hsqldb:hsql://localhost
    username SA
    password secret</programlisting>
            </example>
          </step>

          <step>
            <simpara>Look at the comment towards the top of the init script
            which lists recommended locations for the configuration file for
            various UNIX platforms. Copy the sample config file
            <varname>HSQLDB_HOME</varname><filename>/sample/hsqldb.cfg</filename>
            to one of the listed locations (your choice). Edit the config file
            according to the instructions in it. For our example, you will set
            the value of <varname>URLIDS</varname> to
            <literal>localhostdb1</literal>, since that is the urlid name that
            we used in the <filename>sqltool.rc</filename> file.</simpara>

            <programlisting><xi:include href="../verbatim/sample/hsqldb.cfg"
                parse="text" /></programlisting>

            <simpara>
              <emphasis role="bold">Verify that the init script
              works.</emphasis>
            </simpara>

            <para>Just run <informalexample>
                <screen>
    /path/to/hsqldb</screen>
              </informalexample> as root to see the arguments you may use.
            Notice that you can run</para>

            <para><screen>
    /path/to/hsqldb status</screen>at any time to see whether your HSQLDB
            <classname>Listener</classname> is running.</para>

            <simpara>Re-run the script with each of the possible arguments to
            really test it good. If anything doesn't work right, then see the
            <link endterm="unix_inittrouble-title"
            linkend="unix_inittrouble-sect" /> section.</simpara>
          </step>

          <step>
            <simpara>Tell your OS to run the init script upon system startup
            and shutdown. If you are using a UNIX variant that has
            <filename>/etc/rc.conf</filename> or
            <filename>/etc/rc.conf.local</filename> (like BSD variants and
            Gentoo), you must set "hsqldb_enable" to "YES" in either of those
            files. (Just run <literal>cd /etc; ls rc.conf
            rc.conf.local</literal> to see if you have one of these files).
            For good UNIXes that use System V style init, you must set up hard
            links or soft links either manually or with management tools (such
            as <literal>chkconfig</literal> or <literal>insserv</literal>) or
            Gui's (like run level editors).</simpara>

            <para>This paragraph is for Mac OS X users only. If you followed
            the instructions above, your init script should reside at
            <filename>/Library/StartupItems/hsqldb/hsqldb</filename>. Now copy
            the file <filename>StartupParameters.plist</filename> from the
            directory <filename>src/org.hsqldb/sample</filename> of your
            HSQLDB distribution to the same directory as the init script. As
            long as these two files reside in
            <filename>/Library/StartupItems/hsqldb</filename>, your init
            script is active (for portability reasons, it doesn't check for a
            setting in <filename>/etc/hostconfig</filename>). You can run it
            as a <emphasis>Startup Item</emphasis> by running <screen>
    SystemStarter {start|stop|restart} Hsqldb</screen> Hsqldb is the service
            name. See the man page for <classname>SystemStarter</classname>. To
            disable the init script, wipe out the
            <filename>/Library/StartupItems/hsqldb</filename> directory. Hard
            to believe, but the Mac people tell me that during system shutdown
            the Startup Items don't run at all. Therefore, if you don't want
            your data corrupted, make sure to run "SystemStarter stop Hsqldb"
            before shutting down your Mac.</para>
          </step>
        </procedure>

        <simpara>Follow the examples in the config file to add additional
        classes to the server JVM's classpath and to execute additional
        classes in your JVM. (See the SERVER_ADDL_CLASSPATH and
        INVOC_ADDL_ARGS items).</simpara>
      </section>

      <section xml:id="unix_inittrouble-sect">
        <title xml:id="unix_inittrouble-title">Troubleshooting the Init
        Script</title>

        <simpara>Definitely look at the init script log file, which is at an
        OS-sependent location, but is usually at
        <filename>/var/log/hsqldb.log</filename>.</simpara>

        <simpara>Do a <literal>ps</literal> to look for processes containing
        the string <literal>hsqldb</literal>, and try to connect to the
        database from any client. If the init script starts up your database
        successfully, but incorrectly reports that it has not, then your
        problem is with specification of urlid(s) or SqlTool setup. If your
        database really did not start, then skip to the next paragraph. Verify
        that your config file assigns a urlid for each catalog defined in
        <filename>server.properties</filename> or
        <filename>webserver.properties</filename>, then verify that you can
        run <classname>SqlTool</classname> as root to connect to the catalogs
        with these urlids. (For the latter test, use the
        <literal>--rcfile</literal> switch if you are setting
        <varname>AUTH_FILE</varname> in the init script config
        file).</simpara>

        <simpara>If your database really is not starting, then verify that you
        can su to the database owner account and start the database. The
        command <literal>su USERNAME -c ...</literal> won't work on most
        UNIXes unless the target user has a real login shell. Therefore, if
        you try to tighten up security by disabling this user's login shell,
        you will break the init script. If these possibilities don't pan out,
        then debug the init script or seek help, as described below.</simpara>

        <para>To debug the init script, run it in verbose mode to see exactly
        what is happening (and perhaps manually run the steps that are
        suspect). To run an init script (in fact, any sh shell script) in
        verbose mode, use <literal>sh</literal> with the <literal>-x</literal>
        or <literal>-v</literal> switch, like <screen>
    sh -x path/to/hsqldb start</screen> See the man page for
        <literal>sh</literal> if you don't know the difference between
        <literal>-v</literal> and <literal>-x</literal>.</para>

        <para>If you want troubleshooting help, use the HSQLDB lists/forums or
        email me at <link
        xlink:href="mailto:blaine.simpson@admc.com?Subject=hsqldb-unix">
        &blaine_addr;</link>. If you email me, make sure to include the
        revision number from your <filename>hsqldb</filename> init script
        (it's towards the top in the line that starts like "# $Id:"), and the
        output of a run of <screen>
    sh -x path/to/hsqldb start &gt; /tmp/hstart.log 2&gt;&amp;1</screen></para>
      </section>
    </section>

    <section xml:id="unix_upgrade-sect">
      <title>Upgrading</title>

      <simpara>This section is for users who are using our UNIX init script,
      and who are upgrading their HSQLDB installation.</simpara>

      <simpara>Most users will not have customized the init script itself, and
      your customizations will all be encapsulated in the init script
      configuration file. These users should just overwrite their init script
      with a new one from the HyperSQL installation, and manually merge config
      file settings. First, just copy the file
      <varname>HSQLDB_HOME</varname><filename>/sample/hsqldb.init</filename>.
      over top of of your init script (wherever it runs from). Then update
      your old config file according to the instructions in the new config
      file template at
      <varname>HSQLDB_HOME</varname><filename>/sample/hsqldb.cfg</filename>.
      You will have to change very few settings. If you are upgrading from a
      pre-1.9 installation to a post-1.9 installation, you will need to add
      the setting <varname>URLIDS</varname>, as described above and in the
      inline comments.</simpara>

      <simpara>Users who customized their init script will need to merge their
      customizations into the new init script.</simpara>
    </section>
  </chapter>

  <chapter xml:id="advanced-chapt">
    <title xml:id="advanced-title">Advanced Topics</title>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Advanced</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="advanced_connections-sect">
      <title>Connections</title>

      <para>The normal method of accessing an HSQLDB database is via the JDBC
      Connection interface. An introduction to different methods of providing
      database services and accessing them can be found in the <link
      endterm="sqlissues-title" linkend="sqlissues-chapt" /> chapter. Details
      and examples of how to connect via JDBC are provided in our <link
      xlink:href="../src/org/hsqldb/jdbc/JDBCConnection.html">JavaDoc for
      <classname>JDBCConnection</classname></link>.</para>

      <para>A uniform method is used to distinguish between different types of
      connection. The common driver identifier is
      <literal>jdbc:hsqldb:</literal> followed by a protocol identifier
      (<literal>mem: file: res: hsql: http: hsqls: https:</literal>) then
      followed by host and port identifiers in the case of servers, then
      followed by database identifier. Additional property / value pairs can
      be appended to the end of the URL, separated with semicolons.</para>

      <table frame="all" pgwide="1" tocentry="1">
        <title>Hsqldb URL Components</title>

        <tgroup align="left" cols="3">
          <colspec colname="c1" />

          <colspec colname="c2" />

          <colspec colname="c3" />

          <thead>
            <row>
              <entry>Driver and Protocol</entry>

              <entry>Host and Port</entry>

              <entry>Database</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>jdbc:hsqldb:mem:</literal>
                  </member>
                </simplelist>
              </entry>

              <entry>not available</entry>

              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>accounts</literal>
                  </member>
                </simplelist>
              </entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1">
                <para>Lowercase, single-word identifier creates the in-memory
                database when the first connection is made. Subsequent use of
                the same Connection URL connects to the existing DB.</para>

                <para>The old form for the URL,
                <literal>jdbc:hsqldb:.</literal> creates or connects to the
                same database as the new form for the URL,
                <literal>jdbc:hsqldb:mem:.</literal></para>
              </entry>
            </row>

            <row>
              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>jdbc:hsqldb:file:</literal>
                  </member>
                </simplelist>
              </entry>

              <entry>not available</entry>

              <entry>
                <simplelist type="vert">
                  <member>
                    <filename>mydb</filename>
                  </member>

                  <member>
                    <filename>/opt/db/accounts</filename>
                  </member>

                  <member>
                    <filename>C:/data/mydb</filename>
                  </member>
                </simplelist>
              </entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1">
                <para>The file path specifies the database file. In the above
                examples the first one refers to a set of mydb.* files in the
                directory where the <literal>java</literal>command for running
                the application was issued. The second and third examples
                refer to absolute paths on the host machine.</para>
              </entry>
            </row>

            <row>
              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>jdbc:hsqldb:res:</literal>
                  </member>
                </simplelist>
              </entry>

              <entry>not available</entry>

              <entry>
                <simplelist type="vert">
                  <member>
                    <filename>/adirectory/dbname</filename>
                  </member>
                </simplelist>
              </entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1">Database files can be loaded
              from one of the jars specified as part of the
              <literal>Java</literal> command the same way as resource files
              are accessed in Java programs. The
              <literal>/adirectory</literal> above stands for a directory in
              one of the jars.</entry>
            </row>

            <row>
              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>jdbc:hsqldb:hsql:</literal>
                  </member>

                  <member>
                    <literal>jdbc:hsqldb:hsqls:</literal>
                  </member>

                  <member>
                    <literal>jdbc:hsqldb:http:</literal>
                  </member>

                  <member>
                    <literal>jdbc:hsqldb:https:</literal>
                  </member>
                </simplelist>
              </entry>

              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>//localhost</literal>
                  </member>

                  <member>
                    <literal>//192.0.0.10:9500</literal>
                  </member>

                  <member>
                    <literal>//dbserver.somedomain.com</literal>
                  </member>
                </simplelist>
              </entry>

              <entry>
                <simplelist type="vert">
                  <member>
                    <literal>/an_alias</literal>
                  </member>

                  <member>
                    <literal>/enrollments</literal>
                  </member>

                  <member>
                    <literal>/quickdb</literal>
                  </member>
                </simplelist>
              </entry>
            </row>

            <row>
              <entry nameend="c3" namest="c1">
                <para>The host and port specify the IP address or host name of
                the server and an optional port number. The database to
                connect to is specified by an alias. This alias is a lowercase
                string defined in the <filename>server.properties</filename>
                file to refer to an actual database on the file system of the
                server or a transient, in-memory database on the server. The
                following example lines in <filename>server.properties
                </filename> or <filename>webserver.properties</filename>
                define the database aliases listed above and accessible to
                clients to refer to different file and in-memory
                databases.</para>

                <para>The old form for the server URL, e.g.,
                <literal>jdbc:hsqldb:hsql//localhost</literal> connects to the
                same database as the new form for the URL,
                <literal>jdbc:hsqldb:hsql//localhost/</literal> where the
                alias is a zero length string. In the example below, the
                database catalog <literal>lists.*</literal> in the
                <literal>/home/dbmaster/</literal> directory is associated
                with the empty alias:</para>

                <programlisting>
    database.3=/home/dbmaster/lists
    dbname.3=</programlisting>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section xml:id="conn_props-sect">
        <title>Connection properties</title>

        <para>Each new JDBC Connection to a database can specify connection
        properties. The properties <property>user</property> and
        <property>password</property> are always required. In 1.9.0 the
        following optional properties can also be used.</para>

        <para>Connection properties are specified either by establishing the
        connection via the:</para>

        <programlisting>
    DriverManager.getConnection (String url, Properties info);</programlisting>

        <para>method call, or the property can be appended to the full
        Connection URL.</para>

        <table frame="all" pgwide="1" tocentry="1">
          <title>Connection Properties</title>

          <tgroup align="left" cols="3">
            <colspec colname="c1" />

            <colspec colname="c2" />

            <colspec colname="c3" />

            <tbody valign="top">
              <row>
                <entry>
                  <property>get_column_name</property>
                </entry>

                <entry>
                  <literal>true</literal>
                </entry>

                <entry>column name in ResultSet</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>This property is used for compatibility with other
                  JDBC driver implementations. When true (the default),
                  <methodname>ResultSet.getColumnName(int c)</methodname> returns
                  the underlying column name</para>

                  <para>When false, the above method returns the same value as
                  <methodname>ResultSet.getColumnLabel(int column)</methodname>
                  Example below:</para>

                  <programlisting>
    jdbc:hsqldb:hsql://localhost/enrollments;get_column_name=false
                    </programlisting>

                  <para>When a ResultSet is used inside a user-defined stored
                  procedure, the default, true, is always used for this
                  property.</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>ifexists</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>connect only if database already exists</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>Has an effect only with <glossterm>mem:</glossterm> and
                  <glossterm>file:</glossterm> database. When true, will not
                  create a new database if one does not already exist for the
                  URL.</para>

                  <para>When false (the default), a new
                  <glossterm>mem:</glossterm> or <glossterm>file:</glossterm> database
                  will be created if it does not exist.</para>

                  <para>Setting the property to true is useful when
                  troubleshooting as no database is created if the URL is
                  malformed. Example below:</para>

                  <programlisting>
    jdbc:hsqldb:file:enrollments;ifexists=true</programlisting>
                </entry>
              </row>

              <row>
                <entry>
                  <property>shutdown</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>shut down the database when the last connection is
                closed</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>If this property is <literal>true</literal>, when the
                  last connection to a database is closed, the database is
                  automatically shut down. The property takes effect only when
                  the first connection is made to the database. This means the
                  connection that opens the database. It has no effect if used
                  with subsequent connections.</para>

                  <para>This command has two uses. One is for test suites,
                  where connections to the database are made from one JVM
                  context, immediately followed by another context. The other
                  use is for applications where it is not easy to configure
                  the environment to shutdown the database. Examples reported
                  by users include web application servers, where the closing
                  of the last connection coincides with the web app being shut
                  down.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In addition, when a connection to an
        <glossterm>in-process</glossterm> database creates a new database, or
        opens an existing database (i.e. it is the first connection made to
        the database by the application), all the user-defined database
        properties can be specified as URL properties. This can be used to
        specify properties to enforce more strict SQL adherence, or to change
        cache_scale or similar properties before the database files are
        created. However, for new databases, it is recommended to use the SET
        PROPERTY command for such settings.</para>
      </section>
    </section>

    <section xml:id="advanced_dbprops-sect">
      <title>Database Properties</title>

      <para>The database engine generates a <literal>.properties</literal>
      file for each file catalog. Most of these properties can be changed via
      SQL commands. Some properties are only changed by the engine. There are,
      however, a few properties than can be modified by the user while the
      database is shutdown.</para>

      <section>
        <title>Individual Database Properties</title>

        <para>Each database has its own <filename>&lt;dbname&gt;.properties
        </filename> file as part of a small group of files which also includes
        <filename>&lt;dbname&gt;.script</filename> and
        <filename>&lt;dbname&gt;.data</filename>. The properties files contain
        key/value pairs for some important settings.</para>

        <para>In version 1.9.0 an SQL command allows most database properties
        to be modified as follows:</para>

        <programlisting>    SET PROPERTY "property_name" property_value</programlisting>

        <para>Properties that can be modified via <literal>SET
        PROPERTY</literal> are indicated in the table below. Other properties
        are indicated as <literal>PROPERTIES FILE ONLY</literal> and can be
        modified only by editing the .properties file after a shutdown and
        before a restart. Only the user-defined values listed below should
        ever be modified. Changing any other value could result in unexpected
        malfunction in database operations. Most of these values have been
        introduced for the new features since 1.7.0:</para>

        <table frame="all" pgwide="1" tocentry="1">
          <title>Database-specific Property File Properties</title>

          <tgroup align="left" cols="3">
            <colspec colname="c1" />

            <colspec colname="c2" />

            <colspec colname="c3" />

            <thead>
              <row>
                <entry>Value</entry>

                <entry>Default</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody valign="top">
              <row>
                <entry>
                  <property>readonly</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>whole database is read-only</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>When true, the database cannot be modified in use.
                  This setting can be changed to <literal>true</literal> if
                  the database is to be opened from a CD. Prior to changing
                  this setting, the database should be closed with the
                  <literal>SHUTDOWN COMPACT</literal> command to ensure
                  consistency and compactness of the data.
                  <literal>(PROPERTIES FILE ONLY) but can be used as a
                  connection property to open a normal database as
                  readonly.</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.files_readonly</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>database files will not be written to</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>When true, data in MEMORY tables can be modified and
                  new MEMORY tables can be added. However, these changes are
                  not saved when the database is shutdown. CACHED and TEXT
                  tables are always readonly when this setting is true.
                  <literal>(PROPERTIES FILE ONLY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.cache_file_scale</property>
                </entry>

                <entry>
                  <literal>1</literal>
                </entry>

                <entry>Set larger data file limits. Once set, the limit will
                go up to 8GB.</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>This property can be set to 8 to increase the size
                  limit of the .data file from 2GB to 8GB. To apply the change
                  to an existing database, SHUTDOWN SCRIPT should be performed
                  first, then the property=value line below should be added to
                  the .properties file before reopening the database.
                  <literal>(SET PROPERTY)</literal><programlisting>hsqldb.cache_file_scale=8</programlisting></para>

                  <para>The property can be set with the SQL command (as
                  opposed to changing the value in the properties file) when
                  the database has no CACHED tables (e.g. a new database).
                  <literal>(SET PROPERTY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>sql.enforce_size</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>trimming and padding string columns</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>This property is no longer supported. Use
                  sql.enforce_strict_size</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>sql.enforce_strict_size</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>size enforcement and padding string columns</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>Conforms to SQL standards for size and precision of
                  data types. When true, all CHARACTER, VARCHAR, NUMERIC and
                  DECIMAL values that are in a row affected by an INSERT INTO
                  or UPDATE statement are checked against the size specified
                  in the SQL table definition. An exception is thrown if the
                  value is too long. Also all CHARACTER values that are
                  shorter than the specified size are padded with spaces.
                  TIMESTAMP(0) and TIMESTAMP(6) are also allowed in order to
                  specify the subsecond resolution of the values. When false
                  (default), stores the exact string that is inserted.
                  <literal> (SET PROPERTY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>sql.tx_no_multi_rewrite</property>
                </entry>

                <entry>
                  <literal>false</literal>
                </entry>

                <entry>transaction management</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>In the default READ_UNCOMMITED mode, a transaction can
                  write over rows inserted or updated by another uncommitted
                  transaction.<literal> Setting this property to true will
                  raise an exception when such a write is attempted (SET
                  PROPERTY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.cache_scale</property>
                </entry>

                <entry>
                  <literal>14</literal>
                </entry>

                <entry>memory cache exponent</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>Indicates the maximum number of rows of cached tables
                  that are held in memory, calculated as 3 *(2**value) (three
                  multiplied by (two to the power value)). The default results
                  in up to 3*16384 rows from all cached tables being held in
                  memory at any time.</para>

                  <para>The value can range between 8-18. <literal>(SET
                  PROPERTY)</literal>. If the value is set via SET PROPERTY
                  then it becomes effective after the next database SHUTDOWN
                  or CHECKPOINT. <literal>(SET PROPERTY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.cache_size_scale</property>
                </entry>

                <entry>
                  <literal>10</literal>
                </entry>

                <entry>memory cache exponent</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>Indicates the average size of each row in the memory
                  cache used with cached tables, calculated as 2**value (two
                  to the power value). This result value is multiplied by the
                  maximum number of rows defined by
                  <property>hsqldb.cache_scale</property> to form the maximum
                  number of bytes for all the rows in memory cache. The
                  default results in 1024 bytes per row. This default,
                  combined with the default number of rows, results in
                  approximately 50MB of the .data file to be stored in the
                  memory cache.</para>

                  <para>The value can range between 6-20. <literal>(SET
                  PROPERTY)</literal>. If the value is set via SET PROPERTY
                  then it becomes effective after the next database SHUTDOWN
                  or CHECKPOINT. <literal>(SET PROPERTY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.log_size</property>
                </entry>

                <entry>
                  <literal>200</literal>
                </entry>

                <entry>size of log when checkpoint is performed</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>The value is the size in megabytes that the
                  <literal>.log</literal> file can reach before an automatic
                  checkpoint occurs. A checkpoint and rewrites the
                  <literal>.script</literal> file and clears the
                  <literal>.log</literal> file. The value is changed via the
                  <literal>SET LOGSIZE nnn</literal> SQL command.</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>runtime.gc_interval</property>
                </entry>

                <entry>
                  <literal>0</literal>
                </entry>

                <entry>forced garbage collection</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>This setting forces garbage collection each time a set
                  number of result set row or cache row objects are created.
                  The default, "0" means no garbage collection is forced by
                  the program.</para>

                  <para>This should not be set when the database engine is
                  acting as a server inside an exclusive JVM. The setting can
                  be useful when the database is used
                  <glossterm>in-process</glossterm> with the application with
                  some Java Runtime Environments (JRE's). Some JRE's increase
                  the size of the memory heap before doing any automatic
                  garbage collection. This setting would prevent any
                  unnecessary enlargement of the heap. Typical values for this
                  setting would probably be between 10,000 to 100,000.
                  <literal>(PROPERTIES FILE ONLY)</literal></para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.nio_data_file</property>
                </entry>

                <entry>
                  <literal>true</literal>
                </entry>

                <entry>use of nio access methods for the .data file</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>When HSQLDB is compiled and run in Java 1.4 or higher,
                  setting this property to <literal>false</literal> will avoid
                  the use of nio access methods, resulting in somewhat reduced
                  speed. If the data file is larger than 256MB when it is
                  first opened, nio access methods are not used. Also, if the
                  file gets larger than the amount of available computer
                  memory that needs to be allocated for nio access, non-nio
                  access methods are used.</para>

                  <para><literal>(SET PROPERTY)</literal>. If used before
                  defining any CACHED table, it applies immediately, otherwise
                  it comes into effect after a SHUTDOWN and restart or
                  CHECKPOINT.</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.default_table_type</property>
                </entry>

                <entry>
                  <literal>memory</literal>
                </entry>

                <entry>type of table created with unqualified CREATE
                TABLE</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>The CREATE TABLE command results in a MEMORY table by
                  default. Setting the value "cached" for this property will
                  result in a cached table by default. The qualified forms
                  such as CREATE MEMORY TABLE or CREATE CACHED TABLE are not
                  affected at all by this property. This value is changed via
                  the <literal>SET DEFAULT TABLE TYPE</literal> SQL
                  command.</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>hsqldb.applog</property>
                </entry>

                <entry>
                  <literal>0</literal>
                </entry>

                <entry>application logging level</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>The default level 0 indicates no logging. Level 1
                  results in events related to persistence to be logged,
                  including any failures. The events are logged in a file
                  ending with ".app.log". This value is changed via the
                  <literal>SET DATABASE EVENT LOG LEVEL</literal> SQL
                  command.</para>
                </entry>
              </row>

              <row>
                <entry>
                  <property>textdb.*</property>
                </entry>

                <entry>
                  <literal>0</literal>
                </entry>

                <entry>default properties for new text tables</entry>
              </row>

              <row>
                <entry nameend="c3" namest="c1">
                  <para>Properties that override the database engine defaults
                  for newly created text tables. Settings in the text table
                  <literal>SET &lt;tablename&gt; SOURCE &lt;source string&gt;
                  </literal>command override both the engine defaults and the
                  database properties defaults. Individual
                  <property>textdb.*</property> properties are listed in the
                  <link endterm="texttables-title"
                  linkend="texttables-chapt" /> chapter. <literal>(SET
                  PROPERTY)</literal></para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>When connecting to an <glossterm>in-process</glossterm> database
        creates a new database, or opens an existing database (i.e. it is the
        first connection made to the database by the application), all the
        user-defined database properties listed in this section can be
        specified as URL properties.</para>

        <simpara>The property sql.compare_in_locale=true is no longer
        supported. If the line exists in a .properties file, it will switch
        the database to the collation for the current default. See the <link
        endterm="collation-title" linkend="collation-sect" />
        command.</simpara>

        <simpara>When HSQLDB is used in OpenOffice.org, some property values
        will have a different default. The properties and values
        are:</simpara>

        <simpara>hsqldb.default_table_type=cached hsqldb.cache_scale=13
        hsqldb.log_size=10; hsqldb.nio_data_file=false
        sql.enforce_strict_size=true</simpara>
      </section>
    </section>

    <section xml:id="advanced_sqlcmd_dbprops-sect">
      <title>SQL Commands for Database Properties</title>

      <para>There are some database properties that are set with dedicated SQL
      commands beginning with SET.<programlisting>SET WRITE_DELAY {{TRUE | FALSE} | &lt;seconds&gt; | &lt;milliseconds&gt; MILLIS</programlisting>The
      default is TRUE and indicates that the changes to the database that have
      been logged are synched to the file system once every 10 seconds. FALSE
      indicates there is no delay and at each commit a file synch operation is
      performed. Numeric values from 0 can also be specified for the synch
      delay.</para>

      <para>The purpose of this command is to control the amount of data loss
      in case of a total system crash. A delay of 1 second means at most the
      data written to disk during the last second before the crash is lost.
      All data written prior to this has been synced and should be
      recoverable</para>

      <para>This setting should be specified on the basis of the reliability
      of the hardware used for running the database engine, the type of disk
      system used, the possibility of power failure etc. Also the nature of
      the data stored should be considered.</para>

      <para>In general, when the system is very reliable, the setting can be
      left to the default. If it is not very reliable, or the data is critical
      a setting of 1 or 2 seconds would suffice. Only in the worst case
      scenario or with the most critical data should a setting of 0 or FALSE
      be specified as this will slow the engine down to the speed at which the
      file synch operation can be performed by the disk subsystem.</para>

      <para>Values down to 10 milliseconds can be specified by adding MILLIS
      to the command, but in practice a delay of 100 milliseconds provides
      99.99999% reliability with an average one system crash per 6
      days.</para>

      <para><programlisting>SET LOG_SIZE &lt;numeric value&gt;</programlisting>The
      engine writes out a log of all the changes to the database as they
      occur. This log is synched to the disk based on the WRITE_DELAY property
      above. The log is never reused unless there is an abnormal termination,
      i.e. the database process is terminated without SHUTDOWN, or it was
      terminated using SHUTDOWN IMMEDIATELY.</para>

      <para>The default maximum size of the .log file is 200 MB. When the
      maximum size is reached, a CHECKPOINT operation is performed. This
      operation will save the other database files in a consistent state and
      delete the old log. A value of 0 indicates no limit for the .log
      file.</para>

      <para><programlisting>SET CHECKPOINT DEFRAG &lt;numeric value&gt;</programlisting>When
      rows in CACHED tables are updated or deleted, the spaces are mostly
      reused. However, in time, some unused spaces are left in the .data file,
      especially when large tables are dropped or their structure is
      modified.</para>

      <para>A CHECKPOINT operation does not normally reclaim the empty spaces,
      whereas CHECKPOINT DEFRAG always does.</para>

      <para>This property determines when a normal CHECKPOINT, whether
      initiated by an administrator or when the size of the log exceeds its
      limit.</para>

      <para>The numeric value is the number of megabytes of recorded empty
      spaces in the .data file that would force a DEFRAG operation. Low values
      result in more frequent DEFRAG operations. A value of 0 indicates no
      automatic DEFRAG is performed. The default is 200 megabytes of lost
      space.</para>

      <para><programlisting>SET REFERENTIAL INTEGRITY { TRUE | FALSE }</programlisting>This
      is TRUE by default. If bulk data needs to be loaded into the database,
      this property can be set FALSE for the duration of bulk load operation.
      This allows loading data for related tables in any order. The property
      should be set TRUE after bulk load. If the loaded data is not guaranteed
      to conform to the referential integrity constraints, SQL queries should
      be run after loading to identify and modify any non-conforming
      rows.</para>

      <para>
        <programlisting>SET DEFAULT TABLE TYPE { CACHED | MEMORY }</programlisting>
      </para>

      <para>Sets the type of table created when the next CREATE TABLE
      statement is executed.</para>

      <para><programlisting>SET DATABASE EVENT LOG LEVEL { 0 | 1 | 2 }</programlisting>Sets
      the level of detail for events stored in the database applog. Zero
      indicates no logging. One indicates logging for errors only. Two
      indicates logging for all the main events, which include operations on
      database files.</para>

      <para />
    </section>
  </chapter>

  <chapter xml:id="deployment-chapt">
    <title>Deployment Issues</title>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Guide</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2005-2009 Fred Toussi. Permission is granted to
        distribute this document without any alteration under the terms of the
        HSQLDB license. Additional permission is granted to the HSQLDB
        Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <section xml:id="deploymen_modes-sect">
      <title>Mode of Operation and Tables</title>

      <para>HSQLDB has many modes of operation and features that allow it to
      be used in very different scenarios. Levels of memory usage, speed and
      accessibility by different applications are influenced by how HSQLDB is
      deployed.</para>

      <section>
        <title>Mode of Operation</title>

        <para>The decision to run HSQLDB as a separate server process or as an
        <glossterm>in-process</glossterm> database should be based on the
        following:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para>When HSQLDB is run as a server on a separate machine, it
              is isolated from hardware failures and crashes on the hosts
              running the application.</para>
            </listitem>

            <listitem>
              <para>When HSQLDB is run as a server on the same machine, it is
              isolated from application crashes and memory leaks.</para>
            </listitem>

            <listitem>
              <para>Server connections are slower than
              <glossterm>in-process</glossterm> connections due to the
              overhead of streaming the data for each JDBC call.</para>
            </listitem>
          </itemizedlist>
        </para>
      </section>

      <section>
        <title>Tables</title>

        <para>TEXT tables are designed for special applications where the data
        has to be in an interchangeable format, such as CSV. TEXT tables
        should not be used for routine storage of data.</para>

        <para>MEMORY tables and CACHED tables are generally used for data
        storage. The difference between the two is as follows:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para>The data for all MEMORY tables is read from the .script
              file when the database is started and stored in memory. In
              contrast the data for cached tables is not read into memory
              until the table is accessed. Furthermore, only part of the data
              for each CACHED table is held in memory, allowing tables with
              more data than can be held in memory.</para>
            </listitem>

            <listitem>
              <para>When the database is shutdown in the normal way, all the
              data for MEMORY tables is written out to the disk. In
              comparison, the data in CACHED tables that has changed is
              written out at shutdown, plus a compressed backup of all the
              data in all cached tables.</para>
            </listitem>

            <listitem>
              <para>The size and capacity of the data cache for all the CACHED
              tables is configurable. This makes it possible to allow all the
              data in CACHED tables to be cached in memory. In this case,
              speed of access is good, but slightly slower than MEMORY
              tables.</para>
            </listitem>

            <listitem>
              <para>For normal applications it is recommended that MEMORY
              tables are used for small amounts of data, leaving CACHED tables
              for large data sets. For special applications in which speed is
              paramount and a large amount of free memory is available, MEMORY
              tables can be used for large tables as well.</para>
            </listitem>
          </itemizedlist>
        </para>
      </section>

      <section>
        <title>Large Objects</title>

        <para>JDBC clobs are supported as columns of the type LONGVARCHAR.
        JDBC Blobs are supported as columns of the type LONGVARBINARY. When
        large objects (LONGVARCHAR, LONGVARBINARY, OBJECT) are stored with
        table definitions that contain several normal fields, it is better to
        use two tables instead. The first table to contain the normal fields
        and the second table to contain the large object plus an identity
        field. Using this method has two benefits. (a) The first table can
        usually be created as a MEMORY table while only the second table is a
        CACHED table. (b) The large objects can be retrieved individually
        using their identity, instead of getting loaded into memory for
        finding the rows during query processing. An example of two tables and
        a select query that exploits the separation between the two
        follows:</para>

        <informalexample>
          <programlisting>CREATE MEMORY TABLE MAINTABLE(MAINID INTEGER, ......);
CREATE CACHED TABLE LOBTABLE(LOBID INTEGER, LOBDATA LONGVARBINARY);
SELECT * FROM (SELECT * FROM MAINTABLE &lt;join any other table&gt; WHERE &lt;various conditions apply&gt;) JOIN LOBTABLE ON MAINID=LOBID;</programlisting>
        </informalexample>

        <para>The inner SELECT finds the required rows without reference to
        the LOBTABLE and when it has found all the rows, retrieves the
        required large objects from the LOBTABLE.</para>
      </section>

      <section>
        <title>Deployment context</title>

        <para>The files used for storing HSQLDB database data are all in the
        same directory. New files are always created and deleted by the
        database engine. Two simple principles must be observed:</para>

        <itemizedlist>
          <listitem>
            <para>The Java process running HSQLDB must have full privileges on
            the directory where the files are stored. This include create and
            delete privileges.</para>
          </listitem>

          <listitem>
            <para>The file system must have enough spare room both for the
            'permanent' and 'temporary' files. The default maximum size of the
            .log file is 200MB. The .data file can grow to up to 8GB. The
            .backup file can be up to 50% of the .data file. The temporary
            files created at the time of a SHUTDOWN can be equal in size to
            the .script file and the .data file.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="deployment_mem_disk-sect">
      <title>Memory and Disk Use</title>

      <para>Memory used by the program can be thought of as two distinct
      pools: memory used for table data, and memory used for building result
      sets and other internal operations. In addition, when transactions are
      used, memory is utilised for storing the information needed for a
      rollback.</para>

      <para>The memory used for a MEMORY table is the sum of memory used by
      each row. Each MEMORY table row is a Java object that has 2 int or
      reference variables. It contains an array of objects for the fields in
      the row. Each field is an object such as <classname>Integer</classname>,
      <classname>Long</classname>, <classname>String</classname>, etc. In
      addition each index on the table adds a node object to the row. Each
      node object has 6 int or reference variables. As a result, a table with
      just one column of type INTEGER will have four objects per row, with a
      total of 10 variables of 4 bytes each - currently taking up 80 bytes per
      row. Beyond this, each extra column in the table adds at least a few
      bytes to the size of each row.</para>

      <para>All the rows in the result set are built in memory, so very large
      result sets may not be possible. In server mode databases, the result
      set memory is released from the server once the database server has
      returned the result set. <glossterm>in-process</glossterm> databases
      release the memory when the application program releases the
      <classname>java.sql.ResultSet</classname> object. Server modes require
      additional memory for returning result sets, as they convert the full
      result set into an array of bytes which is then transmitted to the
      client.</para>

      <para>When UPDATE and DELETE queries are performed on CACHED tables, the
      full set of rows that are affected, including those affected due to ON
      UPDATE actions, is held in memory for the duration of the operation.
      This means it may not be possible to perform deletes or updates
      involving very large numbers of rows of CACHED tables. Such operations
      should be performed in smaller sets.</para>

      <para>When transactions support is enabled with SET AUTOCOMMIT OFF,
      lists of all insert, delete or update operations are stored in memory so
      that they can be undone when ROLLBACK is issued. Transactions that span
      hundreds of modification to data will take up a lot of memory until the
      next COMMIT or ROLLBACK clears the list.</para>

      <para>Most JVM implementations allocate up to a maximum amount of memory
      (usually 64 MB by default). This amount is generally not adequate when
      large memory tables are used, or when the average size of rows in cached
      tables is larger than a few hundred bytes. The maximum amount of
      allocated memory can be set on the java ... command line that is used
      for running HSQLDB. For example, with Sun JVM version 1.3.0 the
      parameter -Xmx256m increases the amount to 256 MB.</para>

      <para>By default, all the rows in the result set are built in memory, so
      very large result sets may not be possible. In server mode databases,
      the result set memory is released from the server once the database
      server has returned the result set. <glossterm>in-process</glossterm>
      databases release the memory when the application program releases the
      <classname>java.sql.ResultSet</classname> object. Server modes require
      additional memory for returning result sets, as they convert the full
      result set into an array of bytes which is then transmitted to the
      client.</para>

      <para>**todo** updates to cover new large result support</para>

      <para>1.9.0 uses a fast cache for immutable objects such as Integer or
      String that are stored in the database. In most circumstances, this
      reduces the memory footprint still further as fewer copies of the most
      frequently-used objects are kept in memory.</para>

      <section>
        <title>Cache Memory Allocation</title>

        <para>With CACHED tables, the data is stored on disk and only up to a
        maximum number of rows are held in memory at any time. The default is
        up to 3*16384 rows. The <property>hsqldb.cache_scale</property>
        database property can be set to alter this amount. As any random
        subset of the rows in any of the CACHED tables can be held in the
        cache, the amount of memory needed by cached rows can reach the sum of
        the rows containing the largest field data. For example if a table
        with 100,000 rows contains 40,000 rows with 1,000 bytes of data in
        each row and 60,000 rows with 100 bytes in each, the cache can grow to
        contain nearly 50,000 rows, including all the 40,000 larger
        rows.</para>

        <para>An additional property,
        <property>hsqldb.cache_size_scale</property> can be used in
        conjunction with the <property>hsqldb.cache_scale</property> property.
        This puts a limit in bytes on the total size of rows that are cached.
        When the default values is used for both properties, the limit on the
        total size of rows is approximately 50MB. (This is the size of binary
        images of the rows and indexes. It translates to more actual memory,
        typically 2-4 times, used for the cache because the data is
        represented by Java objects.)</para>

        <para>If memory is limited, the
        <property>hsqldb.cache_scale</property> or
        <property>hsqldb.cache_size_scale</property> database properties can
        be reduced. In the example above, if the
        <property>hsqldb.cache_size_scale</property> is reduced from 10 to 8,
        then the total binary size limit is reduced from 50MB to 12.5 MB. This
        will allow the number of cached rows to reach 50,000 small rows, but
        only 12,500 of the larger rows.</para>
      </section>
    </section>

    <section xml:id="deployment_conns-sect">
      <title>Managing Database Connections</title>

      <para>In all running modes (server or <glossterm>in-process</glossterm>)
      multiple connections to the database engine are supported.
      <glossterm>in-process</glossterm> (standalone) mode supports connections
      from the client in the same Java Virtual Machine, while server modes
      support connections over the network from several different
      clients.</para>

      <para>Connection pooling software can be used to connect to the database
      but it is not generally necessary. With other database engines,
      connection pools are used for reasons that may not apply to
      HSQLDB.</para>

      <itemizedlist>
        <listitem>
          <para>To allow new queries to be performed while a time-consuming
          query is being performed in the background. This is not possible
          with HSQLDB 1.9.0 as it blocks while performing the first query and
          deals with the next query once it has finished it. This capability
          is under development and will be introduced in a future
          version.</para>
        </listitem>

        <listitem>
          <para>To limit the maximum number of simultaneous connections to the
          database for performance reasons. With HSQLDB this can be useful
          only if your application is designed in a way that opens and closes
          connections for each small task.</para>
        </listitem>

        <listitem>
          <para>To control transactions in a multi-threaded application. This
          can be useful with HSQLDB as well. For example, in a web
          application, a transaction may involve some processing between the
          queries or user action across web pages. A separate connection
          should be used for each HTTP session so that the work can be
          committed when completed or rolled back otherwise. Although this
          usage cannot be applied to most other database engines, HSQLDB is
          perfectly capable of handling over 100 simultaneous HTTP sessions as
          individual JDBC connections.</para>
        </listitem>
      </itemizedlist>

      <para>An application that is not both multi-threaded and transactional,
      such as an application for recording user login and logout actions, does
      not need more than one connection. The connection can stay open
      indefinitely and reopened only when it is dropped due to network
      problems.</para>

      <para>When using an <glossterm>in-process</glossterm> database with
      versions prior to 1.7.2 the application program had to keep at least one
      connection to the database open, otherwise the database would have been
      closed and further attempts to create connections could fail. This is
      not necessary since 1.7.2, which does not automatically close an
      <glossterm>in-process</glossterm> database that is opened by
      establishing a connection. An explicit SHUTDOWN command, with or without
      an argument, is required to close the database. In version 1.9.0 a
      connection property can be used to revert to the old behaviour.</para>

      <para>When using a server database (and to some extent, an
      <glossterm>in-process</glossterm> database), care must be taken to avoid
      creating and dropping JDBC Connections too frequently. Failure to
      observe this will result in unsuccessful connection attempts when the
      application is under heavy load.</para>
    </section>

    <section xml:id="deployment_upgrade-sect">
      <title>Upgrading Databases</title>

      <para>Any database that is not produced with the release version of
      HSQLDB 1.9.0 must be upgraded to this version. Some catalogs created
      with 1.8.0 can be upgraded simply by opening with HyperSQL 1.9.0. When
      this is not possible due to errors, the rest of the procedures below
      should be followed.</para>

      <para>Once a database is upgraded to 1.9.0, it can no longer be used
      with previous versions of HSQLDB.</para>

      <section xml:id="upgrade_via_script-sect">
        <title xml:id="upgrade_via_script-title">Upgrading From Older
        Versions</title>

        <para>There may be some potential legacy issues in the upgrade from
        very old versions which should be resolved by editing the
        <literal>.script</literal> file:</para>

        <itemizedlist>
          <listitem>
            <para>Version 1.9.0 does not accept duplicate names for table
            columns that were allowed before 1.7.0.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not accept duplicate names for indexes
            that were allowed before 1.7.2.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not create the same type of index for
            foreign keys as versions before 1.7.2.</para>
          </listitem>

          <listitem>
            <para>Version 1.9.0 does not accept table or column names that are
            SQL reserved keywords without double quoting.</para>
          </listitem>
        </itemizedlist>

        <para>To upgrade from 1.7.2, 1.7.3 or 1.8.0 simply issue the SET
        SCRIPTFORMAT TEXT and SHUTDOWN SCRIPT commands with the old version,
        then open with the new version of the engine. The upgrade is then
        complete.</para>

        <para>To upgrade from older version database files (1.7.1 and older)
        that do not contain CACHED tables, simply SHUTDOWN with the older
        version and open with the new version. If there is any error in the
        <literal>.logs</literal> or <literal>.script</literal> file, try again
        after editing the <literal>.logs</literal> or
        <literal>.script</literal> file.</para>

        <para>To upgrade from older version database files (1.7.1 and older)
        that contain CACHED tables, use the SCRIPT procedure below. In all
        versions of HSQLDB, the <literal>SCRIPT 'filename'</literal> command
        (used as an SQL statement) allows you to save a full record of your
        database, including database object definitions and data, to a file of
        your choice. You can export a script file using the old version of the
        database engine and open the script as a database with 1.9.0.</para>

        <procedure>
          <title>Upgrade Using SCRIPT procedure</title>

          <step>
            <para>Open the original database in the old version of
            DatabaseManager</para>
          </step>

          <step>
            <para>Issue the SCRIPT command, for example <literal>SCRIPT
            'newversion.script'</literal> to create a script file containing a
            copy of the database.</para>
          </step>

          <step>
            <para>SHUTDOWN this database.</para>
          </step>

          <step>
            <para>Copy the original <literal>.properties</literal> file into
            <filename>newversion.properties</filename> in the same directory
            as <filename>newversion.script</filename></para>
          </step>

          <step>
            <para>Try to open the new database <filename>newversion</filename>
            using DatabaseManager.</para>
          </step>

          <step>
            <para>If there is any inconsistency in the data, the script line
            number is reported on the console and the opening process is
            aborted. Edit and correct any problems in the
            <filename>newversion.script</filename> before attempting to open
            again. Use the guidelines in the next section (Manual Changes to
            the <literal>.script</literal> File). Use a programming editor
            that is capable of handling very large files and does not wrap
            long lines of text.</para>
          </step>
        </procedure>
      </section>

      <section>
        <title>Manual Changes to the .script File</title>

        <para>In 1.9.0 the full range of ALTER TABLE commands is available to
        change the data structures and their names. However, if an old
        database cannot be opened due to data inconsistencies, or the use of
        index or column names that are not compatible with 1.9.0, manual
        editing of the <literal>.script</literal> file can be performed. Note
        that the <literal>.script</literal> file must be the result of a
        SHUTDOWN SCRIPT and must contain the full data for the
        database.</para>

        <para>The following changes can be applied so long as they do not
        affect the integrity of existing data.</para>

        <itemizedlist>
          <listitem>
            <para>Names of tables, columns and indexes can be changed.</para>
          </listitem>

          <listitem>
            <para><literal>CREATE UNIQUE INDEX ...</literal> to
            <literal>CREATE INDEX ...</literal> and vice versa</para>

            <para>A unique index can always be converted into a normal index.
            A non-unique index can only be converted into a unique index if
            the table data for the column(s) is unique in each row.</para>
          </listitem>

          <listitem>
            <para>
              <literal>NOT NULL</literal>
            </para>

            <para>A not-null constraint can always be removed.</para>
          </listitem>

          <listitem>
            <para>
              <literal>PRIMARY KEY</literal>
            </para>

            <para>A primary key constraint can be removed. It cannot be
            removed if there is a foreign key referencing the
            column(s).</para>
          </listitem>

          <listitem>
            <para>
              <literal>UNIQUE</literal>
            </para>

            <para>A UNIQUE constraint can be removed if there is no foreign
            key referencing the column(s).</para>
          </listitem>

          <listitem>
            <para>
              <literal>FOREIGN KEY</literal>
            </para>

            <para>A FOREIGN KEY constraint can always be removed.</para>
          </listitem>

          <listitem>
            <para>
              <literal>COLUMN TYPES</literal>
            </para>

            <para>Some changes to column types are possible. For example an
            INTEGER column can be changed to BIGINT, or DATE, TIME and
            TIMESTAMP columns can be changed to VARCHAR.</para>
          </listitem>
        </itemizedlist>

        <para>After completing the changes and saving the modified
        <literal>.script</literal> file, you can open the database as
        normal.</para>
      </section>
    </section>

    <section xml:id="deployment_backup-sect">
      <title>Backing Up Database Catalogs</title>

      <para>The database engine saves the files containing all the data in a
      file catalog when a shutdown takes place. It automatically recovers from
      an abnormal termination and preserves the data when the catalog is
      opened next time. In an ideal operating environment, where there is no
      OS crash, disk failure, bugs in code, etc. there would be no need
      regularly to backup a database. This is meant to say, the engine
      performs the routine shutdown procedure internally, therefore backing up
      catalogs is an insurance policy against all sorts of misadventure that
      are not under the control of the database engine.</para>

      <para>The data for each catalog consists of up to 5 files in the same
      directory with the endings such as <literal>*.properties</literal>,
      <literal>*.script</literal>, etc., as detailed in previous chapters
      **todo**</para>

      <simpara>HyperSQL 1.9.0 and later includes commands to backup the
      database files into a single <literal>.tar</literal> or
      <literal>.tar.gz</literal> file archive. The backup can be performed by
      a command given in a JDBC session if the target database catalog is
      running, or on the command-line if the target catalog has been
      shutdown.</simpara>

      <section>
        <title>Making Online Backups</title>

        <simpara>To back up a running catalog, obtain a JDBC connection and
        issue a <literal>BACKUP DATABASE</literal> command in SQL. In its most
        simple form, the command format below will backup the database as a
        single <literal>.tar.gz</literal> file to the given
        directory.</simpara>

        <programlisting>BACKUP DATABASE TO &lt;directory name&gt; BLOCKING</programlisting>

        <simpara>See the <remark>Add link to sqlsyntax_backup-sect</remark>
        SQL Syntax Chapter for details about the command and its options. See
        the sections below about restoring a backup.</simpara>
      </section>

      <section>
        <title>Making Offline Backups</title>

        <para>To back up an offline catalog, the catalog must be in shut down
        state. You will run a Java command like this <example>
            <title>Offline Backup Example</title>

            <screen>
    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --save  \
    tar/path.tar db/base/path</screen>
          </example>where <filename>tar/path.tar</filename> is a file path to
        the <literal>*.tar</literal> or <literal>*.tar.gz</literal> file to be
        created, and <filename>db/base/path</filename> is the file path to the
        catalog file base name (in same fashion as in
        <varname>server.database.*</varname> settings and JDBC URLs with
        catalog type <glossterm>file:</glossterm>.</para>
      </section>

      <section>
        <title>Examining Backups</title>

        <para>You can list the contents of backup tar files with
        <classname>DbBackup</classname> on your operating system command line,
        or with any Pax-compliant tar or pax client (this includes GNU tar),
        <example>
            <title>Listing a backup with DbBackup</title>

            <screen>
    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --list tar/path.tar</screen>
          </example>You can also give regular expressions at the end of the
        command line if you are only interested in some of the file entries in
        the backup. Note that these are real regular expressions, not shell
        globbing patterns, so you would use <literal>.+script</literal> to
        match entries ending in "script", not
        <literal>*script</literal>.</para>

        <simpara>You can examine the contents of the backup in their entirety
        by restoring the backup, as explained in the following section, to a
        temporary directory.</simpara>
      </section>

      <section>
        <title>Restoring a Backup</title>

        <para>You use <classname>DbBackup</classname> on your operating system
        command line to restore a catalog from a backup. <example>
            <title>Restoring a backup with DbBackup</title>

            <screen>
    java -cp path/to/hsqldb.jar org.hsqldb.lib.tar.DbBackup --extract  \
    tar/path.tar db/dir</screen>
          </example>where <filename>tar/path.tar</filename> is a file path to
        the *.tar or *.tar.gz file to be read, and <filename>db/dir</filename>
        is the target directory to extract the catalog files into. Note that
        <filename>db/dir</filename> specifies a directory path, without the
        catalog file base name. The files will be created with the names
        stored in the tar file (and which you can see as described in the
        preceding section).</para>
      </section>
    </section>
  </chapter>

  <chapter xml:id="texttables-chapt">
    <title xml:id="texttables-title">Text Tables</title>

    <subtitle>Text Tables as a Standard Feature of Hsqldb</subtitle>

    <info>
      <authorgroup>
        <author>
          <personname>
            <firstname>Bob</firstname>

            <surname>Preston</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>
        </author>

        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Text</keyword>

        <keyword>Tables</keyword>
      </keywordset>

      <legalnotice>
        <para>Copyright 2002-2009 Bob Preston and Fred Toussi. Permission is
        granted to distribute this document without any alteration under the
        terms of the HSQLDB license. Additional permission is granted to the
        HSQLDB Development Group to distribute this document with or without
        alterations under the terms of the HSQLDB license.</para>
      </legalnotice>
    </info>

    <para>Text Table support for HSQLDB was originally developed by Bob
    Preston independently from the Project. Subsequently Bob joined the
    Project and incorporated this feature into version 1.7.0, with a number of
    enhancements, especially the use of conventional SQL commands for
    specifying the files used for Text Tables.</para>

    <para>In a nutshell, Text Tables are CSV or other delimited files treated
    as SQL tables. Any ordinary CSV or other delimited file can be used. The
    full range of SQL queries can be performed on these files, including
    SELECT, INSERT, UPDATE and DELETE. Indexes and unique constraints can be
    set up, and foreign key constraints can be used to enforce referential
    integrity between Text Tables themselves or with conventional
    tables.</para>

    <para>HyperSQL with Text Table support is the only comprehensive solution
    that employs the power of SQL and the universal reach of JDBC to handle
    data stored in text files and will have wide-ranging use way beyond the
    currently established Java realm of HSQLDB.</para>

    <section xml:id="texttables_impl-sect">
      <title>The Implementation</title>

      <section>
        <title>Definition of Tables</title>

        <para>Text Tables are defined similarly to conventional tables with
        the added TEXT keyword:</para>

        <programlisting>
    CREATE TEXT TABLE &lt;tablename&gt; (&lt;column definition&gt; [&lt;constraint definition&gt;])</programlisting>

        <para>In addition, a SET command specifies the file and the separator
        character that the Text table uses:</para>

        <programlisting>
    SET TABLE &lt;tablename&gt; SOURCE &lt;quoted_filename_and_options&gt; [DESC]</programlisting>

        <para>Text Tables cannot be created in <glossterm>mem:</glossterm>
        (all-in-memory) databases (databases that have no script file).</para>
      </section>

      <section>
        <title>Scope and Reassignment</title>

        <itemizedlist>
          <listitem>
            <para>A Text table without a file assigned to it is READ ONLY and
            EMPTY.</para>
          </listitem>

          <listitem>
            <para>A Temporary Text table has the scope and the lifetime of the
            SQL session (a JDBC Connection). **todo** (consider current lack
            of support)</para>
          </listitem>

          <listitem>
            <para>Reassigning a Text Table definition to a new file has
            implications in the following areas:</para>

            <orderedlist>
              <listitem>
                <para>The user is required to be an administrator.</para>
              </listitem>

              <listitem>
                <para>Existing transactions are committed at this
                point.</para>
              </listitem>

              <listitem>
                <para>Constraints, including foreign keys referencing this
                table, are kept intact. It is the responsibility of the
                administrator to ensure their integrity.</para>
              </listitem>
            </orderedlist>

            <para>The new source file is scanned and indexes are built when it
            is assigned to the table. At this point any violation of NOT NULL,
            UNIQUE or PRIMARY KEY constraints are caught and the assignment is
            aborted. However, foreign key constraints are not checked at the
            time of assignment or reassignment of the source file.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Null Values in Columns of Text Tables</title>

        <itemizedlist>
          <listitem>
            <para>Empty fields are treated as NULL. These are fields where
            there is nothing or just spaces between the separators.</para>
          </listitem>

          <listitem>
            <para>Quoted empty strings are treated as empty strings.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Configuration</title>

        <para>The default field separator is a comma (,). A different field
        separator can be specified within the SET TABLE SOURCE statement. For
        example, to change the field separator for the table mytable to a
        vertical bar, place the following in the SET TABLE SOURCE statement,
        for example:</para>

        <informalexample>
          <programlisting>
    SET TABLE mytable SOURCE "myfile;fs=|"</programlisting>
        </informalexample>

        <para>Since HSQLDB treats CHAR's, VARCHARs, and LONGVARCHARs the same,
        the ability to assign different separators to the latter two is
        provided. When a different separator is assigned to a VARCHAR or
        LONGVARCHAR field, it will terminate any CSV field of that type. For
        example, if the first field is CHAR, and the second field LONGVARCHAR,
        and the separator fs has been defined as the pipe (|) and vs as the
        period (.) then the data in the CSV file for a row will look
        like:</para>

        <screen>
    First field data|Second field data.Third field data</screen>

        <para>The following example shows how to change the default separator
        to the pipe (|), VARCHAR separator to the period (.) and the
        LONGVARCHAR separator to the tilde (~). Place the following within the
        SET TABLE SOURCE statement, for example:</para>

        <informalexample>
          <programlisting>
    SET TABLE mytable SOURCE "myfile;fs=|;vs=.;lvs=~"</programlisting>
        </informalexample>

        <para>HSQLDB also recognises the following special indicators for
        separators:</para>

        <variablelist>
          <title>special indicators for separators</title>

          <varlistentry>
            <term>\semi</term>

            <listitem>
              <para>semicolon</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\quote</term>

            <listitem>
              <para>single-quote</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\space</term>

            <listitem>
              <para>space character</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\apos</term>

            <listitem>
              <para>apostrophe</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\n</term>

            <listitem>
              <para>newline - Used as an end anchor (like $ in regular
              expressions)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\r</term>

            <listitem>
              <para>carriage return</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\t</term>

            <listitem>
              <para>tab</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\\</term>

            <listitem>
              <para>backslash</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\u####</term>

            <listitem>
              <para>a Unicode character specified in hexadecimal</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Furthermore, HSQLDB provides csv file support with three
        additional boolean options: <varname>ignore_first</varname>,
        <varname>quoted</varname> and <varname>all_quoted</varname>. The
        <varname>ignore_first</varname> option (default false) tells HSQLDB to
        ignore the first line in a file. This option is used when the first
        line of the file contains column headings. The
        <varname>all_quoted</varname> option (default false) tells the program
        that it should use quotes around all character fields when writing to
        the source file. The <varname>quoted</varname> option (default true)
        uses quotes only when necessary to distinguish a field that contains
        the separator character. It can be set to false to prevent the use of
        quoting altogether and treat quote characters as normal characters.
        These options may be specified within the <literal>SET TABLE
        SOURCE</literal> statement:</para>

        <programlisting>
    SET TABLE mytable SOURCE "myfile;ignore_first=true;all_quoted=true"</programlisting>

        <para>When the default options <literal>all_quoted=</literal>
        <literal>false</literal> and <literal>quoted=true</literal> are in
        force, fields that are written to a line of the csv file will be
        quoted only if they contain the separator or the quote character. The
        quote character is doubled when used inside a string. When
        <literal>all_quoted=false</literal> and
        <literal>quoted=false</literal> the quote character is not doubled.
        With this option, it is not possible to insert any string containing
        the separator into the table, as it would become impossible to
        distinguish from a separator. While reading an existing data source
        file, the program treats each individual field separately. It
        determines that a field is quoted only if the first character is the
        quote character. It interprets the rest of the field on this
        basis.</para>

        <para>The character encoding for the source file is<literal> ASCII
        </literal>by default. To support UNICODE or source files prepared with
        different encodings this can be changed to <literal>UTF-8</literal> or
        any other encoding. The default is <literal>encoding=ASCII
        </literal>and the option <literal>encoding=UTF-8</literal> or other
        supported encodings can be used.</para>

        <para>Finally, HSQLDB provides the ability to read a text file from
        the bottom up and making them READ ONLY, by placing the keyword "DESC"
        at the end of the SET TABLE SOURCE statement: *** not supported now
        **</para>

        <programlisting>
    SET TABLE mytable SOURCE "myfile" DESC</programlisting>

        <para>This feature provides functionality similar to the Unix tail
        command, by re-reading the file each time a select is executed. Using
        this feature sets the table to read-only mode. Afterwards, it will no
        longer be possible to change the read-only status with <literal>SET
        TABLE &lt;tablename&gt; READONLY TRUE</literal>.</para>

        <para>Text table source files are cached in memory. The maximum number
        of rows of data that are in memory at any time is controlled by the
        <varname>textdb.cache_scale</varname> property. The default value for
        <varname>textdb.cache_scale</varname> is 10 and can be changed by
        setting the property in the .properties file for the database. The
        number of rows in memory is calculated as 3*(2**scale), which
        translates to 3072 rows for the default textdb.cache_scale setting
        (10). The property can also be set for individual text tables:</para>

        <programlisting>
    SET TABLE mytable SOURCE "myfile;ignore_first=true;all_quoted=true;cache_scale=12"</programlisting>
      </section>

      <section xml:id="disconnecting_text_tables">
        <title>Disconnecting Text Tables</title>

        <para>Text tables may be <emphasis>disconnected</emphasis> from their
        underlying data source, i.e. the text file.</para>

        <para>You can explicitly disconnect a text table from its file by
        issuing the following statement: <programlisting>  SET TABLE mytable SOURCE OFF</programlisting></para>

        <para>Subsequently, <literal>mytable</literal> will be empty and
        read-only. However, the data source description will be preserved, and
        the table can be re-connected to it with <programlisting>  SET TABLE mytable SOURCE ON</programlisting></para>

        <para>When a database is opened, if the source file for an existing
        text table is missing the table remains disconnected from its data
        source, but the source description is preserved. This allows the
        missing source file to be added to the directory and the table
        re-connected to it with the above command.</para>
      </section>
    </section>

    <section xml:id="texttables_issues-sect">
      <title>Text File Issues</title>

      <itemizedlist>
        <title>Text File Issues</title>

        <listitem>
          <para>File locations are restricted to below the directory that
          contains the database, unless the
          <varname>textdb.allow_full_path</varname> property is set true in
          the database properties file.</para>
        </listitem>

        <listitem>
          <para>Blank lines are allowed anywhere in the text file, and are
          ignored.</para>
        </listitem>

        <listitem>
          <para>The file location for a text table created with ** not
          supported now **</para>

          <programlisting>
    SELECT &lt;select list&gt; INTO TEXT &lt;tablename&gt; FROM</programlisting>

          <para>is the directory that contains the database and the file name
          is based on the table name. The table name is converted into the
          file name by replacing all the non-alphanumeric characters with the
          underscore character, conversion into lowercase, and adding the
          ".csv" suffix.</para>
        </listitem>

        <listitem>
          <para>It is possible to define a primary key or identity column for
          text tables.</para>
        </listitem>

        <listitem>
          <para>When a table source file is used with the<literal>
          ignore_first=true </literal>option, the first, ignored line is
          replaced with a blank line after a SHUTDOWN COMPACT.</para>
        </listitem>

        <listitem>
          <para>An existing table source file may include CHARACTER fields
          that do not begin with the quote character but contain instances of
          the quote character. These fields are read as literal strings.
          Alternatively, if any field begins with the quote character, then it
          is interpreted as a quoted string that should end with the quote
          character and any instances of the quote character within the string
          is doubled. When any field containing the quote character or the
          separator is written out to the source file by the program, the
          field is enclosed in quote character and any instance of the quote
          character inside the field is doubled.</para>
        </listitem>

        <listitem>
          <para>Inserts or updates of CHARACTER type field values are allowed
          with strings that contains the linefeed or the carriage return
          character. This feature is disabled when both quoted and all_quoted
          properties are false.</para>
        </listitem>

        <listitem>
          <para>ALTER TABLE commands that add or drop columns are not
          supported with non-empty text tables.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="texttables_globalprops-sect">
      <title>Text File Global Properties</title>

      <itemizedlist>
        <title>Complete list of supported global properties in *.properties
        files</title>

        <listitem>
          <para>
            <varname>textdb.fs</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.lvs</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.quoted</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.all_quoted</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.ignore_first</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.encoding</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.cache_scale</varname>
          </para>
        </listitem>

        <listitem>
          <para>
            <varname>textdb.allow_full_path</varname>
          </para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter xml:id="sqlsyntax-chapt">
    <title xml:id="sqlsyntax-title">SQL Syntax</title>

    <info>
      <authorgroup>
        <editor>
          <orgname>The HSQLDB Development Group</orgname>
        </editor>

        <author>
          <personname>
            <firstname>Fred</firstname>

            <surname>Toussi</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>ft@cluedup.com</email>
        </author>

        <author>
          <personname>
            <firstname>Peter</firstname>

            <surname>Hudson</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>
        </author>

        <author>
          <personname>
            <firstname>Joe</firstname>

            <surname>Maher</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>jrmaher@ameritech.net</email>
        </author>

        <editor>
          <personname>
            <firstname>Blaine</firstname>

            <surname>Simpson</surname>
          </personname>

          <affiliation>
            <orgname>HSQLDB Development Group</orgname>
          </affiliation>

          <email>blaine.simpson@admc.com</email>
        </editor>
      </authorgroup>

      <edition>$Revision$</edition>

      <pubdate>$Date$</pubdate>

      <keywordset>
        <keyword>Hsqldb</keyword>

        <keyword>Syntax</keyword>

        <keyword>SQL</keyword>
      </keywordset>
    </info>

    <para>HSQLDB version 1.8.0 supports the SQL statements and syntax
    described in this chapter. This chapter has not been updated to cover the
    additional features of 1.9.0</para>

    <section xml:id="sqlsyntax_notation-sect">
      <title>Notational Conventions Used in this Chapter</title>

      <para><literal>[A]</literal> means A is optional.</para>

      <para><literal>{ B | C }</literal> means either B or C must be
      used.</para>

      <para><literal>[{ B | C }]</literal> means either B or C may optionally
      be used, or nothing at all.</para>

      <para><literal>(</literal> and <literal>)</literal> are the actual
      characters '(' and ')' used in statements.</para>

      <para>UPPERCASE words are keywords</para>
    </section>

    <section xml:id="sqlsyntax_sqlcommands-sect">
      <title>SQL Commands</title>

      <!-- The first items using footnotes must define them.
         That's why this one has "<footnode xml:id=" instead of "<footnoteref..."
     -->

      <section xml:id="alter_index-sect">
        <title xml:id="alter_index-title">ALTER INDEX<footnote
            xml:id="posthyper">
            <para>These features were added by HSQL Development Group since
            April 2001</para>
          </footnote></title>

        <programlisting>ALTER INDEX &lt;indexname&gt; RENAME TO &lt;newname&gt;;</programlisting>

        <para>Index names can be changed so long as they do not conflict with
        other user-defined or system-defined names.</para>
      </section>

      <!-- Template for new items:  (Put new items into alphabetical position)
    <section xml:id="@-sect">
        <title xml:id="@-title">@<footnoteref linkend="posthyper"/></title>
        <programlisting>
        </programlisting>
        <para>
        </para> <para>
        </para>
    </section>
    -->

      <section xml:id="alter_sequence-sect">
        <title xml:id="alter_sequence-title">ALTER SEQUENCE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>ALTER SEQUENCE &lt;sequencename&gt; RESTART WITH &lt;value&gt;;</programlisting>

        <para>Resets the next value to be returned from the sequence.</para>
      </section>

      <section>
        <title>ALTER SCHEMA<footnoteref linkend="posthyper" /></title>

        <programlisting>ALTER SCHEMA &lt;schemaname&gt; RENAME TO &lt;newname&gt;;</programlisting>

        <para>Renames the schema as specified. All objects of the schema will
        hereafter be accessible only with the new schema name.</para>

        <para>Requires Administrative privileges.</para>
      </section>

      <section xml:id="alter_table-sect">
        <title xml:id="alter_table-title">ALTER TABLE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>ALTER TABLE &lt;tablename&gt; ADD [COLUMN] &lt;columnname&gt; <link
            linkend="sqlsyntax_datatypes-sect">Datatype</link>
    [(columnSize[,precision])] [{DEFAULT &lt;defaultValue&gt; |
    GENERATED BY DEFAULT AS IDENTITY (START WITH &lt;n&gt;[, INCREMENT BY &lt;m&gt;])}] |
    [[NOT] NULL] [IDENTITY] [PRIMARY KEY]
    [BEFORE &lt;existingcolumn&gt;];</programlisting>

        <para>Adds the column to the end of the column list. The optional
        BEFORE &lt;existingcolumn&gt; can be used to specify the name of an
        existing column so that the new column is inserted in a position just
        before the &lt;existingcolumn&gt;.</para>

        <para>It accepts a <link endterm="columnDef-title"
        linkend="columnDef-entry" /> as in a CREATE TABLE command. If NOT NULL
        is specified and the table is not empty, then a default value must be
        specified. In all other respects, this command is the equivalent of a
        column definition statement in a CREATE TABLE statement.</para>

        <para>If an SQL view includes a SELECT * FROM &lt;tablename&gt; in its
        select statement, the new column is added to the view. This is a
        non-standard feature which is likely to change in the future.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; DROP [COLUMN] &lt;columnname&gt;;</programlisting>

        <para>Drops the column from the table. Will drop any single-column
        primary key or unique constraint on the column as well. The command
        will not work if there is any multiple key constraint on the column or
        the column is referenced in a check constraint or a foreign
        key.</para>

        <para>It will also fail if an SQL view includes the column.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;columnname&gt; RENAME TO &lt;newname&gt; </programlisting>

        <para>Changes a column name.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;columnname&gt; SET DEFAULT &lt;defaultvalue&gt;};</programlisting>

        <para>Adds the specified default value to the column. Use NULL to
        remove a default.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;columnname&gt; SET [NOT] NULL</programlisting>

        <para>Sets or removes a NOT NULL constraint for the column.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;columnDefinition&gt;;</programlisting>

        <para>This form of ALTER TABLE ALTER COLUMN accepts a <link
        endterm="columnDef-title" linkend="columnDef-entry" /> as in a CREATE
        TABLE command, with the following restrictions.</para>

        <itemizedlist>
          <title>Restrictions</title>

          <listitem>
            <simpara>The column must be already be a PK column to accept an
            IDENTITY definition.</simpara>
          </listitem>

          <listitem>
            <simpara>If the column is already an IDENTITY column and there is
            no IDENTITY definition, the existing IDENTITY attribute is
            removed.</simpara>
          </listitem>

          <listitem>
            <simpara>The default expression will be that of the new
            definition, meaning an existing default can be dropped by
            omission, or a new default added.</simpara>
          </listitem>

          <listitem>
            <simpara>The NOT NULL attribute will be that of the new definition
            (similar to previous item).</simpara>
          </listitem>

          <listitem>
            <simpara>Depending on the type of change, the table may have to be
            empty for the command to work. It always works when the type of
            change is possible in general and the individual existing values
            can all be converted.</simpara>
          </listitem>
        </itemizedlist>

        <programlisting>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;columnname&gt;
    RESTART WITH &lt;new sequence value&gt;</programlisting>

        <para>This form is used exclusively for IDENTITY columns and changes
        the next automatic value for the identity sequence.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ADD [CONSTRAINT &lt;constraintname&gt;]
    CHECK (&lt;search condition&gt;);</programlisting>

        <para>Adds a check constraint to the table. In the current version, a
        check constraint can reference only the row being inserted or
        updated.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ADD [CONSTRAINT &lt;constraintname&gt;] UNIQUE (&lt;column list&gt;);</programlisting>

        <para>Adds a unique constraint to the table. This will not work if
        there is already a unique constraint covering exactly the same
        &lt;column list&gt;.</para>

        <para>This will work only if the values of the column list for the
        existing rows are unique or include a null value.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; ADD [CONSTRAINT &lt;constraintname&gt;]
    PRIMARY KEY (&lt;column list&gt;);</programlisting>

        <para>Adds a primary key constraint to the table, using the same
        constraint syntax as when the primary key is specified in a table
        definition.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt;
    ADD [CONSTRAINT &lt;constraintname&gt;] FOREIGN KEY (&lt;column list&gt;)
    REFERENCES &lt;exptablename&gt; (&lt;column list&gt;)
    [ON {DELETE | UPDATE} {CASCADE | SET DEFAULT | SET NULL}];</programlisting>

        <para>Adds a foreign key constraint to the table, using the same
        constraint syntax as when the foreign key is specified in a table
        definition.</para>

        <para>This will fail if for each existing row in the referring table,
        a matching row (with equal values for the column list) is not found in
        the referenced tables.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT &lt;constraintname&gt;;</programlisting>

        <para>Drop a named unique, check or foreign key constraint from the
        table.</para>

        <programlisting>ALTER TABLE &lt;tablename&gt; RENAME TO &lt;newname&gt;;</programlisting>
      </section>

      <section xml:id="alter_user-sect">
        <title xml:id="alter_user-title">ALTER USER<footnoteref
        linkend="posthyper" /></title>

        <programlisting>ALTER USER &lt;username&gt; SET PASSWORD &lt;password&gt;;</programlisting>

        <para>Changes the password for an existing user. Password must be
        double quoted. Use "" for an empty password.</para>

        <para>DBA's may change users' base default schema name with the
        command <programlisting>ALTER USER &lt;username&gt; SET INITIAL SCHEMA &lt;schemaname&gt;;</programlisting>
        This is the schema which database object names will resolve to for
        this user, unless overridden as explained in <link
        endterm="sqlsyntax_schemanaming-title"
        linkend="sqlsyntax_schemanaming-sect" />. For reasons of backwards
        compatibility, the initial schema value will not be persisted across
        database shutdowns until HSQLDB version 1.8.1. (I.e., INITIAL SCHEMA
        settings will be lost upon database shutdown with HSQLDB versions
        lower than version 1.8.1).</para>

        <para>Only an administrator may use these commands.</para>
      </section>

      <section xml:id="call-sect">
        <title xml:id="call-title">CALL</title>

        <programlisting>CALL <link linkend="sqlsyntax_expression-sect">
            Expression</link>;</programlisting>

        <para>Any expression can be called like a stored procedure, including,
        but not only Java stored procedures or functions. This command returns
        a ResultSet with one column and one row (the result) just like a
        SELECT statement with one row and one column.</para>

        <para>See also: <link endterm="sqlsyntax_stored-title"
        linkend="sqlsyntax_stored-sect" />, <link
        endterm="sqlsyntax_expression-title"
        linkend="sqlsyntax_expression-sect" />.</para>
      </section>

      <section xml:id="checkpoint-sect">
        <title xml:id="checkpoint-title">CHECKPOINT</title>

        <programlisting>CHECKPOINT [DEFRAG<footnoteref linkend="posthyper" />];</programlisting>

        <para>Closes the database files, rewrites the script file, deletes the
        log file and opens the database.</para>

        <para>If DEFRAG is specified, this command also shrinks the .data file
        to its minimal size.</para>

        <para>See also: <link endterm="shutdown-title"
        linkend="shutdown-sect" />, <link endterm="set_logsize-title"
        linkend="set_logsize-sect" />.</para>
      </section>

      <section xml:id="commit-sect">
        <title xml:id="commit-title">COMMIT</title>

        <programlisting>COMMIT [WORK];</programlisting>

        <para>Ends a transaction and makes the changes permanent.</para>

        <para>See also: <link endterm="rollback-title"
        linkend="rollback-sect" />, <link endterm="set_autocommit-title"
        linkend="set_autocommit-sect" />, <link endterm="set_logsize-title"
        linkend="set_logsize-sect" />.</para>
      </section>

      <section xml:id="connect-sect">
        <title xml:id="connect-title">CONNECT</title>

        <programlisting>CONNECT USER &lt;username&gt; PASSWORD &lt;password&gt;;</programlisting>

        <para>Connects to the database as a different user. Password should be
        double quoted. Use "" for an empty password.</para>

        <para>See also: <link endterm="grant-title" linkend="grant-sect" />,
        <link endterm="revoke-title" linkend="revoke-sect" />.</para>
      </section>

      <section xml:id="create_alias-sect">
        <title xml:id="create_alias-title">CREATE ALIAS</title>

        <programlisting>CREATE ALIAS &lt;function&gt; FOR &lt;javaFunction&gt;;</programlisting>

        <para>Creates an alias for a static Java function to be used as a
        <link linkend="sqlsyntax_stored-sect">Stored Procedure</link>. The
        function must be accessible from the JVM in which the database runs.
        Example:</para>

        <informalexample>
          <programlisting>    CREATE ALIAS ABS FOR "java.lang.Math.abs";</programlisting>
        </informalexample>

        <note>
          <simpara>The CREATE ALIAS command just defines the alias. It does
          not validate existence of the target method or its containing class.
          To validate the alias, use it.</simpara>
        </note>

        <para>See also: <link endterm="call-title" linkend="call-sect" />,
        <link endterm="sqlsyntax_stored-title"
        linkend="sqlsyntax_stored-sect" />.</para>
      </section>

      <section xml:id="create_index-sect">
        <title xml:id="create_index-title">CREATE INDEX</title>

        <programlisting>CREATE [UNIQUE] INDEX &lt;index&gt; ON &lt;table&gt; (&lt;column&gt; [DESC] [, ...]) [DESC];</programlisting>

        <para>Creates an index on one or more columns in a table.</para>

        <para>Creating an index on searched columns may improve performance.
        The qualifier DESC can be present for command compatibility with other
        databases but it has no effect. Unique indexes can be defined but this
        is deprecated. Use UNIQUE constraints instead. The name of an index
        must be unique within the whole database.</para>

        <para>See also: <link endterm="create_table-title"
        linkend="create_table-sect" />, <link endterm="drop_index-title"
        linkend="drop_index-sect" />.</para>
      </section>

      <section xml:id="create_role-sect">
        <title xml:id="create_role-title">CREATE ROLE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>CREATE ROLE &lt;rolename&gt;;</programlisting>

        <para>Creates the named role with no members. Requires Administrative
        privileges.</para>
      </section>

      <section>
        <title>CREATE SCHEMA<footnoteref linkend="posthyper" /></title>

        <programlisting>CREATE SCHEMA &lt;schemaname&gt; AUTHORIZATION &lt;grantee&gt;
    [&lt;createStatement&gt; [&lt;grantStatement&gt;] [...];</programlisting>

        <para>Creates the named schema, with ownership of the specified
        <emphasis>authorization</emphasis>. The authorization grantee may be a
        database user or a role.</para>

        <para>Optional (nested) CREATE and GRANT statements can be given only
        for new objects in this new schema. Only the last nested statement
        should be terminated with a semicolon, because the first semicolon
        encountered after "CREATE SCHEMA" will end the CREATE SCHEMA command.
        In the example below, a new schema, ACCOUNTS, is created, then two
        tables and a view are added to this schema and some rights on these
        objects are granted.<informalexample>
            <programlisting>    CREATE SCHEMA ACCOUNTS AUTHORIZATION DBA
        CREATE TABLE AB(A INTEGER, ...)
        CREATE TABLE CD(C CHAHR, ...)
        CREATE VIEW VI AS SELECT ...
        GRANT SELECT TO PUBLIC ON AB
        GRANT SELECT TO JOE ON CD;
</programlisting>
          </informalexample> Note that this example consists of one CREATE
        SCHEMA statement which is terminated by a semicolon.</para>

        <simpara>Requires Administrative privileges.</simpara>
      </section>

      <section xml:id="create_sequence-sect">
        <title xml:id="create_sequence-title">CREATE SEQUENCE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>CREATE SEQUENCE &lt;sequencename&gt; [AS {INTEGER | BIGINT}]
    [START WITH &lt;startvalue&gt;] [INCREMENT BY &lt;incrementvalue&gt;];</programlisting>

        <para>Creates a sequence. The default type is INTEGER. The default
        start value is 0 and the increment 1. Negative values are not allowed.
        If a sequence goes beyond Integer.MAXVALUE or Long.MAXVALUE, the next
        result is determined by 2's complement arithmetic.</para>

        <para>The next value for a sequence can be included in SELECT, INSERT
        and UPDATE statements as in the following example:</para>

        <para>
          <informalexample>
            <programlisting>SELECT [...,] NEXT VALUE FOR &lt;sequencename&gt; [, ...] FROM &lt;tablename&gt;;</programlisting>
          </informalexample>
        </para>

        <para>In the proposed SQL 200n and in the current version, there is no
        way of retrieving the last returned value of a sequence.</para>
      </section>

      <section xml:id="create_table-sect">
        <title xml:id="create_table-title">CREATE TABLE</title>

        <programlisting>CREATE [MEMORY | CACHED | [GLOBAL] TEMPORARY | TEMP <footnoteref
            linkend="posthyper" /> | TEXT<footnoteref linkend="posthyper" />] TABLE &lt;name&gt;
    ( &lt;columnDefinition&gt; [, ...] [, &lt;constraintDefinition&gt;...] )
    [ON COMMIT {DELETE | PRESERVE} ROWS];</programlisting>

        <para>Creates a table in memory (default) or on disk and only cached
        in memory. If the database is all-in-memory, both MEMORY and CACHED
        forms of CREATE TABLE return a MEMORY table while the TEXT form is not
        allowed.</para>

        <variablelist>
          <title>Components of a CREATE TABLE command</title>

          <varlistentry xml:id="columnDef-entry">
            <!-- N.b.!!!!  Put NO whitespace immediately after programlisting
               tags, because the way DocBook formats the itemlist in PDF, we
               have no whitespace to waste to fit the examples in the 
               horizontal space. -->

            <term xml:id="columnDef-title">columnDefinition</term>

            <listitem>
              <programlisting>columnname
              <link linkend="sqlsyntax_datatypes-sect">Datatype</link> [(columnSize[,precision])]
    [{DEFAULT &lt;defaultValue&gt; |
    GENERATED BY DEFAULT AS IDENTITY
    (START WITH &lt;n&gt;[, INCREMENT BY &lt;m&gt;])}] |
    [[NOT] NULL] [IDENTITY] [PRIMARY KEY]</programlisting>

              <para>Default values that are allowed are constant values or
              certain SQL datetime functions.</para>

              <itemizedlist>
                <title>Allowed Default Values in Column Definitions</title>

                <listitem>
                  <para>For character column, a single-quoted string or NULL.
                  The only SQL function that can be used is
                  CURRENT_USER.</para>
                </listitem>

                <listitem>
                  <para>For datetime columns, a single-quoted DATE, TIME or
                  TIMESTAMP value or NULL. Or a datetime SQL function such as
                  CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, TODAY, NOW.
                  Each function is allowed for a certain datetime type.</para>
                </listitem>

                <listitem>
                  <para>For BOOLEAN columns, the literals FALSE, TRUE,
                  NULL.</para>
                </listitem>

                <listitem>
                  <para>For numeric columns, any valid number or NULL.</para>
                </listitem>

                <listitem>
                  <para>For binary columns, any valid hex string or
                  NULL.</para>
                </listitem>
              </itemizedlist>

              <para>Only one identity column is allowed in each table.
              Identity columns are autoincrement columns. They must be of
              INTEGER or BIGINT type and are automatically primary key columns
              (as a result, multi-column primary keys are not possible with an
              IDENTITY column present). Using the long SQL syntax the (START
              WITH &lt;n&gt;) clause specifies the first value that will be
              used. The last inserted value into an identity column for a
              connection is available using the function IDENTITY(), for
              example (where Id is the identity column):</para>

              <informalexample>
                <programlisting>INSERT INTO Test (Id, Name) VALUES (NULL,'Test');
    CALL IDENTITY();</programlisting>
              </informalexample>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>constraintDefinition</term>

            <listitem>
              <programlisting>[CONSTRAINT &lt;name&gt;]
    UNIQUE ( &lt;column&gt; [,&lt;column&gt;...] ) |
    PRIMARY KEY ( &lt;column&gt; [,&lt;column&gt;...] ) |
    FOREIGN KEY ( &lt;column&gt; [,&lt;column&gt;...] )
    REFERENCES &lt;refTable&gt; ( &lt;column&gt; [,&lt;column&gt;...]) 
    [ON {DELETE | UPDATE}
    {CASCADE | SET DEFAULT | SET NULL}]<footnoteref linkend="posthyper" /> |
    CHECK(&lt;search condition&gt;)<footnoteref linkend="posthyper" /></programlisting>

              <para>Both ON DELETE and ON UPDATE clauses can be used in a
              single foreign key definition.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>search condition</term>

            <listitem>
              <para>A search condition is similar to the set of conditions in
              a WHERE clause. In the current version of HSQLDB, the conditions
              for a CHECK constraint can only reference the current row,
              meaning there should be no SELECT statement. Sample table
              definitions with CHECK constraints are in <remark>Add verbatim
              link here</remark>
              <filename>TestSelfCheckConstraints.txt</filename>. This file is in
              the /hsqldb/testrun/hsqldb/ directory of the zip.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>General syntax limitations</term>

            <listitem>
              <para>HSQLDB databases are initially created in a legacy mode
              that does not enforce column size and precision. You can set the
              property: <code>sql.enforce_strict_size=true</code> to enable
              this feature. When this property has been set, Any supplied
              column size and precision for numeric and character types
              (CHARACTER and VARCHAR) are enforced. Use the command, <code>SET
              PROPERTY "sql.enforce_strict_size" TRUE</code> once before
              defining the tables.</para>

              <para>NOT NULL constraints can be part of the column definition
              only. Other constraints cannot be part of the column definition
              and must appear at the end of the column definition list.</para>

              <para>TEMPORARY TABLE contents for each session (connection) are
              emptied by default at each commit or rollback. The optional
              qualifier ON COMMIT PRESERVE ROWS can be used to keep the rows
              while the session is open. The default is ON COMMIT DELETE
              ROWS.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>See also: <link endterm="drop_table-title"
        linkend="drop_table-sect" />.</para>
      </section>

      <section xml:id="create_trigger-sect">
        <title xml:id="create_trigger-title">CREATE TRIGGER<footnoteref
        linkend="posthyper" /></title>

        <programlisting>CREATE TRIGGER &lt;name&gt; {BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON &lt;table&gt;
    [FOR EACH ROW] [QUEUE n] [NOWAIT] CALL &lt;TriggerClass&gt;;</programlisting>

        <para>TriggerClass is an application-supplied class that implements
        the <classname>org.hsqldb.Trigger</classname> interface e.g.
        "mypackage.TrigClass". It is the fire method of this class that is
        invoked when the trigger event occurs. You should provide this class,
        which can have any name, and ensure that this TriggerClass is present
        in the classpath which you use to start hsqldb.</para>

        <para>Since 1.7.2 the implementation has been changed and enhanced.
        When the 'fire' method is called, it is passed the following
        arguments:</para>

        <informalexample>
          <programlisting>    fire (String name, String table, Object row1[], Object row2[])
</programlisting>
        </informalexample>

        <para>where 'row1' and 'row2' represent the 'before' and 'after'
        states of the row acted on, with each column being a member of the
        array. The mapping of members of the row arrays to database types is
        specified in <link endterm="sqlsyntax_datatypes-title"
        linkend="sqlsyntax_datatypes-sect" />. For example, BIGINT is
        represented by a <filename>java.lang.Long Object</filename>. Note that
        the number of elements in the row arrays could be larger than the
        number of columns by one or two elements. Never modify the last
        elements of the array, which are not part of the actual row.</para>

        <para>If the trigger method wants to access the database, it must
        establish its own JDBC connection. This can cause data inconsistency
        and other problems so it is not recommended. The
        <literal>jdbc:default:connection:</literal> URL is not currently
        supported.</para>

        <para>Implementation note:</para>

        <para>If QUEUE 0 is specified, the fire method is executed in the same
        thread as the database engine. This allows trigger action to alter the
        data that is about to be stored in the database. Data can be checked
        or modified in BEFORE INSERT / UPDATE + FOR EACH ROW triggers. All
        table constraints are then enforced by the database engine and if
        there is a violation, the action is rejected for the SQL command that
        initiated the INSERT or UPDATE. There is an exception to this rule,
        that is with UPDATE queries, referential integrity and cascading
        actions resulting from ON UPDATE CASCASE / SET NULL / SET DEFAULT are
        all performed prior to the invocation of the trigger method. If an
        invalid value that breaks referential integrity is inserted in the row
        by the trigger method, this action is not checked and results in
        inconsistent data in the table.</para>

        <para>Alternatively, if the trigger is used for external
        communications and not for checking or altering the data, a queue size
        larger than zero can be specified. This is in the interests of not
        blocking the database's main thread as each trigger will run in a
        thread that will wait for its firing event to occur. When this
        happens, the trigger's thread calls TriggerClass.fire. There is a
        queue of events waiting to be run by each trigger thread. This is
        particularly useful for 'FOR EACH ROW' triggers, when a large number
        of trigger events occur in rapid succession, without the trigger
        thread getting a chance to run. If the queue becomes full, subsequent
        additions to it cause the database engine to suspend awaiting space in
        the queue. Take great care to avoid this situation if the trigger
        action involves accessing the database, as deadlock will occur. This
        can be avoided either by ensuring the QUEUE parameter makes a large
        enough queue, or by using the NOWAIT parameter, which causes a new
        trigger event to overwrite the most recent event in the queue. The
        default queue size is 1024. Note also that the timing of trigger
        method calls is not guaranteed, so applications should implement their
        own synchronization measures if necessary.</para>

        <para>With a non-zero QUEUE parameter, if the trigger methods modifies
        the 'row2' values, these changes may or may not affect the database
        and will almost certainly result in data inconsistency.</para>

        <para>Please refer to the code for <link
            xlink:href="../src/org/hsqldb/Trigger.html">
            <classname>org.hsqldb.sample.Trigger</classname>
          </link> and <link
            xlink:href="../src/org/hsqldb/sample/TriggerSample.html">
            <classname>org.hsqldb.sample.TriggerSample</classname>
          </link> for more information on how to write a trigger class.</para>

        <para>See also: <link endterm="drop_trigger-title"
        linkend="drop_trigger-sect" />.</para>
      </section>

      <section xml:id="create_user-sect">
        <title xml:id="create_user-title">CREATE USER</title>

        <programlisting>CREATE USER &lt;username&gt; PASSWORD &lt;password&gt; [ADMIN];</programlisting>

        <para>Creates a new user or new administrator in this database.
        Password must be double quoted. Empty password can be made using "".
        You can change a password afterwards using a <link
        endterm="alter_user-title" linkend="alter_user-sect" />
        command.</para>

        <para>Only an administrator can do this.</para>

        <para>See also: <link endterm="connect-title"
        linkend="connect-sect" />, <link endterm="grant-title"
        linkend="grant-sect" />, <link endterm="revoke-title"
        linkend="revoke-sect" />. <link endterm="alter_user-title"
        linkend="alter_user-sect" />,</para>
      </section>

      <section xml:id="create_view-sect">
        <title xml:id="create_view-title">CREATE VIEW<footnoteref
        linkend="posthyper" /></title>

        <programlisting>CREATE VIEW &lt;viewname&gt;[(&lt;viewcolumn&gt;,..) AS SELECT ... FROM ... [WHERE Expression]
[ORDER BY orderExpression [, ...]]
[LIMIT &lt;limit&gt; [OFFSET &lt;offset&gt;]];</programlisting>

        <para>A view can be thought of as either a virtual table or a stored
        query. The data accessible through a view is not stored in the
        database as a distinct object. What is stored in the database is a
        SELECT statement. The result set of the SELECT statement forms the
        virtual table returned by the view. A user can use this virtual table
        by referencing the view name in SQL statements the same way a table is
        referenced. A view is used to do any or all of these functions:</para>

        <itemizedlist>
          <listitem>
            <para>Restrict a user to specific rows in a table. For example,
            allow an employee to see only the rows recording his or her work
            in a labor-tracking table.</para>
          </listitem>

          <listitem>
            <para>Restrict a user to specific columns. For example, allow
            employees who do not work in payroll to see the name, office, work
            phone, and department columns in an employee table, but do not
            allow them to see any columns with salary information or personal
            information.</para>
          </listitem>

          <listitem>
            <para>Join columns from multiple tables so that they look like a
            single table.</para>
          </listitem>

          <listitem>
            <para>Aggregate information instead of supplying details. For
            example, present the sum of a column, or the maximum or minimum
            value from a column.</para>
          </listitem>
        </itemizedlist>

        <para>Views are created by defining the SELECT statement that
        retrieves the data to be presented by the view. The data tables
        referenced by the SELECT statement are known as the base tables for
        the view. In this example, is a view that selects data from three base
        tables to present a virtual table of commonly needed data:</para>

        <informalexample>
          <programlisting>    CREATE VIEW mealsjv AS
      SELECT m.mid mid, m.name name, t.mealtype mt, a.aid aid,
             a.gname + ' ' + a.sname author, m.description description,
             m.asof asof
        FROM meals m, mealtypes t, authors a
       WHERE m.mealtype = t.mealtype
        AND m.aid = a.aid;</programlisting>
        </informalexample>

        <para>You can then reference mealsjv in statements in the same way you
        would reference a table:</para>

        <informalexample>
          <programlisting>    SELECT * FROM mealsjv;</programlisting>
        </informalexample>

        <para>A view can reference another view. For example, mealsjv presents
        information that is useful for long descriptions that contain
        identifiers, but a short list might be all a web page display needs. A
        view can be built that selects only specific mealsjv columns:</para>

        <informalexample>
          <programlisting>    CREATE VIEW mealswebv AS SELECT name, author FROM mealsjv;</programlisting>
        </informalexample>

        <para>The SELECT statement in a VIEW definition should return columns
        with distinct names. If the names of two columns in the SELECT
        statement are the same, use a column alias to distinguish between
        them. A list of new column names can always be defined for a
        view.</para>

        <informalexample>
          <programlisting>    CREATE VIEW aview (new_name, new_author) AS
      SELECT name, author
      FROM mealsjv</programlisting>
        </informalexample>

        <para>See also: <link endterm="sqlsyntax_expression-title"
        linkend="sqlsyntax_expression-sect" />, <link endterm="select-title"
        linkend="select-sect" />, <link endterm="drop_view-title"
        linkend="drop_view-sect" />.</para>
      </section>

      <section xml:id="delete-sect">
        <title xml:id="delete-title">DELETE</title>

        <programlisting>DELETE FROM table [WHERE Expression];</programlisting>

        <para>Removes rows in a table.</para>

        <para>See also: <link endterm="sqlsyntax_expression-title"
        linkend="sqlsyntax_expression-sect" />, <link endterm="insert-title"
        linkend="insert-sect" />, <link endterm="select-title"
        linkend="select-sect" />.</para>
      </section>

      <section xml:id="disconnect-sect">
        <title xml:id="disconnect-title">DISCONNECT</title>

        <programlisting>DISCONNECT;</programlisting>

        <para>Closes this connection. It is not required to call this command
        when using the JDBC interface: it is called automatically when the
        connection is closed. After disconnecting, it is not possible to
        execute other queries (including CONNECT) with this connection.</para>

        <para>See also: <link endterm="connect-title"
        linkend="connect-sect" />.</para>
      </section>

      <section xml:id="drop_index-sect">
        <title xml:id="drop_index-title">DROP INDEX</title>

        <programlisting>DROP INDEX index [IF EXISTS];</programlisting>

        <para>Removes the specified index from the database. Will not work if
        the index backs a UNIQUE of FOREIGN KEY constraint.</para>

        <para>See also: <link endterm="create_index-title"
        linkend="create_index-sect" />.</para>
      </section>

      <section>
        <title>DROP ROLE<footnoteref linkend="posthyper" /></title>

        <programlisting>DROP ROLE &lt;rolename&gt;;</programlisting>

        <para>Removes all members from specified role, then removes the role
        itself.</para>
      </section>

      <section xml:id="drop_sequence-sect">
        <title xml:id="drop_sequence-title">DROP SEQUENCE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>DROP SEQUENCE &lt;sequencename&gt; [IF EXISTS] [RESTRICT | CASCADE];</programlisting>

        <para>Removes the specified sequence from the database. When IF EXIST
        is used, the statement returns without an error if the sequence does
        not exist. The RESTRICT option is in effect by default, meaning that
        DROP will fail if any view reference the sequence. Specify the
        <literal>CASCADE</literal> option to silently drop all dependent
        database objects.</para>
      </section>

      <section>
        <title>DROP SCHEMA<footnoteref linkend="posthyper" /></title>

        <programlisting>DROP SCHEMA &lt;schemaname&gt; [RESTRICT | CASCADE];</programlisting>

        <para>Removes the specified schema from the database. The RESTRICT
        option is in effect by default, meaning that DROP will fail if any
        objects such as tables or sequences have been defined in the schema.
        Specify the <literal>CASCADE</literal> option to silently drop all
        database objects in the schema.</para>

        <simpara>Requires Administrative privileges.</simpara>
      </section>

      <section xml:id="drop_table-sect">
        <title xml:id="drop_table-title">DROP TABLE</title>

        <programlisting>DROP TABLE &lt;table&gt; [IF EXISTS] [RESTRICT | CASCADE];</programlisting>

        <para>Removes a table, the data and indexes from the database. When IF
        EXIST is used, the statement returns without an error even if the
        table does not exist.</para>

        <para>The RESTRICT option is in effect by default, meaning that DROP
        will fail if any tables or views refer to this table. Specify the
        <literal>CASCADE</literal> option to silently drop all dependent
        views, and to drop any foreign key constraint that links this table
        with other tables.</para>

        <simpara>See also:</simpara>

        <simpara><link endterm="create_table-title"
        linkend="create_table-sect" />.</simpara>
      </section>

      <section xml:id="drop_trigger-sect">
        <title xml:id="drop_trigger-title">DROP TRIGGER</title>

        <programlisting>DROP TRIGGER &lt;trigger&gt;;</programlisting>

        <para>Removes a trigger from the database.</para>

        <para>See also: <link endterm="create_trigger-title"
        linkend="create_trigger-sect" />.</para>
      </section>

      <section xml:id="drop_user-sect">
        <title xml:id="drop_user-title">DROP USER</title>

        <programlisting>DROP USER &lt;username&gt;;</programlisting>

        <para>Removes a user from the database.</para>

        <para>Only an administrator do this.</para>

        <para>See also: <link endterm="create_user-title"
        linkend="create_user-sect" />.</para>
      </section>

      <section xml:id="drop_view-sect">
        <title xml:id="drop_view-title">DROP VIEW<footnoteref
        linkend="posthyper" /></title>

        <programlisting>DROP VIEW &lt;viewname&gt; [IF EXISTS] [RESTRICT | CASCADE];</programlisting>

        <para>Removes a view from the database. When IF EXIST is used, the
        statement returns without an error if the view does not exist. The
        RESTRICT option is in effect by default, meaning that DROP will fail
        if any other view refers to this view. Specify the
        <literal>CASCADE</literal> option to silently drop all dependent
        views.</para>

        <para>See also: <link endterm="create_view-title"
        linkend="create_view-sect" />.</para>
      </section>

      <section xml:id="explain-sect">
        <title xml:id="explain-title">EXPLAIN PLAN</title>

        <programlisting>EXPLAIN PLAN FOR { SELECT ... | DELETE ... | INSERT ... | UPDATE ..};</programlisting>

        <para>EXPLAIN PLAN FOR can be used with any query to get a detailed
        list of the elements in the execution plan.</para>

        <para>This list includes the indexes used for performing the query and
        can be used to optimise the query or to add indexes to tables.</para>
      </section>

      <section xml:id="grant-sect">
        <title xml:id="grant-title">GRANT</title>

        <programlisting>GRANT { SELECT | DELETE | INSERT | UPDATE | ALL } [,...]
ON { table | CLASS "package.class" } TO &lt;grantee&gt;;</programlisting>

        <programlisting>GRANT &lt;rolename&gt; [,...] TO &lt;grantee&gt;<footnoteref
            linkend="posthyper" />;</programlisting>

        <para>&lt;grantee&gt; is either a user name, a role name, or
        <literal>PUBLIC</literal>. <literal>PUBLIC</literal> means
        <emphasis>all users</emphasis>.</para>

        <para>The first form of the GRANT command assigns privileges to a
        grantee for a table or for a class. To allow a user to call a <link
        linkend="sqlsyntax_stored-sect">Store Procedure</link> static
        function, the right ALL must be used. Examples: <informalexample>
            <programlisting>    GRANT SELECT ON Test TO GUEST;
    GRANT ALL ON CLASS "java.lang.Math.abs" TO PUBLIC;</programlisting>
          </informalexample></para>

        <warning>
          <simpara>Even though the command is GRANT ALL ON CLASS, you must
          specify a static <emphasis>method name</emphasis>. You are actually
          granting access to a static method, not to a class.</simpara>
        </warning>

        <para>The second form of the GRANT command gives the specified
        &lt;grantee&gt; membership in the specified role.</para>

        <simpara>Requires Administrative privileges.</simpara>

        <simpara>See also: <link endterm="revoke-title"
        linkend="revoke-sect" />, <link endterm="create_user-title"
        linkend="create_user-sect" />, <link endterm="create_role-title"
        linkend="create_role-sect" />.</simpara>
      </section>

      <section xml:id="insert-sect">
        <title xml:id="insert-title">INSERT</title>

        <programlisting>INSERT INTO table [( column [,...] )]
{ VALUES(<link linkend="sqlsyntax_expression-sect">Expression</link> [,...]) | <link
            linkend="select-sect">SelectStatement</link>};</programlisting>

        <para>Adds one or more new rows of data into a table.</para>
      </section>

      <section xml:id="revoke-sect">
        <title xml:id="revoke-title">REVOKE</title>

        <programlisting>REVOKE { SELECT | DELETE | INSERT | UPDATE | ALL } [,...]
ON { table | CLASS "package.class" } FROM &lt;grantee&gt;;</programlisting>

        <programlisting>REVOKE &lt;rolename&gt; [,...] FROM &lt;grantee&gt;<footnoteref
            linkend="posthyper" />;</programlisting>

        <para>&lt;grantee&gt; is either a user name, a role name, or
        <literal>PUBLIC</literal>. <literal>PUBLIC</literal> means
        <emphasis>all users</emphasis>.</para>

        <para>The first form of the REVOKE command withdraws privileges from a
        grantee for a table or for a class.</para>

        <para>The second form of the REVOKE command withdraws membership of
        the specified &lt;grantee&gt; from the specified role.</para>

        <simpara>Both forms require Administrative privileges.</simpara>

        <simpara>See also: <link endterm="grant-title"
        linkend="grant-sect" />.</simpara>
      </section>

      <section xml:id="rollback-sect">
        <title xml:id="rollback-title">ROLLBACK</title>

        <programlisting>ROLLBACK [TO SAVEPOINT &lt;savepoint name&gt;<footnoteref
            linkend="posthyper" /> |  WORK}];</programlisting>

        <para>ROLLBACK used on its own, or with WORK, undoes changes made
        since the last COMMIT or ROLLBACK.</para>

        <para><literal>ROLLBACK TO SAVEPOINT &lt;savepoint name&gt;</literal>
        undoes the change since the named savepoint. It has no effect if the
        savepoint is not found.</para>

        <para>See also: <link endterm="commit-title"
        linkend="commit-sect" />.</para>
      </section>

      <section xml:id="savepoint-sect">
        <title xml:id="savepoint-title">SAVEPOINT<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SAVEPOINT &lt;savepoint name&gt;;</programlisting>

        <para>Sets up a SAVEPOINT for use with ROLLBACK TO SAVEPOINT.</para>

        <para>See also: <link endterm="commit-title"
        linkend="commit-sect" />.</para>
      </section>

      <section xml:id="script-sect">
        <title xml:id="script-title">SCRIPT</title>

        <programlisting>SCRIPT ['file'];</programlisting>

        <para>Creates an SQL script describing the database. If the file is
        not specified, a result set containing only the DDL script is
        returned. If the file is specified then this file is saved with the
        path relative to the machine where the database engine is
        located.</para>

        <para>Only an administrator may do this.</para>
      </section>

      <section xml:id="select-sect">
        <title xml:id="select-title">SELECT<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SELECT [{LIMIT &lt;offset&gt; &lt;limit&gt; | TOP &lt;limit&gt;}<footnoteref
            linkend="posthyper" />][ALL | DISTINCT]
{ selectExpression | table.* | * } [, ...]
[INTO [CACHED | TEMP  | TEXT]<footnoteref linkend="posthyper" /> newTable]
FROM tableList
[WHERE <link linkend="sqlsyntax_expression-sect">Expression</link>]
[GROUP BY Expression [, ...]]
[HAVING Expression]
[{ UNION [ALL | DISTINCT] | {MINUS [DISTINCT] | EXCEPT [DISTINCT] } |
INTERSECT [DISTINCT] } selectStatement]
[ORDER BY orderExpression [, ...]]
[LIMIT &lt;limit&gt; [OFFSET &lt;offset&gt;]];</programlisting>

        <para>Retrieves information from one or more tables in the
        database.</para>

        <variablelist>
          <title>Components of a SELECT command</title>

          <varlistentry>
            <!-- N.b.!!!!  Put NO whitespace immediately after programlisting
               tags, because the way DocBook formats the itemlist in PDF, we
               have no whitespare to waste to fit the examples in the 
               horizontal space. -->

            <term>tableList</term>

            <listitem>
              <programlisting>table [{CROSS | INNER | LEFT OUTER | RIGHT OUTER}
    JOIN table ON Expression] [, ...]</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>table</term>

            <listitem>
              <programlisting>{ (selectStatement) [AS] label | tableName}</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>selectExpression</term>

            <listitem>
              <programlisting>{ Expression | COUNT(*) | {
    COUNT | MIN | MAX | SUM | AVG | SOME | EVERY |
    VAR_POP | VAR_SAMP | STDDEV_POP | STDDEV_SAMP
} ([ALL | DISTINCT]<footnoteref linkend="posthyper" />] Expression) } [[AS] label]</programlisting>

              <para>If DISTINCT is specified, only one instance of several
              equivalent values is used in the aggregate function. Except
              COUNT(*), all aggregate functions exclude NULL values. The type
              of the returned value for SUM is subject to deterministic
              widening to ensure lossless results. The returned value type for
              COUNT is INTEGER, for MIN, MAX and AVG it is the same type as
              the column, for SOME and EVERY it is BOOLEAN. For VAR_POP,
              VAR_SAMP, STDDEV_POP and STDDEV_SAMP statistical functions, the
              type is always DOUBLE. These statistical functions do not allow
              ALL or DISTINCT qualifiers.</para>

              <para>If CROSS JOIN is specified no ON expression is allowed for
              the join.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>orderExpression</term>

            <listitem>
              <programlisting>{ columnNr | columnAlias | selectExpression }
    [ASC | DESC]</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>LIMIT n m</term>

            <listitem>
              <para>Creates the result set for the SELECT statement first and
              then discards the first n rows (OFFSET) and returns the first m
              rows of the remaining result set (LIMIT). Special cases: LIMIT 0
              m is equivalent to TOP m or FIRST m in other RDBMS's; LIMIT n 0
              discards the first n rows and returns the rest of the result
              set.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>LIMIT m OFFSET n</term>

            <listitem>
              <para>This form is used at the end of the SELECT statement. The
              OFFSET term is optional.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TOP m</term>

            <listitem>
              <para>Equivalent to LIMIT 0 m.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>UNION and other set operations</term>

            <listitem>
              <para>Multiple SELECT statements joined with UNION, EXCEPT and
              INTERSECT are possible. Each SELECT is then treated as a term,
              and the set operation as an operator in an expression. The
              expression is evaluated from left to right but INTERSECT takes
              precedence over the rest of the operators and is applied first.
              You can use parentheses around any number of SELECT statements
              to change the evaluation order.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>See also: <link endterm="insert-title" linkend="insert-sect" />,
        <link endterm="update-title" linkend="update-sect" />, <link
        endterm="delete-title" linkend="delete-sect" />.</para>
      </section>

      <section xml:id="set_autocommit-sect">
        <title xml:id="set_autocommit-title">SET AUTOCOMMIT</title>

        <programlisting>SET AUTOCOMMIT { TRUE | FALSE };</programlisting>

        <para>Switches on or off the connection's auto-commit mode. If
        switched on, then all statements will be committed as individual
        transactions. Otherwise, the statements are grouped into transactions
        that are terminated by either <link
        linkend="commit-sect">COMMIT</link> or <link
        linkend="rollback-sect">ROLLBACK</link>. By default, new connections
        are in auto-commit mode. This command should not be used directly. Use
        the JDBC equivalent method, Connection.setAutoCommit(boolean
        autocommit).</para>
      </section>

      <section xml:id="collation-sect">
        <title xml:id="collation-title">SET DATABASE COLLATION<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET DATABASE COLLATION &lt;double quoted collation name&gt;;</programlisting>

        <para>Each database can have its own collation. Sets the collation
        from the set of collations in the source for
        org.hsqldb.Collation.</para>

        <para>Once this command has been issued, the database can be opened in
        any JVM and will retain its collation.</para>
      </section>

      <section>
        <title>SET CHECKPOINT DEFRAG<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET CHECKPOINT DEFRAG &lt;size&gt;;</programlisting>

        <para>The parameter <literal>size</literal> is the megabytes of
        abandoned space in the .data file. When a CHECKPOINT is performed
        either as a result of the .log file reaching the limit set by "SET
        LOGSIZE size", or by the user issuing a CHECKPOINT command, the amount
        of space abandoned during the session is checked and if it is larger
        than size, a CHECKPOINT DEFRAG is performed instead of a
        checkpoint.</para>
      </section>

      <section xml:id="set_ignorecase-sect">
        <title xml:id="set_ignorecase-title">SET IGNORECASE</title>

        <programlisting>SET IGNORECASE { TRUE | FALSE };</programlisting>

        <para>Disables (ignorecase = true) or enables (ignorecase = false) the
        case sensitivity of text comparison and indexing for new tables. By
        default, character columns in new databases are case sensitive. The
        sensitivity must be switched before creating tables. Existing tables
        and their data are not affected. When switched on, the data type
        VARCHAR is set to <literal>VARCHAR_IGNORECASE</literal> in new tables.
        Alternatively, you can specify the
        <literal>VARCHAR_IGNORECASE</literal> type for the definition of
        individual columns. So it is possible to have some columns case
        sensitive and some not, even in the same table.</para>

        <para>Only an administrator may do this.</para>
      </section>

      <section xml:id="set_initialschema-sect">
        <title xml:id="set_initialschema-title">SET INITIAL SCHEMA
        <footnoteref linkend="posthyper" /></title>

        <para>Users may change their base default schema name with the command
        <programlisting>SET INITIAL SCHEMA &lt;schemaname&gt;;</programlisting>
        This is the schema which database object names will resolve to for the
        current user, unless overridden as explained in <link
        endterm="sqlsyntax_schemanaming-title"
        linkend="sqlsyntax_schemanaming-sect" />. For reasons of backwards
        compatibility, the initial schema value will not be persisted across
        database shutdowns until HSQLDB version 1.8.1. (I.e., INITIAL SCHEMA
        settings will be lost upon database shutdown with HSQLDB versions
        lower than version 1.8.1).</para>
      </section>

      <section xml:id="set_logsize-sect">
        <title xml:id="set_logsize-title">SET LOGSIZE</title>

        <programlisting>SET LOGSIZE &lt;size&gt;;</programlisting>

        <para>Sets the maximum size in MB of the .log file. Default is 200 MB.
        The database will be closed and opened (just like using CHECKPOINT) if
        the .log file gets over this limit, and so the .log file will shrink.
        0 means no limit.</para>

        <para>See also: <link endterm="checkpoint-title"
        linkend="checkpoint-sect" />.</para>
      </section>

      <section>
        <title>SET MAXROWS</title>

        <programlisting>SET MAXROWS &lt;maxwors&gt;;</programlisting>

        <para>Describe me!</para>
      </section>

      <section xml:id="set_password-sect">
        <title xml:id="set_password-title">SET PASSWORD</title>

        <programlisting>SET PASSWORD &lt;password&gt;;</programlisting>

        <para>Changes the password of the currently connected user. Password
        must be double quotedEmpty password can be set using "".</para>
      </section>

      <section xml:id="set_property-sect">
        <title xml:id="set_property-title">SET PROPERTY<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET PROPERTY &lt;double quoted name&gt; &lt;value&gt;;</programlisting>

        <para>Sets a database property. Properties that can be set using this
        command are either boolean or integral and are listed in the <link
        endterm="advanced-title" linkend="advanced-chapt" /> chapter.</para>
      </section>

      <section>
        <title>SET READONLY</title>

        <programlisting>SET READONLY {TRUE|FALSE};</programlisting>

        <para>Describe me!</para>
      </section>

      <section xml:id="set_refint-sect">
        <title xml:id="set_refint-title">SET REFERENTIAL INTEGRITY</title>

        <programlisting>SET REFERENTIAL_INTEGRITY { TRUE | FALSE };</programlisting>

        <para>This commands enables / disables the referential integrity
        checking (foreign keys). Normally it should be switched on (this is
        the default) but when importing data (and the data is imported in the
        'wrong' order) the checking can be switched off.</para>

        <warning>
          <para>Note that when referential integrity is switched back on, no
          check is made that the changes to the data are consistent with the
          existing referential integrity constraints. You can verify
          consistency using SQL queries and take appropriate actions.</para>
        </warning>

        <para>Only an administrator may do this.</para>

        <para>See also: <link endterm="create_table-title"
        linkend="create_table-sect" />.</para>
      </section>

      <section xml:id="set_schema-sect">
        <title xml:id="set_schema-title">SET SCHEMA<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET SCHEMA &lt;schemaname&gt;;</programlisting>

        <para>Sets the current JDBC session's schema. The sole purpose for the
        session schema is to provide a default schema name for schema objects
        that do not have the schema name specified explicitly in the SQL
        command, or by association with another object of known schema. For
        example, if you run <literal>SELECT * FROM atbl;</literal>, HSQLDB
        will look for the table or view named <literal>atbl</literal> in the
        session's current schema.</para>

        <para>Session schemas last only for the duration of the current
        session. When a new JDBC session is obtained, the new session will
        have the default schema.</para>
      </section>

      <section xml:id="set_scriptformat-sect">
        <title xml:id="set_scriptformat-title">SET SCRIPTFORMAT<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET SCRIPTFORMAT {TEXT | BINARY | COMPRESSED};</programlisting>

        <para>Changes the format of the script file. BINARY and COMPRESSED
        formats are slightly faster and more compact than the default TEXT.
        Recommended only for very large script files.</para>
      </section>

      <section xml:id="set_table_index-sect">
        <title xml:id="set_table_index-title">SET TABLE INDEX</title>

        <programlisting>SET TABLE tableName INDEX 'index1rootPos index2rootPos ... ';</programlisting>

        <para>This command is only used internally to store the position of
        index roots in the .data file. It appears only in database script
        files; it should not be used directly.</para>
      </section>

      <section xml:id="set_table_readonly-sect">
        <title xml:id="set_table_readonly-title">SET TABLE
        READONLY<footnoteref linkend="posthyper" /></title>

        <programlisting>SET TABLE &lt;tablename&gt; READONLY {TRUE | FALSE};</programlisting>

        <para>Sets the table as read only.</para>
      </section>

      <section xml:id="set_table_source-sect">
        <title xml:id="set_table_source-title">SET TABLE SOURCE<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET TABLE &lt;tablename&gt; SOURCE &lt;file and options&gt; [DESC];</programlisting>

        <para>For details see the <link endterm="texttables-title"
        linkend="texttables-chapt" /> chapter.</para>

        <para>This command is used exclusively with TEXT tables to specify
        which file is used for storage of the data. The optional DESC
        qualifier results in the text file indexed from the end and opened as
        readonly. The &lt;file and options&gt; argument is a double quoted
        string that consists of:</para>

        <programlisting>    &lt;file and options&gt;::= &lt;doublequote&gt; &lt;filepath&gt;
        [&lt;semicolon&gt; &lt;option&gt;...] &lt;doublequote&gt;</programlisting>

        <para>Example:</para>

        <informalexample>
          <programlisting>    SET TABLE mytable SOURCE "myfile;fs=|;vs=.;lvs=~"</programlisting>
        </informalexample>

        <variablelist>
          <title>Supported Properties</title>

          <varlistentry>
            <term>quoted = { true | false }</term>

            <listitem>
              <para>default is true. If false, treats double quotes as normal
              characters</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>all_quoted = { true | false }</term>

            <listitem>
              <para>default is false. If true, adds double quotes around all
              fields.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>encoding = &lt;encoding name&gt;</term>

            <listitem>
              <para>character encoding for text and character fields, for
              example, encoding=UTF-8</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ignore_first = { true | false }</term>

            <listitem>
              <para>default is false. If true ignores the first line of the
              file</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>cache_scale= &lt;numeric value&gt;</term>

            <listitem>
              <para>exponent to calculate rows of the text file in cache.
              Default is 8, equivalent to nearly 800 rows</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>cache_size_scale = &lt;numeric value&gt;r</term>

            <listitem>
              <para>exponent to calculate average size of each row in cache.
              Default is 8, equivalent to 256 bytes per row.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>fs = &lt;unquoted character&gt;</term>

            <listitem>
              <para>field separator</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>vs = &lt;unquoted character&gt;</term>

            <listitem>
              <para>varchar separator</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>lvs = &lt;unquoted character&gt;</term>

            <listitem>
              <para>long varchar separator</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <variablelist>
          <title>Special indicators for Hsqldb Text Table separators</title>

          <varlistentry>
            <term>\semi</term>

            <listitem>
              <para>semicolon</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\quote</term>

            <listitem>
              <para>quote</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\space</term>

            <listitem>
              <para>space character</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\apos</term>

            <listitem>
              <para>apostrophe</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\n</term>

            <listitem>
              <para>newline - Used as an end anchor (like $ in regular
              expressions)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\r</term>

            <listitem>
              <para>carriage return</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\t</term>

            <listitem>
              <para>tab</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\\</term>

            <listitem>
              <para>backslash</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\u####</term>

            <listitem>
              <para>a Unicode character specified in hexadecimal</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Only an administrator may do this.</para>
      </section>

      <section xml:id="set_write_delay-sect">
        <title xml:id="set_write_delay-title">SET WRITE DELAY<footnoteref
        linkend="posthyper" /></title>

        <programlisting>SET WRITE_DELAY {{ TRUE | FALSE } | &lt;seconds&gt; | &lt;milliseconds&gt; MILLIS};</programlisting>

        <para>This controls the frequency of file sync for the log file. When
        WRITE_DELAY is set to FALSE or 0, the sync takes place immediately at
        each COMMIT. WRITE_DELAY TRUE performs the sync once every 20 seconds
        (which is the default). A numeric value can be specified
        instead.</para>

        <para>The purpose of this command is to control the amount of data
        loss in case of a total system crash. A delay of 1 second means at
        most the data written to disk during the last second before the crash
        is lost. All data written prior to this has been synced and should be
        recoverable.</para>

        <para>A write delay of 0 impacts performance in high load situations,
        as the engine has to wait for the file system to catch up.</para>

        <para>To avoid this, you can set write delay down to 10 milliseconds.
        In practice, a write delay of 100 milliseconds provides better than
        99.9999% reliability with an average one system crash per day, or
        99.99999% with an average one system crash per 6 days.</para>

        <para>Each time a SET WRITE_DELAY is issued with any value, a sync is
        immediately performed.</para>

        <para>Only an administrator may do this.</para>
      </section>

      <section xml:id="shutdown-sect">
        <title xml:id="shutdown-title">SHUTDOWN</title>

        <programlisting>SHUTDOWN [IMMEDIATELY | COMPACT | SCRIPT<footnoteref
            linkend="posthyper" />];</programlisting>

        <para>Closes the current database.</para>

        <variablelist>
          <title>Varieties of the SHUTDOWN command</title>

          <varlistentry>
            <term>SHUTDOWN</term>

            <listitem>
              <para>Performs a checkpoint to creates a new .script file that
              has the minimum size and contains the data for memory tables
              only. It then backs up the .data file containing the CACHED
              TABLE data in a compressed format to the .backup file and closes
              the database.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>SHUTDOWN IMMEDIATELY</term>

            <listitem>
              <para>Just closes the database files (like when the Java process
              for the database is terminated); this command is used in tests
              of the recovery mechanism. This command should not be used as
              the routine method of closing the database.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>SHUTDOWN COMPACT</term>

            <listitem>
              <para>Writes out a new .script file which contains the data for
              all the tables, including CACHED and TEXT tables. It then
              deletes the existing text table files and the .data file before
              rewriting them. After this, it backs up the .data file in the
              same way as normal SHUTDOWN. This operation shrinks all files to
              the minimum size.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>SHUTDOWN SCRIPT</term>

            <listitem>
              <para>Similar to SHUTDOWN COMPACT but after writing the script
              and deleting the existing files, it does not rewrite the .data
              and text table files. After SHUTDOWN SCRIPT, only the .script
              and .properties file remain. At the next startup, these files
              are processed and the .data and .backup files are created. This
              command in effect performs part of the job of SHUTDOWN COMPACT,
              leaving the other part to be performed automatically at the next
              startup.</para>

              <para>This command produces a full script of the database which
              can be edited for special purposes prior to the next
              startup.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <simpara>Only an administrator may use the SHUTDOWN command.</simpara>
      </section>

      <section xml:id="update-sect">
        <title xml:id="update-title">UPDATE</title>

        <programlisting>UPDATE table SET column = Expression [, ...] [WHERE Expression];</programlisting>

        <para>Modifies data of a table in the database.</para>

        <para>See also: <link endterm="select-title" linkend="select-sect" />,
        <link endterm="insert-title" linkend="insert-sect" />, <link
        endterm="delete-title" linkend="delete-sect" />.</para>
      </section>
    </section>

    <section xml:id="sqlsyntax_schemanaming-sect">
      <title xml:id="sqlsyntax_schemanaming-title">Schema object
      naming</title>

      <simpara><emphasis>Schema</emphasis> objects are database objects that
      are always scoped to a specific schema. Each schema has a namespace.
      There may be multiple schema objects of the same name, each in the
      namespace of a different schema. A particular schema object may nearly
      always be uniquely identified using the notation
      <literal>schemaname.objectname</literal>. All HSQLDB database objects
      are schema objects, other than the following.</simpara>

      <itemizedlist>
        <title>HSQLDB Non-Schema Object Types</title>

        <listitem>
          <simpara>Users</simpara>
        </listitem>

        <listitem>
          <simpara>Roles</simpara>
        </listitem>

        <listitem>
          <simpara>Store Procedure Java Classes</simpara>
        </listitem>

        <listitem>
          <simpara>HSQL Aliases</simpara>
        </listitem>
      </itemizedlist>

      <simpara>Our current Java-class-based Triggers are not fully schema
      objects. However, we are in the process of implementing SQL-conformant
      triggers which will encompass our Java-class-based triggers. When this
      work is completed, HSQLDB triggers will be schema objects.</simpara>

      <simpara>Sequences are schema objects with creation and removal
      permission governed by schema authorization (as described hereafter),
      but GRANT and REVOKE command do not work yet for sequences. In a future
      version of HSQLDB, sequence GRANTs and REVOKEs will work similarly to
      the current GRANT and REVOKE commands for table access.</simpara>

      <simpara>Most of the time, you do not need to specify the schema for the
      desired schema object, because the implicit schema is usually the only
      one that can be used. For example, when creating an index, the target
      schema will default to that of the table which is the target of the
      index. Named constraints are an extreme example of this. There is never
      a need to specify a schema name for a constraint, since constraint names
      are only specified in a CREATE or ALTER TABLE command, and the schema
      must be that of the target table. If the implicit schema is not
      determined by a related object, then the default comes from your JDBC
      session's current schema setting. The session schema value will be your
      login user's <emphasis>initial schema</emphasis>, or whatever you last
      set it to with <link endterm="set_schema-title"
      linkend="set_schema-sect" /> in your <emphasis>current</emphasis> JDBC
      session with the SET SCHEMA command. (Your initial schema is "PUBLIC"
      unless changed with the <link linkend="alter_user-sect"> ALTER USER SET
      INITIAL SCHEMA</link> or the <link endterm="set_initialschema-title"
      linkend="set_initialschema-sect" /> command).</simpara>

      <simpara>In addition to namespace scoping, there are permission aspects
      to the schema of a database object. The
      <emphasis>authorization</emphasis> of a schema is a role or user that is
      basically the <emphasis>owner</emphasis> of the schema. Only a user with
      the DBA role (an admin user) or the owner of a schema may create
      objects, or modify the DDL of objects, in the namespace of that schema.
      In this way, a schema authorization is said to "own" the objects of that
      schema. A schema authorization/owner can be a role or a user (even a
      role with no members). The two schemas automatically created when a
      database is initialized are both owned by the role
      <emphasis>DBA</emphasis>.</simpara>

      <simpara>An important implication to database objects being
      <emphasis>owned</emphasis> by the schema owner is, if a non-DBA database
      user is to have permission to create any database object, they must have
      ownership of a schema. To allow a user to create (or modify DDL of)
      objects in their own personal schema, you would create a new schema with
      that user as the authorization. To allow a non-DBA user to share create
      and DDL privileges in some schema, you would create this schema with a
      role as the authorization, then GRANT this role to all of the desired
      users.</simpara>

      <simpara>The INFORMATION_SCHEMA is a system defined schema that contains
      the system tables for the database. This schema is read-only. When a
      database is created, a shema named PUBLIC is automatically created as
      the default schma. This schema has the authorization DBA. You can change
      the name of this schema. If all non-system schemas are dropped from a
      database, an empty PUBLIC schema is created again. So each database
      always has at least one non-system schema.</simpara>
    </section>

    <section xml:id="sqlsyntax_datatypes-sect">
      <title xml:id="sqlsyntax_datatypes-title">Data Types</title>

      <table frame="all" pgwide="1" tocentry="1">
        <title>Data Types. The types on the same line are equivalent.</title>

        <titleabbrev>Data Types</titleabbrev>

        <tgroup align="left" cols="3">
          <thead>
            <row>
              <entry>Name</entry>

              <entry>Range</entry>

              <entry>Java Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>INTEGER | INT</entry>

              <entry>as Java type</entry>

              <entry><literal>int</literal> |
              <classname>java.lang.Integer</classname></entry>
            </row>

            <row>
              <entry>DOUBLE [PRECISION] | FLOAT</entry>

              <entry>as Java type</entry>

              <entry><literal>double</literal> |
              <classname>java.lang.Double</classname></entry>
            </row>

            <row>
              <entry>VARCHAR</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <classname>java.lang.String</classname>
              </entry>
            </row>

            <row>
              <entry>VARCHAR_IGNORECASE</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <classname>java.lang.String</classname>
              </entry>
            </row>

            <row>
              <entry>CHAR | CHARACTER</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <classname>java.lang.String</classname>
              </entry>
            </row>

            <row>
              <entry>LONGVARCHAR</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <classname>java.lang.String</classname>
              </entry>
            </row>

            <row>
              <entry>DATE</entry>

              <entry>as Java type</entry>

              <entry>
                <classname>java.sql.Date</classname>
              </entry>
            </row>

            <row>
              <entry>TIME</entry>

              <entry>as Java type</entry>

              <entry>
                <classname>java.sql.Time</classname>
              </entry>
            </row>

            <row>
              <entry>TIMESTAMP | DATETIME</entry>

              <entry>as Java type</entry>

              <entry>
                <classname>java.sql.Timestamp</classname>
              </entry>
            </row>

            <row>
              <entry>DECIMAL</entry>

              <entry>No limit</entry>

              <entry>
                <classname>java.math.BigDecimal</classname>
              </entry>
            </row>

            <row>
              <entry>NUMERIC</entry>

              <entry>No limit</entry>

              <entry>
                <classname>java.math.BigDecimal</classname>
              </entry>
            </row>

            <row>
              <entry>BOOLEAN | BIT</entry>

              <entry>as Java type</entry>

              <entry><literal>boolean</literal> |
              <classname>java.lang.Boolean</classname></entry>
            </row>

            <row>
              <entry>TINYINT</entry>

              <entry>as Java type</entry>

              <entry><literal>byte</literal> |
              <classname>java.lang.Byte</classname></entry>
            </row>

            <row>
              <entry>SMALLINT</entry>

              <entry>as Java type</entry>

              <entry><literal>short</literal> |
              <classname>java.lang.Short</classname></entry>
            </row>

            <row>
              <entry>BIGINT</entry>

              <entry>as Java type</entry>

              <entry><filename>long</filename> |
              <classname>java.lang.Long</classname></entry>
            </row>

            <row>
              <entry>REAL</entry>

              <entry>as Java type</entry>

              <entry><literal>double</literal> |
              <classname>java.lang.Double</classname><footnoteref
              linkend="posthyper" /></entry>
            </row>

            <row>
              <entry>BINARY</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <literal>byte[]</literal>
              </entry>
            </row>

            <row>
              <entry>VARBINARY</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <literal>byte[]</literal>
              </entry>
            </row>

            <row>
              <entry>LONGVARBINARY</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <literal>byte[]</literal>
              </entry>
            </row>

            <row>
              <entry>OTHER | OBJECT</entry>

              <entry>as Integer.MAXVALUE</entry>

              <entry>
                <classname>java.lang.Object</classname>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The uppercase names are the data types names defined by the SQL
      standard or commonly used by RDMS's. The data types in quotes are the
      Java class names - if these type names are used then they must be
      enclosed in quotes because in Java names are case-sensitive. Range
      indicates the maximum size of the object that can be stored. Where
      Integer.MAXVALUE is stated, this is a theoretical limit and in practice
      the maximum size of a VARCHAR or BINARY object that can be stored is
      dictated by the amount of memory available. In practice, objects of up
      to a megabyte in size have been successfully used in production
      databases.</para>

      <para>The recommended Java mapping for the JDBC datatype FLOAT is as a
      Java type "double". Because of the potential confusion it is recommended
      that DOUBLE is used instead of FLOAT.</para>

      <para>VARCHAR_IGNORECASE is a special case-insensitive type of VARCHAR.
      This type is not portable.</para>

      <para>In table definition statements, HSQLDB accepts size, precision and
      scale qualifiers only for certain types: CHAR(s), VARCHAR(s), DOUBLE(p),
      NUMERIC(p), DECIMAL(p,s) and TIMESTAMP(p).</para>

      <para>TIMESTAMP(p) can take only 0 or 6 as precision. Zero indicates no
      subsecond part. Without the precision, the default is 6.</para>

      <para>By default specified precision and scale for the column is simply
      ignored by the engine. Instead, the values for the corresponding Java
      types are always used, which in the case of DECIMAL is an unlimited
      precision and scale. If a size is specified, it is stored in the
      database definition but is not enforeced by default. Once you have
      created the database (before adding data), you can add a database
      property value to enforce the sizes:</para>

      <programlisting>    SET PROPERTY "sql.enforce_strict_size" true</programlisting>

      <para>This will enforce the specified size and pad CHAR fields with
      spaces to fill the size. This complies with SQL standards by throwing an
      exception if an attempt is made to insert a string longer than the
      maximum size. It also results in all DECIMAL values conforming to the
      specified precision and scale.</para>

      <para>CHAR and VARCHAR and LONGVARCHAR columns are by default compared
      and sorted according to POSIX standards. See the <link
      endterm="collation-title" linkend="collation-sect" /> section above to
      modify this behavior. The property
      <varname>sql.compare_in_locale</varname> is no longer supported.
      Instead, you can define a collation to be used for all character
      comparisons.</para>

      <para>Columns of the type OTHER or OBJECT contain the serialized form of
      a Java Object in binary format. To insert or update such columns, a
      binary format string (see below under Expression) should be used. Using
      PreparedStatements with JDBC automates this transformation.</para>
    </section>

    <section xml:id="sqlsyntax_comments-sect">
      <title>SQL Comments</title>

      <simplelist>
        <member>
          <literal>-- SQL style line comment</literal>
        </member>

        <member>
          <literal>// Java style line comment</literal>
        </member>

        <member>
          <literal>/* C style line comment */</literal>
        </member>
      </simplelist>

      <para>All these types of comments are ignored by the database.</para>
    </section>

    <section xml:id="sqlsyntax_stored-sect">
      <title xml:id="sqlsyntax_stored-title">Stored Procedures /
      Functions</title>

      <para>Stored procedures are static Java functions that are called
      directly from the SQL language or using an alias. Calling Java functions
      (directly or using the alias) requires that the Java class can be
      reached by the database (server). The syntax is:</para>

      <programlisting>    "java.lang.Math.sqrt"(2.0)</programlisting>

      <para>This means the package must be provided, and the name must be
      written as one word, and inside " because otherwise it is converted to
      uppercase (and not found).</para>

      <para>An alias can be created using the command CREATE ALIAS:</para>

      <programlisting>    CREATE ALIAS SQRT FOR "java.lang.Math.sqrt";</programlisting>

      <para>When an alias is defined, then the function can be called
      additionally using this alias:</para>

      <programlisting>    SELECT SQRT(A) , B FROM MYTABLE;</programlisting>

      <para>Only static java methods can be used as stored procedures. If,
      within the same class, there are overloaded methods with the same number
      of arguments, then the first one encountered by the program will be
      used. If you want to use Java library methods, it is recommended that
      you create your own class with static methods that act as wrappers
      around the Java library methods. This will allow you to control which
      method signature is used to call each Java library method.</para>
    </section>

    <section xml:id="sqlsyntax_builtin-sect">
      <title>Built-in Functions and Stored Procedures</title>

      <variablelist>
        <title>Numerical built-in Functions / Stored Procedures</title>

        <varlistentry>
          <term>ABS(d)</term>

          <listitem>
            <para>returns the absolute value of a double value</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ACOS(d)</term>

          <listitem>
            <para>returns the arc cosine of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ASIN(d)</term>

          <listitem>
            <para>returns the arc sine of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ATAN(d)</term>

          <listitem>
            <para>returns the arc tangent of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ATAN2(a,b)</term>

          <listitem>
            <para>returns the tangent of a/b</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>BITAND(a,b)</term>

          <listitem>
            <para>return a &amp; b</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>BITOR(a,b)</term>

          <listitem>
            <para>returns a | b</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CEILING(d)</term>

          <listitem>
            <para>returns the smallest integer that is not less than d</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>COS(d)</term>

          <listitem>
            <para>returns the cosine of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>COT(d)</term>

          <listitem>
            <para>returns the cotangent of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DEGREES(d)</term>

          <listitem>
            <para>converts radians to degrees</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>EXP(d)</term>

          <listitem>
            <para>returns e (2.718...) raised to the power of d</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>FLOOR(d)</term>

          <listitem>
            <para>returns the largest integer that is not greater than
            d</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LOG(d)</term>

          <listitem>
            <para>returns the natural logarithm (base e)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LOG10(d)</term>

          <listitem>
            <para>returns the logarithm (base 10)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>MOD(a,b)</term>

          <listitem>
            <para>returns a modulo b</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>PI()</term>

          <listitem>
            <para>returns pi (3.1415...)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>POWER(a,b)</term>

          <listitem>
            <para>returns a raised to the power of b</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RADIANS(d)</term>

          <listitem>
            <para>converts degrees to radians</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RAND()</term>

          <listitem>
            <para>returns a random number x bigger or equal to 0.0 and smaller
            than 1.0</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ROUND(a,b)</term>

          <listitem>
            <para>rounds a to b digits after the decimal point</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ROUNDMAGIC(d)</term>

          <listitem>
            <para>solves rounding problems such as 3.11-3.1-0.01</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SIGN(d)</term>

          <listitem>
            <para>returns -1 if d is smaller than 0, 0 if d==0 and 1 if d is
            bigger than 0</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SIN(d)</term>

          <listitem>
            <para>returns the sine of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SQRT(d)</term>

          <listitem>
            <para>returns the square root</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TAN(A)</term>

          <listitem>
            <para>returns the trigonometric tangent of an angle</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TRUNCATE(a,b)</term>

          <listitem>
            <para>truncates a to b digits after the decimal point</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <variablelist>
        <title>String built-in Functions / Stored Procedures</title>

        <varlistentry>
          <term>ASCII(s)</term>

          <listitem>
            <para>returns the ASCII code of the leftmost character of s</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>BIT_LENGTH(str)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the length of the string in bits</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CHAR(c)</term>

          <listitem>
            <para>returns a character that has the ASCII code c</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CHAR_LENGTH(str)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the length of the string in characters</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CONCAT(str1,str2)</term>

          <listitem>
            <para>returns str1 + str2</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DIFFERENCE(s1,s2)</term>

          <listitem>
            <para>returns the difference between the sound of s1 and s2</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>HEXTORAW(s1)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns translated string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>INSERT(s,start,len,s2)</term>

          <listitem>
            <para>returns a string where len number of characters beginning at
            start has been replaced by s2</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LCASE(s)</term>

          <listitem>
            <para>converts s to lower case</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LEFT(s,count)</term>

          <listitem>
            <para>returns the leftmost count of characters of s) - requires
            double quoting - use SUBSTRING() instead</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LENGTH(s)</term>

          <listitem>
            <para>returns the number of characters in s</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LOCATE(search,s,[start])</term>

          <listitem>
            <para>returns the first index (1=left, 0=not found) where search
            is found in s, starting at start</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LTRIM(s)</term>

          <listitem>
            <para>removes all leading blanks in s</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>OCTET_LENGTH(str)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the length of the string in bytes (twice the number
            of characters)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RAWTOHEX(s1)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns translated string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>REPEAT(s,count)</term>

          <listitem>
            <para>returns s repeated count times</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>REPLACE(s,replace,s2)</term>

          <listitem>
            <para>replaces all occurrences of replace in s with s2</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RIGHT(s,count)</term>

          <listitem>
            <para>returns the rightmost count of characters of s</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RTRIM(s)</term>

          <listitem>
            <para>removes all trailing spaces</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SOUNDEX(s)</term>

          <listitem>
            <para>returns a four character code representing the sound of
            s</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SPACE(count)</term>

          <listitem>
            <para>returns a string consisting of count spaces</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SUBSTR(s,start[,len])</term>

          <listitem>
            <para>alias for substring</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SUBSTRING(s,start[,len])</term>

          <listitem>
            <para>returns the substring starting at start (1=left) with length
            len</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>UCASE(s)</term>

          <listitem>
            <para>converts s to upper case</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LOWER(s)</term>

          <listitem>
            <para>converts s to lower case</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>UPPER(s)</term>

          <listitem>
            <para>converts s to upper case</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <variablelist>
        <title>Date/Time built-in Functions / Stored Procedures</title>

        <varlistentry>
          <term>CURDATE()</term>

          <listitem>
            <para>returns the current date</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CURTIME()</term>

          <listitem>
            <para>returns the current time</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DATEDIFF(string, datetime1, datetime2)<footnoteref
          linkend="posthyper" /></term>

          <listitem>
            <para>returns the count of units of time elapsed from datetime1 to
            datetime2. The string indicates the unit of time and can have the
            following values 'ms'='millisecond',
            'ss'='second','mi'='minute','hh'='hour', 'dd'='day', 'mm'='month',
            'yy' = 'year'. Both the long and short form of the strings can be
            used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DAYNAME(date)</term>

          <listitem>
            <para>returns the name of the day</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DAYOFMONTH(date)</term>

          <listitem>
            <para>returns the day of the month (1-31)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DAYOFWEEK(date)</term>

          <listitem>
            <para>returns the day of the week (1 means Sunday)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DAYOFYEAR(date)</term>

          <listitem>
            <para>returns the day of the year (1-366)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>HOUR(time)</term>

          <listitem>
            <para>return the hour (0-23)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>MINUTE(time)</term>

          <listitem>
            <para>returns the minute (0-59)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>MONTH(date)</term>

          <listitem>
            <para>returns the month (1-12)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>MONTHNAME(date)</term>

          <listitem>
            <para>returns the name of the month</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>NOW()</term>

          <listitem>
            <para>returns the current date and time as a timestamp) - use
            CURRENT_TIMESTAMP instead</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>QUARTER(date)</term>

          <listitem>
            <para>returns the quarter (1-4)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SECOND(time)</term>

          <listitem>
            <para>returns the second (0-59)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEEK(date)</term>

          <listitem>
            <para>returns the week of this year (1-53)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>YEAR(date)</term>

          <listitem>
            <para>returns the year</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CURRENT_DATE<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the current date</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CURRENT_TIME<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the current time</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CURRENT_TIMESTAMP<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>returns the current timestamp</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <variablelist>
        <title>System/Connection built-in Functions / Stored
        Procedures</title>

        <varlistentry>
          <term>DATABASE()</term>

          <listitem>
            <para>returns the name of the database of this connection</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>USER()</term>

          <listitem>
            <para>returns the user name of this connection</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CURRENT_USER</term>

          <listitem>
            <para>SQL standard function, returns the user name of this
            connection</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>IDENTITY()</term>

          <listitem>
            <para>returns the last identity values that was inserted by this
            connection</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <variablelist>
        <title>System built-in Functions / Stored Procedures</title>

        <varlistentry>
          <term>IFNULL(exp,value)</term>

          <listitem>
            <para>if exp is null, value is returned else exp) - use COALESCE()
            instead</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CASEWHEN(exp,v1,v2)</term>

          <listitem>
            <para>if exp is true, v1 is returned, else v2) - use CASE WHEN
            instead</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CONVERT(term,type)</term>

          <listitem>
            <para>converts exp to another data type</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CAST(term AS type)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>converts exp to another data type</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>COALESCE(expr1,expr2,expr3,...)<footnoteref
          linkend="posthyper" /></term>

          <listitem>
            <para>if expr1 is not null then it is returned else, expr2 is
            evaluated and if not null it is returned and so on</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>NULLIF(v1,v2)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>if v1 equals v2 return null, otherwise v1</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CASE v1 WHEN...<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>CASE v1 WHEN v2 THEN v3 [ELSE v4] END</literal>
            </para>

            <para>when v1 equals v2 return v3 [otherwise v4 or null if there
            is no ELSE]</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CASE WHEN...<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>CASE WHEN expr1 THEN v1[WHEN expr2 THEN v2] [ELSE v4]
              END</literal>
            </para>

            <para>when expr1 is true return v1 [optionally repeated for more
            cases] [otherwise v4 or null if there is no ELSE]</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>EXTRACT<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>EXTRACT ({YEAR | MONTH | DAY | HOUR | MINUTE | SECOND}
              FROM &lt;datetime value&gt;)</literal>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>POSITION (... IN ..)<footnoteref linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>POSITION(&lt;string expression&gt; IN &lt;string
              expression&gt;)</literal>
            </para>

            <para>if the first string is a sub-string of the second one,
            returns the position of the sub-string, counting from one;
            otherwise 0</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SUBSTRING(... FROM ... FOR ...)<footnoteref
          linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>SUBSTRING(&lt;string expression&gt; FROM &lt;numeric
              expression&gt; [FOR &lt;numeric expression&gt;])</literal>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TRIM( LEDING ... FROM ...)<footnoteref
          linkend="posthyper" /></term>

          <listitem>
            <para>
              <literal>TRIM([{LEADING | TRAILING | BOTH}] FROM &lt;string
              expression&gt;)</literal>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>See also: <link endterm="call-title" linkend="call-sect" />, <link
      endterm="create_alias-title" linkend="create_alias-sect" />.</para>
    </section>

    <section xml:id="sqlsyntax_expression-sect">
      <title xml:id="sqlsyntax_expression-title">SQL Expression</title>

      <programlisting>[NOT] condition [{ OR | AND } condition]</programlisting>

      <variablelist>
        <title>Components of SQL Expressions</title>

        <varlistentry>
          <term>condition</term>

          <listitem>
            <programlisting>   { value [|| value]
  | value { = | &lt; | &lt;= | &gt; | &gt;= | &lt;&gt; | != } value
  | value IS [NOT] NULL
  | EXISTS(selectStatement)
  | value BETWEEN value AND value
  | value [NOT] IN ( {value [, ...] | selectStatement } )
  | value [NOT] LIKE value [ESCAPE] value }</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>value</term>

          <listitem>
            <programlisting>   [+ | -] { term [{ + | - | * | / | || } term]
  | ( condition )
  | function ( [parameter] [,...] )
  | selectStatement giving one value
  | {ANY|ALL} (selectStatement giving single column)</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>term</term>

          <listitem>
            <programlisting>   { 'string' | number | floatingpoint
  | [table.]column | TRUE | FALSE | NULL }</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>sequence</term>

          <listitem>
            <programlisting>   NEXT VALUE FOR &lt;sequence&gt;</programlisting>

            <para>HSQLDB does not currently enforce the SQL 200n proposed
            rules on where sequence generated values are allowed to be used.
            In general, these values can be used in insert and update
            statements but not in CASE statements, order by clauses, search
            conditions, aggregate functions, or grouped queries.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>string</term>

          <listitem>
            <para>Strings in HSQLDB are Unicode strings. A string starts and
            ends with a single ' (singlequote). In a string started with '
            (singlequote) use '' (two singlequotes) to create a '
            (singlequote).</para>

            <para>String contatenation should be performed with the standard
            SQL operator || rather than the non-standard + operator.</para>

            <para>The LIKE keyword uses '%' to match any (including 0) number
            of characters, and '_' to match exactly one character. To search
            for '%' or '_' itself an escape character must also be specified
            using the ESCAPE clause. For example, if the backslash is the
            escaping character, '\%' and '\_' can be used to find the '%' and
            '_' characters themselves. For example, SELECT .... LIKE '\_%'
            ESCAPE '\' will find the strings beginning with an
            underscore.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>name</term>

          <listitem>
            <para>The character set for quoted identifiers (names) in HSQLDB
            is Unicode.</para>

            <para>A unquoted identifier (name) starts with a letter and is
            followed by any number of ASCII letters or digits. When an SQL
            statement is issued, any lowercase characters in unquoted
            identifiers are converted to uppercase. Because of this, unquoted
            names are in fact ALL UPPERCASE when used in SQL statements. An
            important implication of this is the for accessing columns names
            via JDBC DatabaseMetaData: the internal form, which is the ALL
            UPPERCASE must be used if the column name was not quoted in the
            CREATE TABLE statement.</para>

            <para>Quoted identifiers can be used as names (for tables,
            columns, constraints or indexes). Quoted identifiers start and end
            with " (one doublequote). A quoted identifier can contain any
            Unicode character, including space. In a quoted identifier use ""
            (two doublequotes) to create a " (one doublequote). With quoted
            identifiers it is possible to create mixed-case table and column
            names. Example:</para>

            <informalexample>
              <programlisting>    CREATE TABLE "Address" ("Nr" INTEGER,"Name" VARCHAR);
    SELECT "Nr", "Name" FROM "Address";</programlisting>
            </informalexample>

            <para>The equivalent quoted identifier can be used for an unquoted
            identifer by converting the identifier to all uppercase and
            quoting it. For example, if a table name is defined as Address2
            (unquoted), it can be referred to by its quoted form, "ADDRESS2",
            as well as address2, aDDress2 and ADDRESS2. Quoted identifiers
            should not be confused with SQL strings.</para>

            <para>Quoting can sometimes be used for identifiers, aliases or
            functions when there is an ambiguity. For example:</para>

            <informalexample>
              <programlisting>    SELECT COUNT(*) "COUNT" FROM MYTABLE;
    SELECT "LEFT"(COL1, 2) FROM MYTABLE;</programlisting>
            </informalexample>

            <para>Although HSQLDB 1.8.0 does not force unquoted identifiers to
            contain only ASCII characters, the use of non-ASCII characters in
            these identifiers does not comply with SQL standards. Portability
            between different JRE locales could be an issue when accented
            characters (or extended unicode characters) are used in unquoted
            identifiers. Because native Java methods are used to convert the
            identifier to uppercase, the result may vary not be expected in
            different locales. It is recommended that accented characters are
            used only in quoted identifiers.</para>

            <para>When using JDBC DatabaseMetaData methods that take table,
            column, or index identifiers as arguments, treat the names as they
            are registered in the database. With these methods, unquoted
            identifiers should be used in all-uppercase to get the correct
            result. Quoted identifiers should be used in the exact case
            combination as they were defined - no quote character should be
            included around the name. JDBC methods that return a result set
            containing such identifiers return unquoted identifiers as
            all-uppercase and quoted identifiers in the exact case they are
            registered in the database (a change from 1.6.1 and previous
            versions).</para>

            <para>Please also note that the JDBC getXXX(String columnName)
            methods interpret the columnName as case-independent. This is a
            general feature of JDBC and not specific to HSQLDB.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>password</term>

          <listitem>
            <para>Passwords must be double quoted and used consistently.
            Passwords are case insensitive only for backward compatibility.
            This may change in future versions.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>values</term>

          <listitem>
            <itemizedlist>
              <listitem>
                <para>A DATE literal starts and ends with ' (singlequote), the
                format is yyyy-mm-dd (see
                <classname>java.sql.Date</classname>.</para>
              </listitem>

              <listitem>
                <para>A TIME literal starts and ends with ' (singlequote), the
                format is hh:mm:ss (see
                <classname>java.sql.Time</classname>).</para>
              </listitem>

              <listitem>
                <para>A TIMESTAMP or DATETIME literal starts and ends with '
                (singlequote), the format is yyyy-mm-dd hh:mm:ss.SSSSSSSSS
                (see <classname>java.sql.Timestamp</classname>).</para>
              </listitem>
            </itemizedlist>

            <para>When specifying default values for date / time columns in
            CREATE TABLE statements, or in SELECT,INSERT, and UPDATE
            statements, special SQL functions: NOW, SYSDATE, TODAY,
            CURRENT_TIMESTAMP, CURRENT_TIME and CURRENT_DATE (case
            independent) can be used. NOW is used for TIME and TIMESTAMP
            columns, TODAY is used for DATE columns. The data and time
            variants CURRENT_* are SQL standard versions and should be used in
            preference to others. Example:</para>

            <programlisting>    CREATE TABLE T(D DATE DEFAULT CURRENT_DATE);
    CREATE TABLE T1(TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);</programlisting>

            <para>Binary data starts and ends with ' (singlequote), the format
            is hexadecimal. '0004ff' for example is 3 bytes, first 0, second 4
            and last 255 (0xff).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Any number of commands may be combined. With combined commands,
      ';' (semicolon) must be used at the end of each command to ensure data
      integrity, despite the fact that the engine may understand the end of
      commands and not return an error when a semicolon is not used.</para>
    </section>
  </chapter>

  <chapter xml:id="builtin_functions-chapt">
    <title>Built In Functions</title>

    <section xml:id="builtin_functions_intro-sect">
      <title>Introduction</title>

      <para>HSQLDB supports a wide range of built-in functions and allows
      user-defined functions written in SQL and Java languages.</para>

      <para>The functions fall into five groups:</para>

      <section>
        <title>SQL Standard Functions</title>

        <para>A wide rang of functions defined by SQL/Foundation are
        supported. SQL/Foundation functions that have no parameter are called
        without empty parentheses. Functions with multiple parameters often
        use keywords instead of commas to separate the parameters. Many
        functions are overloaded. Among these, some have one or more optional
        parameters that can be omitted, while the return type of some
        functions is dependent upon the type of one of the parameters.</para>
      </section>

      <section>
        <title>Open Group CLI Functions</title>

        <para>These functions were defined as an extension to the CLI
        standard, which is the basis for ODBC and JDBC and supported by many
        database products. JDBC supports an escape mechanism to specify
        function calls in SQL statements in a manner that is independent of
        the function names supported by the target database engine. For
        example <literal>SELECT {fn DAYOFMONTH (dateColumn)} FROM
        myTable</literal> can be used in JDBC and is translated to Standard
        SQL as<literal> SELECT EXTRACT (DAY_OF_MONTH FORM dateColumn) FROM
        myTable</literal> if a database engine supports the Standard syntax.
        If a database engine does not support Standard SQL, then the
        translation will be different. HSQLDB supports all the function names
        specified in the JDBC specifications as native functions. Therefore,
        there is no need to use the<literal> {fn FUNC_NAME ( ... ) }
        </literal>escape with HSQLDB. If a JDBC function is supported by the
        SQL Standard in a different form, the SQL Standard form is the
        preferred form to use.</para>
      </section>

      <section>
        <title>HSQLDB built-in functions</title>

        <para>A few additional built-in functions are available for some
        useful operations.</para>
      </section>

      <section>
        <title>User-defined SQL functions</title>

        <para>These functions are written by the user in the SQL language.
        They can call all other available functions and access the data in the
        database. These functions are defined in specific schemas and should
        be prefixed with the schema name when called from other
        schemas.</para>
      </section>

      <section>
        <title>User-defined Java functions</title>

        <para>These functions are written by the user in the Java language as
        public static methods of a class. The types of parameters and the
        return value must be supported types for Java functions. These
        functions are defined in specific schemas and should be prefixed with
        the schema name when called from other schemas.</para>
      </section>

      <section>
        <title>BNF Used In This Chapter</title>

        <para>In the BNF specification used here, words in capital letters are
        actual tokens. Syntactic elements such as expressions are enclosed in
        angle brackets. The <literal>&lt;left paren&gt; </literal>and<literal>
        &lt;right paren&gt; </literal>tokens are represented with the actual
        symbol. Optional elements are enclosed with square brackets (
        <literal>&lt;left bracket&gt; </literal>and<literal> &lt;right
        bracket&gt;</literal> ). Multiple options for a required element are
        enclosed with braces (<literal> &lt;left brace&gt;
        </literal>and<literal> &lt;right brace&gt;</literal> )<literal>.
        </literal>Alternative tokens are separated with the vertical bar (
        <literal>&lt;vertical bar&gt;</literal> ).</para>
      </section>
    </section>

    <section xml:id="builtin_functions_string-sect">
      <title>String and Binary String Functions</title>

      <para>In SQL, there are three kinds of string: character, binary and
      bit. The units are respectively characters, octets, and bits. Each kind
      of string can be in different data types. CHAR, VARCHAR and CLOB are the
      character data types. BINARY, VARBINARY and BLOB are the binary data
      types. BIT and BIT VARYING are the bit string types. In all string
      functions, the position of a unit of the string within the whole string
      is specified from 1 to the length of the whole string. In the BNF,
      <literal>&lt;char value expr&gt; </literal>indicates any valid SQL
      expression that evaluates to a character type. Likewise,
      <literal>&lt;binary value expr&gt; </literal>indicates a binary type
      and<literal> &lt;num value expr&gt; </literal>indicates a numeric
      type.</para>

      <para>
        <literal>ASCII ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns an INTEGER equal to the ASCII code value of the first
      character of <literal>&lt;char value expr&gt;</literal>. (JDBC)</para>

      <para>
        <literal>CHAR ( &lt;UNICODE code&gt; )</literal>
      </para>

      <para>The argument is an INTEGER. Returns a character string containing
      a single character that has the specified<literal> &lt;UNICODE
      code&gt;</literal>, which is an integer. ASCII codes are a subset of the
      allowed values for <literal>&lt;UNICODE code&gt;</literal>.
      (JDBC)</para>

      <para>
        <literal>CONCAT ( &lt;char value expr 1&gt;, &lt;char value expr 2&gt;
        )</literal>
      </para>

      <para>
        <literal>CONCAT ( &lt;binary value expr 1&gt;, &lt;binary value expr
        2&gt; )</literal>
      </para>

      <para>The arguments are character strings or binary strings. Returns a
      string formed by concatenation of the arguments. Equivalent to the SQL
      concatenation expression <literal>&lt;value expr 1&gt; || &lt;value expr
      2&gt;</literal>. (JDBC)</para>

      <para>
        <literal>DIFFERENCE ( &lt;char value expr 1&gt;, &lt;char value expr
        2&gt; )</literal>
      </para>

      <para>The arguments are character strings. Converts the arguments into
      SOUNDEX codes, and returns an INTEGER between 0-3 which indicates how
      many letters of the two SOUNDEX value are different. (JDBC)</para>

      <para>INSERT ( &lt;char value expr 1&gt;, , &lt;offset&gt;,
      &lt;length&gt;, &lt;char value expr 2&gt; )</para>

      <para>Returns a character string based on <literal>&lt;char value expr
      1&gt;</literal> in which <literal>&lt;length&gt;</literal> characters
      have been removed from the<literal>&lt;offset&gt;</literal> position and
      in their place, the whole <literal>&lt;char value expr 2&gt;</literal>
      is copied. Equivalent to SQL/Foundation <literal>OVERLAY( &lt;char value
      expr1&gt; PLACING &lt; char value expr2&gt; FROM &lt;offset&gt; FOR
      &lt;length&gt; )</literal> . (JDBC)</para>

      <para>
        <literal>LCASE ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns a character string that is the lower case version of the
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>LOWER (&lt;char value expr&gt; )</literal> . (JDBC)</para>

      <para>
        <literal>LEFT ( &lt;char value expr&gt;, &lt;length&gt; )</literal>
      </para>

      <para>Returns a character string consisting of the first
      <literal>&lt;length&gt;</literal> characters of <literal>&lt;char value
      expr&gt;</literal>. Equivalent to SQL/Foundation<literal>
      SUBSTRING(&lt;char value expr&gt; FROM 0 FOR &lt;length&gt; )
      </literal>. (JDBC)</para>

      <para>
        <literal>LENGTH ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns as a BIGINT value the number of characters in
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>CHAR_LENGTH(&lt;char value expr&gt;)</literal>. (JDBC)</para>

      <para>
        <literal>LOCATE ( &lt;char value expr 1&gt;, &lt;char value expr 2&gt;
        [ , &lt;offset&gt; ] )</literal>
      </para>

      <para>Returns as a BIGINT value the starting position of the first
      occurrence of <literal>&lt;char value expr 1&gt;</literal> within
      <literal>&lt;char value expr 2&gt;</literal>. If
      <literal>&lt;offset</literal>&gt; is specified, the search begins with
      the position indicated by <literal>&lt;offset&gt;</literal>. If the
      search is not successful, 0 is returned. Equivalent to SQL/Foundation
      <literal>POSITION ( &lt;char value expr 1&gt; IN &lt;char value expr
      2&gt; )</literal>. (JDBC)</para>

      <para>
        <literal>LTRIM ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns a character string based on <literal>&lt;char value
      expr&gt;</literal> with the leading space characters removed. Equivalent
      to SQL/Foundation <literal>TRIM( LEADING ' ' FROM &lt;char value
      expr&gt; )</literal>. (JDBC)</para>

      <para>
        <literal>REPEAT ( &lt;char value expr&gt;, &lt;count&gt; )</literal>
      </para>

      <para>Returns a character string based on<literal> &lt;char value
      expr&gt;</literal>, repeated <literal>&lt;count&gt;</literal> times.
      (JDBC)</para>

      <para>REPLACE ( &lt;char value expr 1&gt;, &lt;char value expr 2&gt;,
      &lt;char value expr 3&gt; )</para>

      <para>Returns a character string based on <literal>&lt;char value expr
      1&gt;</literal> where each occurrence of <literal>&lt;char value expr
      2&gt;</literal> has been replaced with a copy of <literal>&lt;char value
      expr 3&gt;</literal>. (JDBC)</para>

      <para>
        <literal>RIGHT ( &lt;char value expr&gt;, &lt;count&gt; )</literal>
      </para>

      <para>Returns a character string consisting of the last
      <literal>&lt;count&gt;</literal> characters of <literal>&lt;char value
      expr&gt;</literal>. (JDBC)</para>

      <para>
        <literal>RTRIM ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns a character string based on <literal>&lt;char value
      expr&gt;</literal> with the trailing space characters removed.
      Equivalent to SQL/Foundation <literal>TRIM(TRAILING ' ' FROM
      &lt;character string&gt;</literal>. (JDBC)</para>

      <para>
        <literal>SOUNDEX ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns a four character code representing the sound of
      <literal>&lt;char value expr&gt;</literal>. The US census algorithm is
      used. For example the soundex value for Washington is W252.
      (JDBC)</para>

      <para>
        <literal>SPACE ( &lt;count&gt; )</literal>
      </para>

      <para>Returns a character string consisting of <literal>&lt;count&gt;
      </literal>spaces. (JDBC)</para>

      <para>{ SUBSTR | SUBSTRING } ( &lt;char value expr&gt;, &lt;offset&gt;,
      &lt;length&gt; )</para>

      <para>The JDBC version of SQL/Foundation <literal>SUBSTRING</literal>
      returns a character string that consists of
      <literal>&lt;length&gt;</literal> characters from <literal>&lt;char
      value expr&gt; </literal>starting at the
      <literal>&lt;offset&gt;</literal> position. (JDBC)</para>

      <para>
        <literal>UCASE ( &lt;char value expr&gt; )</literal>
      </para>

      <para>Returns a character string that is the lower case version of the
      <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
      <literal>UPPER( &lt;char value expr&gt; )</literal> . (JDBC)</para>

      <para>
        <literal>{ CHAR_LENGTH | CHARACTER_LENGTH } ( &lt;char value
        expression&gt; [ USING { CHARACTERS | OCTETS } ] )</literal>
      </para>

      <para>
        <literal>OCTET_LENGTH ( &lt;string value expression&gt; )</literal>
      </para>

      <para>
        <literal>BIT_LENGTH ( &lt;string value expression&gt; )</literal>
      </para>

      <para>The CHAR_LENGTH or CHARACTER_LENGTH function can be used with
      character strings, while OCTET_LENGTH can be used with character or
      binary strings and BIT_LENGTH can be used with character, binary and bit
      strings.</para>

      <para>All functions return a BIGINT value that measures the length of
      the string in the given unit. CHAR_LENGTH counts characters,
      OCTET_LENGTH counts octets and BIT_LENGTH counts bits in the string. For
      CHAR_LENGTH, if <literal>[ USING OCTETS ] </literal>is specified, the
      octet count is returned. (Foundation)</para>

      <para>
        <literal>OVERLAY ( &lt;char value expr 1&gt; PLACING &lt;char value
        expr 2&gt;</literal>
      </para>

      <para>
        <literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ] [
        USING CHARACTERS ] )</literal>
      </para>

      <para>
        <literal>OVERLAY ( &lt;binary value expr 1&gt; PLACING &lt;binary
        value expr 2&gt;</literal>
      </para>

      <para>
        <literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ]
        )</literal>
      </para>

      <para>The character version of OVERLAY returns a character string based
      on <literal>&lt;char value expr 1&gt;</literal> in which
      <literal>&lt;string length&gt;</literal> characters have been removed
      from the <literal>&lt;start position&gt;</literal> and in their place,
      the whole <literal>&lt;char value expr 2&gt;</literal> is copied.</para>

      <para>The binary version of OVERLAY returns a binary string formed in
      the same manner as the character version. (Foundation)</para>

      <para>
        <literal>POSITION ( &lt;char value expr 1&gt; IN &lt;char value expr
        2&gt; [ USING CHARACTERS ] )</literal>
      </para>

      <para>
        <literal>POSITION ( &lt;binary value expr 1&gt; IN &lt;binary value
        expr 2&gt; )</literal>
      </para>

      <para>The character and binary versions of POSITION search the string
      value of the second argument for the first occurrence of the first
      argument string. If the search is successful, the position in the string
      is returned as a BIGINT. Otherwise zero is returned.</para>

      <para>
        <literal>SUBSTRING ( &lt;char value expr&gt; FROM &lt;start
        position&gt; [ FOR &lt;string length&gt; ] [ USING CHARACTERS ]
        )</literal>
      </para>

      <para>
        <literal>SUBSTRING ( &lt;binary value expr&gt; FROM &lt;start
        position&gt; [ FOR &lt;string length&gt; ] )</literal>
      </para>

      <para>The character version of SUBSTRING returns a character string that
      consists of the characters of the <literal>&lt;char value expr&gt;
      </literal>from <literal>&lt;start position&gt;</literal>. If the
      optional<literal> &lt;string length&gt;</literal> is specified, only
      <literal>&lt;string length&gt; </literal>characters are returned.</para>

      <para>The binary version of SUBSTRING returns a binary string in the
      same manner. (Foundation)</para>

      <para>
        <literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim
        character&gt; ] FROM ] &lt;char value expr&gt; )</literal>
      </para>

      <para>
        <literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim octet&gt; ]
        FROM ] &lt;binary value expr&gt; )</literal>
      </para>

      <para>The character version of TRIM returns a character string based on
      <literal>&lt;char value expr&gt;</literal>. Consecutive instances of
      <literal>&lt;trim character&gt; </literal>are removed from the
      beginning, the end or both ends of the<literal>&lt;char value expr&gt;
      </literal>depending on the value of the optional first
      qualifier<literal>[ LEADING | TRAILING | BOTH ]</literal>. If no
      qualifier is specified,<literal>BOTH </literal>is used as default. If
      <literal>[ &lt;trim character&gt; ]</literal> is not specified, the
      space character is used as default.</para>

      <para>The binary version of TRIM returns a binary string based on
      <literal>&lt;binary value expr&gt;</literal>. Consecutive instances of
      <literal>&lt;trim octet&gt; </literal>are removed in the same manner as
      in the character version. If<literal> [ &lt;trim octet&gt; ]</literal>
      is not specified, the 0 octet is used as default. (Foundation)</para>
    </section>

    <section xml:id="builtin_functions_numeric-sect">
      <title>Numeric Functions</title>

      <para>
        <literal>ABS ( &lt;num value expr&gt; | &lt;interval value expr&gt;
        )</literal>
      </para>

      <para>Returns the absolute value of the argument as a value of the same
      type. (JDBC and Foundation)</para>

      <para>
        <literal>ACOS ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the arc-cosine of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para>
        <literal>ASIN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the arc-sine of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para>
        <literal>ATAN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the arc-tangent of the argument in radians as a value of
      DOUBLE type. (JDBC)</para>

      <para>
        <literal>ATAN2 ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
        )</literal>
      </para>

      <para>The <literal>&lt;num value expr1&gt;</literal> and
      <literal>&lt;num value expr2&gt;</literal> express the
      <varname>x</varname> and <varname>y</varname> coordinates of a point.
      Returns the angle, in radians, representing the angle coordinate of the
      point in polar coordinates, as a value of DOUBLE type. (JDBC)</para>

      <para>
        <literal>{ CEIL | CEILING } ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the smallest integer greater than or equal to the
      argument. If the argument is exact numeric then the result is exact
      numeric with a scale of 0. If the argument is approximate numeric, then
      the result is of DOUBLE type. (JDBC and Foundation)</para>

      <para>
        <literal>COS ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the cosine of the argument (an angle expressed in radians)
      as a value of DOUBLE type. (JDBC)</para>

      <para>
        <literal>COT ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the cotangent of the argument as a value of DOUBLE type.
      The <literal>&lt;num value expr&gt;</literal> represents an angle
      expressed in radians. (JDBC)</para>

      <para>
        <literal>DEGREES ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Converts the argument (an angle expressed in
      <literal>radians</literal>) into degrees and returns the value in the
      DOUBLE type. (JDBC)</para>

      <para>
        <literal>EXP ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the exponential value of the argument as a value of DOUBLE
      type. (JDBC and Foundation)</para>

      <para>
        <literal>FLOOR ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the largest integer that is less than or equal to the
      argument. If the argument is exact numeric then the result is exact
      numeric with a scale of 0. If the argument is approximate numeric, then
      the result is of DOUBLE type. (JDBC and Foundation)</para>

      <para>
        <literal>LN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the natural logarithm of the argument, as a value of
      DOUBLE type. (Foundation)</para>

      <para>
        <literal>LOG ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the natural logarithm of the argument, as a value of
      DOUBLE type. (JDBC)</para>

      <para>
        <literal>LOG10 ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the base 10 logarithm of the argument as a value of DOUBLE
      type. (JDBC)</para>

      <para>
        <literal>MOD ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
        )</literal>
      </para>

      <para>Returns the remainder (modulus) of <literal>&lt;num value expr
      1&gt;</literal> divided by <literal>&lt;num value expr 2&gt;.</literal>
      The data type of the returned value is the same as the second argument.
      (JDBC and Foundation)</para>

      <para>
        <literal>PI ()</literal>
      </para>

      <para>Returns the constant pi as a value of DOUBLE type. (JDBC)</para>

      <para>
        <literal>POWER ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
        )</literal>
      </para>

      <para>Returns the value of <literal>&lt;num value expr 1&gt;</literal>
      raised to the power of <literal>&lt;int value expr 2&gt;</literal> as a
      value of DOUBLE type. (JDBC and Foundation)</para>

      <para>
        <literal>RADIANS ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Converts the argument (an angle expressed in<literal>
      degrees</literal>) into radians and returns the value in the DOUBLE
      type. (JDBC)</para>

      <para>
        <literal>RAND ( [ &lt;int value expr&gt; ] )</literal>
      </para>

      <para>Returns a random value in the DOUBLE type. The optional <literal>[
      &lt;int value expr&gt; ]</literal> is used as seed value. In HSQLDB each
      session has a separate random number generator. (JDBC)</para>

      <para>
        <literal>ROUND ( &lt;num value expr&gt;, &lt;int value expr&gt;
        )</literal>
      </para>

      <para>The <literal>&lt;num value expr&gt; </literal>is of the DOUBLE
      type. The function returns a DOUBLE value which is the value of the
      argument rounded to <literal>&lt;int value expr&gt;</literal> places
      right of the decimal point. If <literal>&lt;int value expr&gt;</literal>
      is negative, the first argument is rounded to <literal>&lt;int value
      expr&gt;</literal> places to the left of the decimal point.
      (JDBC)</para>

      <para>
        <literal>SIGN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns an INTEGER, indicating the sign of the argument. If the
      argument is negative then -1 is returned. If it is equal to zero then 0
      is returned. If the argument is positive then 1 is returned.
      (JDBC)</para>

      <para>
        <literal>SIN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the sine of the argument (an angle expressed in radians)
      as a value of DOUBLE type. (JDBC)</para>

      <para>
        <literal>SQRT ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the square root of the argument as a value of DOUBLE type.
      (JDBC and Foundation)</para>

      <para>
        <literal>TAN ( &lt;num value expr&gt; )</literal>
      </para>

      <para>Returns the tangent of the argument (an angle expressed in
      radians) as a value of DOUBLE type. (JDBC)</para>

      <para>
        <literal>TRUNCATE ( &lt;num value expr&gt;, &lt;int value expr&gt;
        )</literal>
      </para>

      <para>Returns a value in the same type as <literal>&lt;num value
      expr&gt;</literal>. The value is rounded by replacing digits with zeros
      from <literal>&lt;int value expr&gt;</literal> places right of the
      decimal point to the end. If <literal>&lt;int value expr&gt;</literal>
      is negative, <literal>ABS( &lt;int value expr&gt; )</literal> digits to
      left of the decimal point and all digits to the right of the decimal
      points are replaced with zeros. Results of calling TRUNCATE with
      12345.6789 with (-2, 0, 2, 4) are (12300.0000, 12345.0000, 12345.6700,
      12345.6789). (JDBC)</para>
    </section>

    <section xml:id="builtin_functions_datetime-sect">
      <title>Date Time and Interval Functions</title>

      <para>
        <literal>EXTRACT ( &lt;extract field&gt; FROM &lt;extract source&gt;
        )</literal>
      </para>

      <para>
        <literal>&lt;extract field&gt; ::= YEAR | MONTH | DAY | HOUR | MINUTE
        | DAY_OF_WEEK | WEEK_OF_YEAR | QUARTER | DAY_OF_YEAR | DAY_OF_MONTH
        |</literal>
      </para>

      <para>
        <literal>TIMEZONE_HOUR | TIMEZONE_MINUTE | SECOND | SECONDS_MIDNIGHT
        |</literal>
      </para>

      <para>DAY_NAME | MONTH_NAME</para>

      <para>
        <literal>&lt;extract source&gt; ::= &lt;datatime value expr&gt; |
        &lt;interval value expr&gt;</literal>
      </para>

      <para>The EXTRACT function returns a field or element of the
      <literal>&lt;extract source&gt;</literal>. The <literal>&lt;extract
      source&gt;</literal> is a datetime or interval expression. The type of
      the return value is BIGINT for most of the<literal> &lt;extract
      field&gt;</literal> options, except for <literal>SECOND </literal>where
      a DECIMAL value is returned and <literal>DAY_NAME </literal>or<literal>
      MONTH_NAME </literal>where a character string is returned. When
      <literal>MONTH_NAME</literal> is specified, a string in the range
      January - December is returned. When <literal>DAY_NAME </literal>is
      specified, a string in the range Sunday -Saturday is returned.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      </literal><literal /><literal>&lt;datatime value expr&gt;</literal>,
      different groups of <literal>&lt;extract source&gt;</literal> can be
      used depending on the data type of the expression. The
      <literal>TIMEZONE_HOUR | TIMEZONE_MINUTE</literal> options are valid
      only for TIME WITH TIMEZONE and TIMESTAMP WITH TIMEZONE data types. The
      <literal>HOUR | MINUTE | SECOND</literal>
      |<literal>SECONDS_MIDNIGHT</literal> options, are valid for TIME and
      TIMESTAMP types. The rest of the fields are valid for DATE and TIMESTAMP
      types.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      &lt;interval value expr&gt;</literal>, the <literal>&lt;extract
      field&gt;</literal> must be one of the fields of the INTERVAL type of
      the expressions. The <literal>YEAR | MONTH</literal> options may be
      valid for INTERVAL types based on months. The <literal>DAY | HOUR |
      MINUTE | SECOND</literal> | <literal>SECONDS_MIDNIGHT</literal> options
      may be valid for INTERVAL types based on seconds. For example,<literal>
      DAY | HOUR | MINUTE</literal> are the only valid fields for the INTERVAL
      DAY TO MINUTE data type. (Foundation with HSQLDB extensions)</para>

      <para>
        <literal>CURRENT_DATE</literal>
      </para>

      <para>
        <literal>CURRENT_TIME [ ( &lt;time precision&gt; ) ]</literal>
      </para>

      <para>
        <literal>LOCALTIME [ ( &lt;time precision&gt; ) ]</literal>
      </para>

      <para>
        <literal>CURRENT_TIMESTAMP [ ( &lt;timestamp precision&gt; )
        ]</literal>
      </para>

      <para>
        <literal>LOCALTIMESTAMP [ ( &lt;timestamp precision&gt; ) ]</literal>
      </para>

      <para>These datetime functions return the datetime value representing
      the moment the function is called. CURRENT_DATE returns a value of DATE
      type. CURRENT_TIME returns a value of TIME WITH TIME ZONE type.
      LOCALTIME returns a value of TIME type. CURRENT_TIMESTAMP returns a
      value of TIMESTAMP WITH TIME ZONE type. LOCALTIMESTAMP returns a value
      of TIMESTAMP type. If the optional <literal>[ ( &lt;time precision&gt; )
      ]</literal> or<literal> [ ( &lt;timestamp precision&gt; ) ]</literal> is
      used, then the returned value has the specified fraction of the second
      precision. (Foundation)</para>

      <para>
        <literal>CURDATE ()</literal>
      </para>

      <para>This function is equivalent to<literal> CURRENT_DATE.
      </literal>(JDBC)<literal /></para>

      <para>
        <literal>CURTIME ()</literal>
      </para>

      <para>This function is equivalent to<literal> LOCALTIME</literal>.
      (JDBC)</para>

      <para>
        <literal>DAYNAME ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_NAME FROM
      ... ) </literal>Returns a string in the range of Sunday - Saturday.
      (JDBC)</para>

      <para>
        <literal>DAYOFMONTH ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_OF_MONTH
      FROM ... ) </literal>Returns an integer value in the range of 1-31.
      (JDBC)</para>

      <para>
        <literal>DAYOFWEEK ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_WEEK FROM
      ... ) </literal>Returns an integer value in the range of 1-7. The first
      day of the week is Sunday. (JDBC)</para>

      <para>
        <literal>DAYOFYEAR ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_YEAR FROM
      ... ) </literal>Returns an integer value in the range of 1-366.
      (JDBC)</para>

      <para>
        <literal>HOUR ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( HOUR FROM ... )
      </literal>Returns an integer value in the range of 0-23. (JDBC)</para>

      <para>
        <literal>MINUTE ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to<literal> EXTRACT ( MINUTE FROM ...
      ) </literal>Returns an integer value in the range of 0 - 59.
      (JDBC)</para>

      <para>
        <literal>MONTH ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( MONTH FROM ... )
      </literal>Returns an integer value in the range of 1-12. (JDBC)</para>

      <para>
        <literal>MONTHNAME ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( NAME_OF_MONTH
      FROM ... ) </literal>Returns a string in the range of January -
      December. (JDBC)</para>

      <para>
        <literal>NOW ()</literal>
      </para>

      <para>This function is equivalent to
      <literal>LOCAL_TIMESTAMP.</literal></para>

      <para>
        <literal>QUARTER ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( QUARTER FROM ...
      ) </literal>Returns an integer in the range of 1 - 4. (JDBC)</para>

      <para>
        <literal>SECOND ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equivalent to <literal>EXTRACT ( SECOND FROM ...
      ) </literal>Returns an integer in the range of 0 - 59. (JDBC)</para>

      <para>
        <literal>SECONDS_SINCE_MIDNIGHT ( &lt;datatime value expr&gt;
        )</literal>
      </para>

      <para>This function is equvalent to<literal> EXTRACT (
      SECONDS_SINCE_MIDNIGHT FROM ... ) </literal>Returns an integer in the
      range of 0 - 86399. (HSQLDB)</para>

      <para>
        <literal>WEEK ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equvalent to<literal> EXTRACT ( WEEK_OF_YEAR FROM
      ... ) </literal>Returns an integer in the range of 1 - 54. (JDBC)</para>

      <para>
        <literal>YEAR ( &lt;datatime value expr&gt; )</literal>
      </para>

      <para>This function is equvalent to<literal> EXTRACT ( YEAR FROM ... )
      </literal>Returns an integer in the range of 1 - 9999. (JDBC)</para>

      <para>
        <literal>TIMESTAMPADD ( &lt;datetime value expr&gt;, &lt;numeric value
        expression&gt;, &lt;tsi datetime field&gt; )</literal>
      </para>

      <para>
        <literal>TIMESTAMPDIFF ( &lt;datetime value expr 1&gt;, datetime value
        expr 2&gt;, &lt;tsi datetime field&gt; )</literal>
      </para>

      <para>
        <literal>&lt;tsi datetime field&gt; ::= SQL_TSI_FRAC_SECOND |
        SQL_TSI_SECOND | SQL_TSI_MINUTE | SQL_TSI_HOUR | SQL_TSI_DAY |
        SQL_TSI_WEEK | SQL_TSI_MONTH | SQL_TSI_QUARTER |
        SQL_TSI_YEAR</literal>
      </para>

      <para>HSQLDB supports full SQL Standard dateteime features. It supports
      adding integers representing units of time directly to datetime values
      using the arithmetic plus operator. It also supports subtracting one
      <literal>&lt;datetime value expr&gt;</literal> from another in the given
      units of days using the minus operator. An example of
      <literal>&lt;datetime value expr&gt; + &lt;numeric value expression&gt;
      &lt;datetime field&gt; </literal>is <literal>LOCAL_TIMESTAMP + 5
      DAY</literal>. An example of <literal>( &lt;datetime value expr&gt; -
      &lt;numeric value expression&gt; ) &lt;datetime field&gt; </literal>is
      (<literal>CURRENT_DATE - DATE '2008-08-8') MONTH </literal>which returns
      the number of calendar months between the two dates.</para>

      <para>The two JDBC functions, <literal>TIMESTAMPADD </literal>and
      <literal>TIMESTAMPDIFF</literal> perform the same function as above SQL
      expressions. The field names are different from those used in the
      EXTRACT functions. These names are valid for use only when calling these
      two functions. The return value for TIMESTAMPADD is of the same type as
      the datetime argument used. The return type for TIMESTAMPDIFF is always
      BIGINT, regardless of the type of arguments. The two datetime arguments
      of TIMESTAMPDIFF should be of the same type. (JDBC)</para>

      <para>
        <literal>DATEDIFF ( &lt;datetime value expr 1&gt;, datetime value expr
        2&gt;, &lt;field&gt; )</literal>
      </para>

      <para>
        <literal>&lt;field&gt; ::= 'yy' | 'mm' | 'dd' | 'hh' | 'mi' | 'ss' |
        'ms'</literal>
      </para>

      <para>The DATEDIFF function is an alternative to TIMESTAMPDIFF, with
      fewer available field options. The fields translate to YEAR, MONTH, DAY,
      HOUR, MINUTE, SECOND and MILLISECOND. (HSQLDB}</para>

      <para>
        <literal>TO_CHAR( &lt;datetime value expr&gt;, &lt;char value expr&gt;
        )</literal>
      </para>

      <para>This function formats a datetime or numeric value to the format
      specified by the pattern given in the second argument. The pattern can
      contain pattern elements from the list given below, plus punctuation and
      space characters. An example, including the result, is given
      below:</para>

      <para>
        <literal>TO_CHAR ( TIMESTAMP'2008-02-01 20:30:40', 'YYYY BC MONTH, DAY
        HH')</literal>
      </para>

      <para>
        <literal>2008 AD February, Friday 8</literal>
      </para>

      <para>The format is internally translated to a
      java.text.SimpleDateFormat format string. Any character sequences not
      listed below are included in the Java format string and may cause
      unexpected results or errors. The supported format components are as
      follows:</para>

      <table>
        <title>BC / AD Values</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>
                <literal>BC | B.C. | AD | A.D.</literal>
              </entry>

              <entry>Returns <literal>AD</literal> for common era and
              <literal>BC</literal> for before common era</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>
                <literal>RRRR</literal>
              </entry>

              <entry>
                <literal>4-digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>YYYY</literal>
              </entry>

              <entry>
                <literal>4-digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>IYYY</literal>
              </entry>

              <entry>
                <literal>4-digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>YY</literal>
              </entry>

              <entry>
                <literal>2 digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>IY</literal>
              </entry>

              <entry>
                <literal>2 digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>IYYY</literal>
              </entry>

              <entry>
                <literal>4-digit year</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>MM</literal>
              </entry>

              <entry>
                <literal>Month (01-12)</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>MON</literal>
              </entry>

              <entry>
                <literal>Short three-letter name of month</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>MONTH</literal>
              </entry>

              <entry>
                <literal>Name of month</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>WW</literal>
              </entry>

              <entry>
                <literal>Week of year (1-53) where week 1 starts on the first
                day of the year and continues to the seventh day of the
                year.</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>W</literal>
              </entry>

              <entry>
                <literal>Week of month (1-5) where week 1 starts on the first
                day of the month and ends on the seventh.</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>IW</literal>
              </entry>

              <entry>
                <literal>Week of year (1-52 or 1-53) based on the ISO
                standard.</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>DAY</literal>
              </entry>

              <entry>
                <literal>Name of day.</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>DD</literal>
              </entry>

              <entry>
                <literal>Day of month (1-31).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>DDD</literal>
              </entry>

              <entry>
                <literal>Day of year (1-366).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>DY</literal>
              </entry>

              <entry>
                <literal>Short three-letter</literal>

                <literal>name of day.</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>HH</literal>
              </entry>

              <entry>
                <literal>Hour of day (0-11).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>HH12</literal>
              </entry>

              <entry>
                <literal>Hour of day (0-11).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>HH24</literal>
              </entry>

              <entry>
                <literal>Hour of day (0-23).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>MI</literal>
              </entry>

              <entry>
                <literal>Minute (0-59).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>SS</literal>
              </entry>

              <entry>
                <literal>Second (0-59).</literal>
              </entry>
            </row>

            <row>
              <entry>
                <literal>FF</literal>
              </entry>

              <entry>
                <literal>Fractional seconds.</literal>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="builtin_functions_sysfunc-sect">
      <title>System Functions</title>

      <para>
        <literal>DATABASE ()</literal>
      </para>

      <para>Returns the file name (without directory information) of the
      database. (JDBC)</para>

      <para>
        <literal>IFNULL( &lt;value expr1&gt;, &lt;value expr2&gt; )</literal>
      </para>

      <para>Returns <literal>&lt;value expr1&gt;</literal> if it is not null,
      otherwise returns <literal>&lt;value expr2&gt;</literal>. The type of
      both arguments must be the same. Equivalent to SQL Standard
      <literal>COALESCE( &lt;value expr1&gt;, &lt;value expr2&gt; )</literal>
      function . (JDBC)</para>

      <para>
        <literal>USER ()</literal>
      </para>

      <para>Equivalent to the SQL function <literal>CURRENT_USER</literal>.
      (JDBC)</para>

      <para>
        <literal>CONVERT ( &lt;value expr&gt; , &lt;data type&gt; )</literal>
      </para>

      <para>
        <literal>&lt;data type&gt; ::= { SQL_BIGINT | SQL_BINARY | SQL_BIT
        |SQL_BLOB | SQL_BOOLEAN | SQL_CHAR | SQL_CLOB | SQL_DATE | SQL_DECIMAL
        | SQL_DATALINK |SQL_DOUBLE | SQL_FLOAT | SQL_INTEGER |
        SQL_LONGVARBINARY | SQL_LONGNVARCHAR | SQL_LONGVARCHAR | SQL_NCHAR |
        SQL_NCLOB | SQL_NUMERIC | SQL_NVARCHAR | SQL_REAL | SQL_ROWID |
        SQL_SQLXML | SQL_SMALLINT | SQL_TIME | SQL_TIMESTAMP | SQL_TINYINT |
        SQL_VARBINARY | SQL_VARCHAR} [ ( &lt;precision, length or scale
        parameters&gt; ) ]</literal>
      </para>

      <para>The CONVERT function is a JDBC escape function, equivalent to the
      SQL standard CAST expression. It converts the <literal>&lt;value
      expr&gt;</literal> into the given <literal>&lt;data type&gt;</literal>
      and returns the value. The <literal>&lt;data type&gt;</literal> options
      are synthetic names made by prefixing type names with SQL_. Some of the
      <literal>&lt;data type&gt;</literal> options represent valid SQL types,
      but some are are based on non-standard type names, namely <literal>{
      SQL_LONGNVARCHAR | SQL_LONGVARBINARY |SQL_LONGNVARCHAR | SQL_TINYINT
      }</literal>. None of the synthetic names can be used in any other
      context than the CONVERT function.</para>

      <para>The definition of CONVERT in the JDBC Standard does not allow the
      precision, scale or length to be specified. This is required by the SQL
      standard for BINARY, BIT, BLOB, CHAR, CLOB, VARBINARY and VARCHAR types
      and is often needed for DECIMAL and NUMERIC. Therefore, HSQLDB allows
      the use of precision, scale or length for the type definition when they
      are valid for the type definition. HSQLDB also allows the use of real
      type names (without the <literal>SQL_</literal> prefix). (JDBC)</para>

      <para>
        <literal>CURRENT_USER</literal>
      </para>

      <para>
        <literal>CURRENT_ROLE</literal>
      </para>

      <para>
        <literal>SESSION_USER</literal>
      </para>

      <para>
        <literal>SYSTEM_USER</literal>
      </para>

      <para>
        <literal>CURRENT_SCHEMA</literal>
      </para>

      <para>
        <literal>CURRENT_CATALOG</literal>
      </para>

      <para>These functions return the named current session attribute. They
      are all SQL Standard functions.</para>

      <para>The CURRENT_USER is the user that connected to the database, or a
      user subsequently set by the SET AUTHORIZATION statement.</para>

      <para>SESSION_USER is the same as CURRENT_USER</para>

      <para>SYSTEM_USER is the user that connected to the database. It is not
      changed with any command until the session is closed.</para>

      <para>CURRENT_SCHEMA is default schema of the user, or a schema
      subsequently set by the SET SCHEMA command.</para>

      <para>CURRENT_CATALOG is always the same within a given HSQLDB database
      and indicates the name of the catalog.</para>
    </section>
  </chapter>

  <!--  Enable the index as soon as mark some index terms.
  <index xml:id="book-ind"/>
  -->
</book>
