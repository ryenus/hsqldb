<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="databaseobjects-title">Schemas and Other Database
  Objects</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>HSQLDB Development Group</orgname>
        </affiliation>

        <email>ft@cluedup.com</email>
      </author>
    </authorgroup>

    <edition>$Revision: 734 $</edition>

    <pubdate>$Date: 2009-01-08 19:19:51 +0000 (Thu, 08 Jan 2009) $</pubdate>

    <keywordset>
      <keyword>Hsqldb</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2009 Fred Toussi. Permission is granted to distribute
      this document without any alteration under the terms of the HSQLDB
      license. Additional permission is granted to the HSQLDB Development
      Group to distribute this document with or without alterations under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <para>The persistent elements of an SQL environment are database objects.
  The database consists of catalogs plus authorizations. In HyperSQL, there is
  only one catalog per database.</para>

  <para>A catalog contains only schemas while schemas contain database objects
  that contain data or govern the data. Separate from catalogs, there are USER
  and ROLE objects, collectively called <emphasis>authorizations</emphasis>.
  Each AUTHORIZATION has some access rights on some of the schemas or the
  objects they contain.</para>

  <para>Each catalog contains a special schema called INFORMATION_SCHEMA. This
  schema is read-only and contains some views and other schema objects. The
  views contain lists of all the database objects that exist within the
  database.</para>

  <para>Each database object has a name. A name is an identifier and is unique
  within its name-space.</para>

  <indexterm significance="preferred" type="sql">
    <primary>identifier definition</primary>
  </indexterm>

  <simpara><emphasis>definition of identifier</emphasis></simpara>

  <simpara><literal>&lt;identifier&gt; ::= &lt;regular identifier&gt; |
  &lt;delimited identifier&gt; | &lt;SQL language identifier&gt;
  </literal></simpara>

  <simpara><literal>&lt;delimited identifier&gt; ::= &lt;double quote&gt;
  &lt;character sequence&gt; &lt;double quote&gt;</literal></simpara>

  <simpara><literal>&lt;regular identifier&gt; ::= &lt;special character
  sequence&gt;</literal></simpara>

  <simpara><literal>&lt;SQL language identifier&gt; ::= &lt;special character
  sequence&gt;</literal></simpara>

  <simpara>A <literal>&lt;delimited identifier&gt;</literal> is a sequence of
  characters enclosed with double-quote symbols. The character sequence length
  must be between 1 and 128 characters. All characters are allowed in the
  character sequence.</simpara>

  <simpara>A <literal>&lt;regular identifier&gt;</literal> is a special
  sequence of characters. It consists of letters, digits and the underscore
  characters. It should begin with a letter. </simpara>

  <simpara>A <literal>&lt;SQL language identifier&gt;</literal> is similar to
  <literal>&lt;regular identifier&gt;</literal> but the letters can range only
  from A-Z in the ASCII character set. This type of identifier is used for
  names of CHARACTER SET objects.</simpara>

  <simpara>If the character sequence of a delimited identifier is the same as
  an undelimited identifier, it represents the same identifier. For example
  "JOHN" is the same identifier as JOHN. In a <literal>&lt;regular
  identifier&gt;</literal> the case-normal form is considered for comparison.
  This form consists of the upper-case of equivalent of all the letters.
  </simpara>

  <simpara>A reserved word is one that is used by the SQL Standard for special
  purposes. It is similar to a <literal>&lt;regular identifier&gt;</literal>
  but it cannot be used as an identifier for user objects. If a reserved word
  is enclosed in double quote characters, it becomes a quoted identifier and
  can be used for database objects.</simpara>

  <section>
    <title>Authorizations and Access Control</title>

    <para>In general, ROLE and USER objects simply control access to schema
    objects. This is the scope of SQL Standard. However, there are special
    roles that allow the creation of USER and ROLE objects and also allow some
    special operations on the database as a whole. These roles are not defined
    by the Standard, which has left it to implementors to define such roles as
    they are needed for the particular SQL implementation.</para>

    <para>A ROLE is a collection of zero or more other roles, plus some
    privileges (access rights). A USER is similarly a collection of zero or
    more roles plus some privileges. USER objects existed in the SQL-92, but
    ROLE objects were introduced in SQL:1999. Originally it was intended that
    USER objects would normally be the same as the operating system USER
    objects and their authentication would be handled outside the SQL
    environment. The existence of ROLE and USER objects results in complexity.
    With the addition of ROLE objects, there is no rationale, other than
    legacy support, for the possibility of granting privileges to USER
    objects.</para>

    <para>The Standard effectively defines a special ROLE, named PUBLIC. All
    authorization have the PUBLIC role, which cannot be removed from them.
    Therefore any access right assigned to the PUBLIC role applies to all
    authorizations in the database. Access to INFORMATION_SCHEMA views is
    granted to PUBLIC, therefore these views are accessible to all. However,
    the contents of each view depends on the ROLE or USER (AUTHORIZATION) that
    is in force while accessing the view.</para>

    <para>Each schema has a single AUTHORIZATION. This is commonly known as
    the <emphasis>owner</emphasis> of the schema. All the objects in the
    schema inherit the schema owner. The schema owner can add objects to the
    schema, drop them or alter them.</para>

    <para>The objects in a schema can only be accessed by the schema owner.
    The schema owner can grant access rights on the objects to other users or
    roles.</para>

    <indexterm significance="preferred" type="sql">
      <primary>AUTHORIZATION IDENTIFIER</primary>
    </indexterm>

    <simpara><emphasis>authorization identifier</emphasis></simpara>

    <simpara><literal>&lt;authorization identifier&gt; ::= &lt;role name&gt; |
    &lt;user name&gt;</literal></simpara>

    <simpara>Authorization identifiers share the same name-space within the
    database. The same name cannot be used for a USER and a ROLE.</simpara>

    <section>
      <title>Built-In Roles and Users</title>

      <para>There are some pre-defined roles in each database; some defined by
      the SQL Standard, some by HyperSQL. These roles can be assigned to users
      (directly or via other, user-defined roles). In addition, there is the
      default initial user, SA, created with each new database.</para>

      <indexterm significance="preferred" type="sql">
        <primary>PUBLIC ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">PUBLIC</emphasis></simpara>

      <simpara><emphasis>the PUBLIC role (SQL Standard)</emphasis></simpara>

      <simpara>The role that is assigned to all authorizations (roles and
      users) in the database. This role has access rights to all objects in
      the INFORMATION_SCHEMA. Any roles or rights granted to this role, are in
      effect granted to all users of the database.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>_SYSTEM ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">_SYSTEM</emphasis></simpara>

      <simpara><emphasis>the _SYSTEM role (SQL Standard)</emphasis></simpara>

      <simpara>This role is the authorization for the pre-defined (system)
      objects in the database, including the INFORMATION_SCHEMA. This role
      cannot be assigned to any authorization.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DBA ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">DBA</emphasis></simpara>

      <simpara><emphasis>the DBA role (HyperSQL)</emphasis></simpara>

      <simpara>This is a special role in HyperSQL. It is the default
      authorization for all the user-defined schemas in the database unless
      the authorization has been otherwise specified in the
      <literal>&lt;schema definition&gt;</literal> statement. In addition, a
      user that has this role, can perform all possible administrative tasks
      on the database. The DBA role can also act as a proxy for all the roles
      and users in the database. This means it can do everything the
      authorization for an schema can do, including dropping the schema or its
      objects, or granting rights on the schema objects to a
      grantee.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE_SCHEMA ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE_SCHEMA</emphasis></simpara>

      <simpara><emphasis>the CREATE_SCHEMA role
      (HyperSQL)</emphasis></simpara>

      <simpara>An authorization that has this role, can create schemas. The
      DBA authorization has this role and can grant it to other
      authorizations.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CHANGE_AUTHORIZATION</primary>
      </indexterm>

      <simpara><emphasis role="bold">CHANGE_AUTHORIZATION</emphasis></simpara>

      <simpara><emphasis>the CHANGE_AUTHORIZATION role
      (HyperSQL)</emphasis></simpara>

      <simpara>A user that has this role, can change the authorization for the
      current session to another user. The DBA authorization has this role and
      can grant it to other authorizations.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SA USER</primary>
      </indexterm>

      <simpara><emphasis role="bold">SA</emphasis></simpara>

      <simpara><emphasis>the SA user (HyperSQL)</emphasis></simpara>

      <simpara>This user is automatically created with a new database and has
      the DBA role. Initially, the password for this user is an empty string.
      After connecting to the new database as this user, it is possible to
      change the password, create other users and created new schema objects.
      This user can be dropped by another user that has the DBA
      role.</simpara>
    </section>

    <section>
      <title>Access Rights</title>

      <para>By default, the objects in a schema can only be accessed by the
      schema owner. But the schema owner can grant privileges (access rights)
      on the objects to other users or roles.</para>

      <para>Things can get far more complex, because the grant of privileges
      can be made WITH GRANT OPTION. In this case, the role or user that has
      been granted the privilege can grant the privilege to other roles and
      users.</para>

      <para>Privileges can also be revoked from users or roles.</para>

      <para>The statements for granting and revoking privileges normally
      specify which privileges are granted or revoked. However, there is a
      shortcut, ALL PRIVILEGES, which means all the privileges that the
      <literal>&lt;grantor&gt;</literal> has on the schema object. The
      <literal>&lt;grantor&gt;</literal> is normally the CURRENT_USER of the
      session that issues the statement.</para>

      <para>The user or role that is granted privileges is referred to as
      <literal>&lt;grantee&gt;</literal> for the granted privileges.</para>

      <simpara><emphasis role="bold">Table</emphasis></simpara>

      <simpara>For tables, including views, privileges can be granted with
      different degrees of granularity. It is possible to grant a privilege on
      all columns of a table, or on specific columns of the table.</simpara>

      <simpara>The DELETE privilege applies to the table, rather than its
      columns. It applies to all DELETE statements.</simpara>

      <simpara>The SELECT, INSERT and UPDATE privileges may apply to all
      columns or to individual columns. These privileges determine whether the
      <literal>&lt;grantee&gt;</literal> can execute SQL data statements on
      the table.</simpara>

      <simpara>The SELECT privilege designates the columns that can be
      referenced in SELECT statements, as well as the columns that are read in
      a DELETE or UPDATE statement, including the search condition.</simpara>

      <simpara>The INSERT privilege designates the columns into which explicit
      values can be inserted. To be able to insert a row into the table, the
      user should therefore have the INSERT privilege on the table, or at
      least all the columns that do not have a default value.</simpara>

      <simpara>The UPDATE privilege simply designates the table or the
      specific columns that can be updated.</simpara>

      <simpara>The REFERENCES privilege allows the
      <literal>&lt;grantee&gt;</literal> to define a FOREIGN KEY constraint on
      a different table, which references the table or the specific columns
      designated for the REFERENCES privilege.</simpara>

      <simpara>The TRIGGER privilege allows adding a trigger to the
      table.</simpara>

      <simpara><emphasis role="bold">Sequence, Type, Domain, Character Set,
      Collation, Transliteration,</emphasis></simpara>

      <simpara>For these objects, only USAGE can be granted. The USAGE
      privilege is needed when object is referenced directly in an SQL
      statement.</simpara>

      <simpara><emphasis role="bold">Routine</emphasis></simpara>

      <simpara>For routines, including procedures or functions, only EXECUTE
      privilege can be granted. This privilege is needed when the routine is
      used directly in an SQL statement.</simpara>

      <simpara><emphasis role="bold">Other Objects</emphasis></simpara>

      <simpara>Other objects such as constraints and assertions are not used
      directly and there is no grantable privilege that refers to
      them.</simpara>
    </section>

    <section>
      <title>Statements for Authorization and Access Control</title>

      <para>The statements listed below allow creation and destruction of USER
      and ROLE objects. The GRANT and REVOKE statements allow roles to be
      assigned to other roles or to users. The same statements are also used
      in a different form to assign privileges on schema objects to users and
      roles.</para>

      <!-- From Foundation chapt. 12 -->

      <indexterm significance="preferred" type="sql">
        <primary>CREATE USER</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE USER</emphasis></simpara>

      <simpara><emphasis>user definition (HyperSQL)</emphasis></simpara>

      <simpara><literal>&lt;user definition&gt; ::= CREATE USER &lt;user
      name&gt; PASSWORD &lt;password&gt; [ ADMIN ]</literal></simpara>

      <simpara>Define a new user and its password.
      <literal>&lt;password&gt;</literal> is a string enclosed with single
      quote characters. If <literal>ADMIN</literal> is specified, the DBA role
      is granted to the new user. Only a user with the DBA role can execute
      this command.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP USER</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP USER</emphasis></simpara>

      <simpara><emphasis>drop user statement (HyperSQL)</emphasis></simpara>

      <simpara><literal>&lt;drop user statement&gt; ::= DROP USER &lt;user
      name&gt;</literal></simpara>

      <simpara>Drop (destroy) an existing user. If the specified user is the
      authorization for an schema, the schema is destroyed. Only a user with
      the DBA role can execute this command.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SET PASSWORD</primary>
      </indexterm>

      <simpara><emphasis role="bold">SET PASSWORD</emphasis></simpara>

      <simpara><emphasis>set password statement
      (HyperSQL)</emphasis></simpara>

      <simpara><literal>&lt;set password statement&gt; ::= SET PASSWORD
      &lt;password&gt;</literal></simpara>

      <simpara>Set the password for the current user.
      <literal>&lt;password&gt;</literal> is a string enclosed with single
      quote characters.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE ROLE</emphasis></simpara>

      <simpara><emphasis>role definition</emphasis></simpara>

      <simpara><literal>&lt;role definition&gt; ::= CREATE ROLE &lt;role
      name&gt; [ WITH ADMIN &lt;grantor&gt; ]</literal></simpara>

      <simpara>Defines a new role. Initially the role has no rights, except
      those of the PUBLIC role. Only a user with the DBA role can execute this
      command.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP ROLE</emphasis></simpara>

      <simpara><emphasis>drop role statement</emphasis></simpara>

      <simpara><literal>&lt;drop role statement&gt; ::= DROP ROLE &lt;role
      name&gt;</literal></simpara>

      <simpara>Drop (destroy) a role. If the specified user is the
      authorization for an schema, the schema is destroyed. Only a user with
      the DBA role can execute this command.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>GRANTED BY</primary>
      </indexterm>

      <simpara><emphasis role="bold">GRANTED BY</emphasis></simpara>

      <simpara><emphasis>grantor determination</emphasis></simpara>

      <simpara><literal>GRANTED BY &lt;grantor&gt;</literal></simpara>

      <simpara><literal>&lt;grantor&gt; ::= CURRENT_USER |
      CURRENT_ROLE</literal></simpara>

      <simpara>The authorization that is granting or revoking a role or
      privileges. The optional <literal>GRANTED BY &lt;grantor&gt;</literal>
      clause can be used in various statements that perform GRANT or REVOKE
      actions. If the clause is not used, the authorization is CURRENT_USER.
      Otherwise, it is the specified authorization.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>GRANT privilege</primary>
      </indexterm>

      <simpara><emphasis role="bold">GRANT</emphasis></simpara>

      <simpara><emphasis>grant privilege statement</emphasis></simpara>

      <simpara><literal>&lt;grant privilege statement&gt; ::= GRANT
      &lt;privileges&gt; TO &lt;grantee&gt; [ { &lt;comma&gt; &lt;grantee&gt;
      }... ] [ WITH GRANT OPTION ] [ GRANTED BY &lt;grantor&gt;
      ]</literal></simpara>

      <simpara>Assign privileges on schema objects to roles or users. Each
      <literal>&lt;grantee&gt;</literal> is a role or a user. If <literal>[
      WITH GRANT OPTION ]</literal> is specified, then the
      <literal>&lt;grantee&gt;</literal> can assign the privileges to other
      <literal>&lt;grantee&gt;</literal> objects.</simpara>

      <simpara><literal>&lt;privileges&gt; ::= &lt;object privileges&gt; ON
      &lt;object name&gt;</literal></simpara>

      <simpara><literal>&lt;object name&gt; ::= [ TABLE ] &lt;table name&gt; |
      DOMAIN &lt;domain name&gt; | COLLATION &lt;collation name&gt; |
      CHARACTER SET &lt;character set name&gt; | TRANSLATION
      &lt;transliteration name&gt; | TYPE &lt;user-defined type name&gt; |
      SEQUENCE &lt;sequence generator name&gt; | &lt;specific routine
      designator&gt; | &lt;routine name&gt;</literal></simpara>

      <simpara><literal>&lt;object privileges&gt; ::= ALL PRIVILEGES |
      &lt;action&gt; [ { &lt;comma&gt; &lt;action&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;action&gt; ::= SELECT | SELECT &lt;left paren&gt;
      &lt;privilege column list&gt; &lt;right paren&gt; | DELETE | INSERT [
      &lt;left paren&gt; &lt;privilege column list&gt; &lt;right paren&gt; ] |
      UPDATE [ &lt;left paren&gt; &lt;privilege column list&gt; &lt;right
      paren&gt; ] | REFERENCES [ &lt;left paren&gt; &lt;privilege column
      list&gt; &lt;right paren&gt; ] | USAGE | TRIGGER |
      EXECUTE</literal></simpara>

      <simpara><literal>&lt;privilege column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;grantee&gt; ::= PUBLIC | &lt;authorization
      identifier&gt;</literal></simpara>

      <simpara>The <literal>&lt;object privileges&gt;</literal> that can be
      used depend on the type of the <literal>&lt;object name&gt;</literal>.
      If <literal>&lt;privilege column list&gt;</literal> is not specified,
      then the privilege is granted on the table, which includes all of its
      columns and any column that may be added to it in the future.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>GRANT role</primary>
      </indexterm>

      <simpara><emphasis role="bold">GRANT</emphasis></simpara>

      <simpara><emphasis>grant role statement</emphasis></simpara>

      <simpara><literal>&lt;grant role statement&gt; ::= GRANT &lt;role
      name&gt; [ { &lt;comma&gt; &lt;role name&gt; }... ] TO &lt;grantee&gt; [
      { &lt;comma&gt; &lt;grantee&gt; }... ] [ WITH ADMIN OPTION ] [ GRANTED
      BY &lt;grantor&gt; ]</literal></simpara>

      <simpara>Assign roles to roles or users. One or more roles can be
      assigned to one or more <literal>&lt;grantee&gt;</literal> objects. A
      <literal>&lt;grantee&gt;</literal> is a user or a role. If the
      <literal>[ WITH ADMIN OPTION ]</literal> is specified, then each
      <literal>&lt;grantee&gt;</literal> can grant the newly assigned roles to
      other grantees.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>REVOKE</primary>
      </indexterm>

      <simpara><emphasis role="bold">REVOKE privilege</emphasis></simpara>

      <simpara><emphasis>revoke statement</emphasis></simpara>

      <simpara><literal>&lt;revoke privilege statement&gt; ::= REVOKE [ GRANT
      OPTION FOR ] &lt;privileges&gt; FROM &lt;grantee&gt; [ { &lt;comma&gt;
      &lt;grantee&gt; }... ] [ GRANTED BY &lt;grantor&gt; ] RESTRICT |
      CASCADE</literal></simpara>

      <simpara>Revoke privileges from a user or role.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>REVOKE ROLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">REVOKE role</emphasis></simpara>

      <simpara><emphasis>revoke role statement</emphasis></simpara>

      <simpara><literal>&lt;revoke role statement&gt; ::= REVOKE [ ADMIN
      OPTION FOR ] &lt;role revoked&gt; [ { &lt;comma&gt; &lt;role revoked&gt;
      }... ] FROM &lt;grantee&gt; [ { &lt;comma&gt; &lt;grantee&gt; }... ] [
      GRANTED BY &lt;grantor&gt; ] RESTRICT | CASCADE</literal></simpara>

      <simpara><literal>&lt;role revoked&gt; ::= &lt;role
      name&gt;</literal></simpara>

      <simpara>Revoke a role from users or roles.</simpara>
    </section>
  </section>

  <section>
    <title>Schemas and Schema Objects</title>

    <para>Schema objects are database objects that contain data or govern or
    perform operations on data.</para>

    <para>There are several kinds of schema objects.</para>

    <itemizedlist>
      <listitem>
        <para>Some kinds of schema objects can exist independently from other
        kinds of schema object, while other kinds can exist only as elements
        of another kind of objects. These dependent objects are automatically
        destroyed when the parent object is dropped.</para>
      </listitem>

      <listitem>
        <para>Separate name-spaces exists for different kinds of schema
        object. Some name-spaces are shared between two kinds of schema
        objects.</para>
      </listitem>

      <listitem>
        <para>There can be dependencies between various schema objects, as a
        schema object can include references to other schema objects. These
        references can cross schema boundaries. Interdependence and cross
        referencing between schema objects is allowed in some circumstances
        and disallowed in some others.</para>
      </listitem>
    </itemizedlist>

    <para>More..</para>

    <section>
      <title>Names and References</title>

      <para>The name of an schema object is an
      <literal>&lt;identifier&gt;</literal>. The name belongs to the
      name-space for the particular kind of schema object within the schema.
      The name is unique within its name-space. For example, each schema has a
      separate name-space for TRIGGER objects.</para>

      <para>In addition to the name-spaces in the schema. Each table has a
      name-space for the names of its columns.</para>

      <para>Because a schema object is always in a schema and a schema always
      in a catalog, it is possible, and sometimes necessary, to qualify the
      name of the schema object that is being referenced in an SQL statement.
      This is done by forming an &lt;<literal>identifier chain&gt;</literal>.
      In some contexts, only a simple <literal>&lt;identifier&gt;</literal>
      ran be used and the <literal>&lt;identifier chain&gt;</literal> is
      prohibited. While in some other contexts, the use of
      <literal>&lt;identifier chain&gt;</literal> is optional. An identifier
      chain is be formed by qualifying each object with the name of the object
      that owns its name-space. Therefore a column name is prefixed with a
      table name, a table name is prefixed with a schema name, and a schema
      name is prefixed with a catalog name. A fully qualified column name is
      in the form <literal>&lt;catalog name&gt;.&lt;schema name&gt;.&lt;table
      name&gt;.&lt;column name&gt;</literal>, likewise, a fully qualified
      sequence name is in the form <literal>&lt;catalog name&gt;.&lt;schema
      name&gt;.&lt;sequence name&gt;</literal>.</para>
    </section>

    <section>
      <title>Character Sets</title>

      <simpara>A CHARACTER SET is the whole or a subset of the UNICODE
      character set.</simpara>

      <simpara>A character set names can only be an <literal>&lt;regular
      identifier&gt;</literal>. There is a separate name-space for character
      sets.</simpara>

      <simpara>There are several predefined character sets. These character
      sets belong to INFORMATION_SCHEMA. However, when they are referenced in
      a statement, no schema prefix can be used in the statement that
      references them.</simpara>

      <simpara>The following character sets have been specified by the SQL
      Standard:</simpara>

      <simpara>SQL_TEXT, SQL_IDENTIFIER, SQL_CHARACTER, ASCII_GRAPHIC,
      GRAPHIC_IRV, ASCII_FULL, ISO8BIT, LATIN1, UTF32, UTF16, UTF8.</simpara>

      <simpara>The ASCII_GRAPHIC is the same as GRAPHIC_IRV and ASCII_FULL is
      the same as ISO8BIT.</simpara>

      <simpara>Most of the character sets are defined by well-known standards
      such as UNICODE.</simpara>

      <simpara>The SQL_CHARACTER consists of ASCII letters, digits and the
      symbols used in the SQL language. The SQL_TEXT, SQL_IDENTIFIER are
      implementation defined. HyperSQL defines SQL_TEXT as the UNICODE
      character set and SQL_IDENTIFIER as the UNICODE character set minus the
      SQL language special characters.</simpara>
    </section>

    <section>
      <title>Collations</title>

      <simpara>A COLLATION is the method used for ordering character strings
      in ordered sets and to determine equivalence of two character
      strings.</simpara>

      <simpara>There are several predefined collations. These collations
      belong to INFORMATION-SCHEMA. However, when they are referenced in a
      statement, no schema prefix can be used in the statement that references
      them.</simpara>

      <simpara>There is a separate name-space for collations.</simpara>

      <simpara>The SQL Standard specifies several collations with the same
      name as the character sets that it specifies.</simpara>
    </section>

    <section>
      <title>Distinct Types</title>

      <simpara>A distinct, user-defined TYPE is simply based on a built-in
      type. A distinct TYPE is used in table definitions and in CAST
      statements.</simpara>

      <simpara>Distinct types share a name-space with domains.</simpara>
    </section>

    <section>
      <title>Domains</title>

      <simpara>A DOMAIN is a user-defined type, simply based on a built-in
      type. A DOMAIN can have constraints that limit the values that the
      DOMAIN can represent. A DOMAIN can be used in table definitions and in
      CAST statements.</simpara>

      <simpara>Distinct types share a name-space with domains.</simpara>
    </section>

    <section>
      <title>Number Sequences</title>

      <simpara>A SEQUENCE object produces INTEGER values in sequence. The
      SEQUENCE can be referenced in special contexts only within certain SQL
      statements.</simpara>

      <simpara>There is a separate name-space for sequence objects.</simpara>
    </section>

    <section>
      <title>Tables</title>

      <simpara>In the SQL environment, tables are the most essential
      components, as they hold all persistent data.</simpara>

      <simpara>If TABLE is considered as metadata (i.e. without its actual
      data) it is called a <emphasis>relation</emphasis> in relational theory.
      It has one or more columns, with each column having a distinct name and
      a data type. A table usually has one or more constraints which limit the
      values that can potentially be stored in the TABLE. These constraints
      are discussed in the next section.</simpara>

      <simpara>A single column of the table can be defined as IDENTITY. The
      values stored in this column are auto-generated and are based on an
      (unnamed) identity sequence.</simpara>
    </section>

    <section>
      <title>Views</title>

      <simpara>A VIEW is similar to a TABLE but it does not permanently
      contain rows of data. A view is defined as a QUERY EXPRESSION, which is
      often a SELECT statement that references views and tables, but it can
      also consist of a TABLE CONSTRUCTOR that does not reference any tables
      or views.</simpara>

      <simpara>A VIEW that is ultimately based on a single TABLE may be
      <glossterm>updatable</glossterm>. Some <glossterm>updatable</glossterm>
      views are <glossterm>insertable-into</glossterm>.</simpara>

      <simpara>Views share a name-space with tables.</simpara>
    </section>

    <section>
      <title>Constraints</title>

      <simpara>A CONSTRAINT is a child schema object and can belong to a
      DOMAIN or a TABLE.</simpara>

      <simpara>In a DOMAIN, CHECK constraints can be defined that limits the
      value represented by the DOMAIN. These constraints work exactly like a
      CHECK constraint on a single column of a table as described
      below.</simpara>

      <simpara>In a TABLE, a constraint takes three basic forms.</simpara>

      <simpara><emphasis role="bold">CHECK</emphasis></simpara>

      <simpara>A CHECK constraint consists of a <literal>&lt;search
      condition&gt;</literal> that must not be false (can be unknown) for each
      row of the table. A simple form of check constraint is the NOT NULL
      constraint, which applies to a single column. The <literal>&lt;search
      condition&gt;</literal> can reference all the columns of the current
      row, and if it contains a <literal>&lt;subquery&gt;</literal>, other
      tables and views in the database (excluding its own table).</simpara>

      <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

      <simpara>A UNIQUE constraint is based on an equality comparison of
      values of specific columns (taken together) of one row with the same
      values from each of the other rows. The result of the comparison must
      never be true (can be false or unknown). If a row of the table has NULL
      in any of the columns of the constraint, it conforms to the
      constraint.</simpara>

      <simpara>A PRIMARY KEY constraint is equivalent to a UNIQUE constraint
      on one or more NOT NULL columns. Only one PRIMARY KEY can be defined in
      each table.</simpara>

      <simpara><emphasis role="bold">FOREIGN KEY</emphasis></simpara>

      <simpara>A FOREIGN key constraint is based on an equality comparison
      between values of specific columns(taken together) of each row with the
      values of the columns of a UNIQUE constraint on another table or the
      same table. The result of the comparison must never be false (can be
      unknown). A special form of FOREIGN KEY constraint, based on its CHECK
      clause, allows the result to be unknown only if the values for all
      columns are NULL.</simpara>

      <simpara>Constraints share a name space with assertions.</simpara>
    </section>

    <section>
      <title>Assertions</title>

      <para>An ASSERTION is a top-level schema objects. It consists of a
      <literal>&lt;search condition&gt;</literal> that must not be false (can
      be unknown).</para>

      <para>Assertions share a name-space with constraints</para>
    </section>

    <section>
      <title>Triggers</title>

      <simpara>A TRIGGER is a child schema object that always belongs to a
      TABLE or a VIEW.</simpara>

      <simpara>Trigger functionality first appeared in SQL:1999. Triggers
      embody the <emphasis>live database</emphasis> concept, where changes in
      SQL data can be monitored and acted upon. SQL Standard triggers are
      <literal>imperative</literal> while the <literal>relational</literal>
      aspects of SQL are declarative. Triggers allow performing an arbitrary
      transformation of data that is being updated or inserted, or to prevent
      deletes, or to perform additional operations.</simpara>

      <simpara>Some bad examples of SQL triggers in effect enforce an
      “integrity constraint” which would better be expressed as a CHECK
      constraint. A trigger that causes an exception if the value inserted in
      a column is negative is such an example. A check constraint that
      declares CHECK VALUE &gt;= 0 (declarative) is a better way of expressing
      an integrity constraint than a trigger that throws an exception if the
      same condition is false.</simpara>

      <simpara>Some constraints cannot be expressed by SQL’s constraint
      statements. Triggers can overcome some of the limitations. For example,
      it is possible to write a check constraint that prevents data from being
      added to a table on weekends. But it is not possible to write a check
      constraint that prevents existing data from being modified or deleted on
      weekends. A trigger can enforce this second kind of
      constraint.</simpara>

      <simpara>Triggers can have different roles beyond constraints. For
      example, a trigger can modify the values that are inserted into the
      database, instead of rejecting them. Triggers can also perform
      additional data changes, for example inserting an additional row into a
      different table.</simpara>

      <simpara>A trigger is declared to activate when an UPDATE, INSERT or
      DELETE action is performed on a table. These actions may be direct, or
      indirect, arising from CASCADE actions of FOREIGN KEY constraints, or
      actions performed on a VIEW that is based on the table.</simpara>

      <simpara>It is possible to declare multiple triggers on a single table.
      The triggers activate one by one according to the order in which they
      were defined.</simpara>

      <simpara>A row level trigger allows access to the deleted or inserted
      rows. For UPDATE actions there is both an old and new version of each
      row. A trigger can be specified to activate before or after the action
      has been performed. Triggers that are performed after the action cannot
      modify the rows that have been modified. These triggers can perform
      other actions, such as inserting rows into other tables. Triggers that
      are performed before the action can modify the inserted or updated rows
      but not the deleted rows.</simpara>

      <simpara>A TRIGGER that is declared on a VIEW, is an INSTEAD OF trigger.
      This term means when an INSERT, UPDATE or DELETE statement is executed,
      the trigger action is all that is performed, and no further data change
      takes place on the VIEW. The trigger action can include all the
      statements that are necessary to change the data in the tables that
      underlie the VIEW. With the use of INSTEAD OF triggers a read-only view
      can effectively become updatable or insertable-into.</simpara>
    </section>

    <section>
      <title>Routines</title>

      <simpara>Routines are user-defined functions or procedures. The names
      and usage of functions and procedures are different. FUNCTION is a
      routine that can be referenced in many types of statements. PROCEDURE is
      a routine that can be referenced only in a CALL statement.</simpara>

      <simpara>There is a separate name-space for routines.</simpara>

      <simpara>Routines are discussed in detail in a separate
      chapter.</simpara>
    </section>

    <section>
      <title>Statements for Schema Definition and Manipulation</title>

      <!-- From Foundation chapt. 11 -->

      <indexterm significance="preferred" type="sql">
        <primary>CASCADE or RESTRICT</primary>
      </indexterm>

      <simpara><emphasis role="bold">CASCADE or RESTRICT</emphasis></simpara>

      <simpara><emphasis>drop behavior</emphasis></simpara>

      <simpara><literal>&lt;drop behavior&gt; ::= CASCADE |
      RESTRICT</literal></simpara>

      <simpara>The <literal>&lt;drop behavior&gt;</literal> is specified in
      statements that drop a SCHEMA or a schema object. If <literal>&lt;drop
      behavior&gt;</literal> is not specified then <literal>RESTRICT</literal>
      is implicit. It determines the effect of the statement if there are
      other objects in the catalog that reference the SCHEMA or the schema
      object. If RESTRICT is specified, the statement fails if there are
      referencing objects. If CASCADE is specified, all the referencing
      objects are modified or dropped with cascading effect. Whether a
      referencing object is modified or dropped, depends on the kind of schema
      object that is dropped.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE SCHEMA</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE SCHEMA</emphasis></simpara>

      <simpara><emphasis>schema definition</emphasis></simpara>

      <para>A schema can be created with or without schema objects. Schema
      objects can always be added after creating the schema, or existing ones
      can be dropped. Within the <literal>&lt;schema definition&gt;</literal>
      statement, all schema object creation takes place inside the newly
      created schema. Therefore, if an schema name is specified for the schema
      objects, the name should match that of the new schema. In addition to
      statements for creating schema objects, the statement can include
      instances of <literal>&lt;grant statement&gt;</literal> and
      <literal>&lt;role definition&gt;</literal>. This is a curious aspect of
      the SQL standard, as these elements do not really belong to schema
      creation.</para>

      <simpara><literal>&lt;schema definition&gt; ::= CREATE SCHEMA &lt;schema
      name clause&gt; [ &lt;schema character set specification&gt; ] [
      &lt;schema element&gt;... ]</literal></simpara>

      <simpara><literal>&lt;schema name clause&gt; ::= &lt;schema name&gt; |
      AUTHORIZATION &lt;authorization identifier&gt; | &lt;schema name&gt;
      AUTHORIZATION &lt;authorization identifier&gt;</literal></simpara>

      <para>If the name of the schema is specified simply as
      <literal>&lt;schema name&gt;</literal>, then the AUTHORIZATION is the
      special system role, DBA. Otherwise, the specified
      <literal>&lt;authorization identifier&gt;</literal> is used as the
      AUTHORIZATION for the schema. If <literal>&lt;schema name&gt;</literal>
      is omitted, then the name of the schema is the same as the specified
      <literal>&lt;authorization identifier&gt;</literal>.</para>

      <simpara><literal>&lt;schema element&gt; ::= &lt;table definition&gt; |
      &lt;view definition&gt; | &lt;domain definition&gt; | &lt;character set
      definition&gt; | &lt;collation definition&gt; | &lt;transliteration
      definition&gt; | &lt;assertion definition&gt; | &lt;trigger
      definition&gt; | &lt;user-defined type definition&gt; | &lt;user-defined
      cast definition&gt; | &lt;user-defined ordering definition&gt; |
      &lt;transform definition&gt; | &lt;schema routine&gt; | &lt;sequence
      generator definition&gt; | &lt;grant statement&gt; | &lt;role
      definition&gt;</literal></simpara>

      <simpara>An example of the command is given below:</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP SCHEMA</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP SCHEMA</emphasis></simpara>

      <simpara><emphasis>drop schema statement</emphasis></simpara>

      <simpara><literal>&lt;drop schema statement&gt; ::= DROP SCHEMA
      &lt;schema name&gt; CASCADE | RESTRICT</literal></simpara>

      <simpara>This command destroys an existing schema. If
      <literal>RESTRICT</literal> is specified, the schema must be empty,
      otherwise an error is raised. If <literal>CASCADE</literal> is
      specified, then all the objects contained in the schema are destroyed
      with a CASCADE option.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE TABLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE TABLE</emphasis></simpara>

      <simpara><emphasis>table definition</emphasis></simpara>

      <simpara><literal>&lt;table definition&gt; ::= CREATE [ { &lt;table
      scope&gt; | &lt;table type&gt; } ] TABLE &lt;table name&gt; &lt;table
      contents source&gt; [ ON COMMIT { PRESERVE | DELETE } ROWS
      ]</literal></simpara>

      <simpara><literal>&lt;table scope&gt; ::= { GLOBAL | LOCAL }
      TEMPORARY</literal></simpara>

      <simpara><literal>&lt;table type&gt; :: = MEMORY |
      CACHED</literal></simpara>

      <simpara><literal>&lt;table contents source&gt; ::= &lt;table element
      list&gt; | &lt;as subquery clause&gt;</literal></simpara>

      <simpara><literal>&lt;table element list&gt; ::= &lt;left paren&gt;
      &lt;table element&gt; [ { &lt;comma&gt; &lt;table element&gt; }... ]
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;table element&gt; ::= &lt;column definition&gt; |
      &lt;table constraint definition&gt; | &lt;like
      clause&gt;</literal></simpara>

      <simpara><emphasis>like clause</emphasis></simpara>

      <simpara>A <literal>&lt;like clause&gt;</literal> copies all column
      definitions from another table into the newly created table. Its three
      options indicate if the <literal>&lt;default clause&gt;</literal>,
      <literal>&lt;identity column specification&gt;</literal> and
      <literal>&lt;generation clause&gt;</literal> associated with the column
      definitions are copied or not. The <literal>&lt;like
      clause&gt;</literal> can be used multiple times, allowing the new table
      to have copies of the column definitions of one or more other tables. If
      an option is not specified, it defaults to
      <literal>EXCLUDING</literal>.</simpara>

      <simpara><literal>&lt;like clause&gt; ::= LIKE &lt;table name&gt; [
      &lt;like options&gt; ]</literal></simpara>

      <simpara><literal>&lt;like options&gt; ::= &lt;like
      option&gt;...</literal></simpara>

      <simpara><literal>&lt;like option&gt; ::= &lt;identity option&gt; |
      &lt;column default option&gt; | &lt;generation
      option&gt;</literal></simpara>

      <simpara><literal>&lt;identity option&gt; ::= INCLUDING IDENTITY |
      EXCLUDING IDENTITY</literal></simpara>

      <simpara><literal>&lt;column default option&gt; ::= INCLUDING DEFAULTS |
      EXCLUDING DEFAULTS</literal></simpara>

      <simpara><literal>&lt;generation option&gt; ::= INCLUDING GENERATED |
      EXCLUDING GENERATED</literal></simpara>

      <simpara><emphasis>as subquery clause</emphasis></simpara>

      <simpara><literal>&lt;as subquery clause&gt; ::= [ &lt;left paren&gt;
      &lt;column name list&gt; &lt;right paren&gt; ] AS &lt;table subquery&gt;
      { WITH NO DATA | WITH DATA }</literal></simpara>

      <simpara>An <literal>&lt;as subquery clause&gt;</literal> used in table
      definition creates a table based on a <literal>&lt;table
      subquery&gt;</literal>. This kind of table definition is similar to a
      view definition. If <literal>WITH DATA</literal> is specified, then the
      new table will contain the rows of data returned by the
      <literal>&lt;table subquery&gt;</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>column definition</primary>
      </indexterm>

      <simpara><emphasis>column definition</emphasis></simpara>

      <simpara>A column definition consists of a <literal>&lt;column
      name&gt;</literal> and in most cases a <literal>&lt;data
      type&gt;</literal> or <literal>&lt;domain name&gt;</literal> as minimum.
      Each <literal>&lt;column name&gt;</literal> is unique. The other
      elements of <literal>&lt;column definition&gt;</literal> are
      optional.</simpara>

      <simpara><literal>&lt;column definition&gt; ::= &lt;column name&gt; [
      &lt;data type or domain name&gt; ] [ &lt;default clause&gt; |
      &lt;identity column specification&gt; | &lt;generation clause&gt; ] [
      &lt;column constraint definition&gt;... ] [ &lt;collate clause&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;data type or domain name&gt; ::= &lt;data type&gt;
      | &lt;domain name&gt;</literal></simpara>

      <simpara><literal>&lt;column constraint definition&gt; ::= [
      &lt;constraint name definition&gt; ] &lt;column constraint&gt; [
      &lt;constraint characteristics&gt; ]</literal></simpara>

      <simpara><literal>&lt;column constraint&gt; ::= NOT NULL | &lt;unique
      specification&gt; | &lt;references specification&gt; | &lt;check
      constraint definition&gt;</literal></simpara>

      <simpara><literal>&lt;identity column specification&gt; ::= GENERATED {
      ALWAYS | BY DEFAULT } AS IDENTITY [ &lt;left paren&gt; &lt;common
      sequence generator options&gt; &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;generation clause&gt; ::= GENERATED ALWAYS AS
      &lt;generation expression&gt;</literal></simpara>

      <simpara><literal>&lt;generation expression&gt; ::= &lt;left paren&gt;
      &lt;value expression&gt; &lt;right paren&gt;</literal></simpara>

      <simpara>The <literal>&lt;identity column specification&gt;</literal>
      can be specified for only a single column of the table.</simpara>

      <simpara>A <literal>&lt;column constraint definition&gt;</literal> is a
      shortcut for a <literal>&lt;table constraint definition&gt;</literal>. A
      constraint that is defined in this way is automatically turned into a
      table constraint. A name is automatically generated for the constraint
      and assigned to it.</simpara>

      <simpara>The <literal>&lt;identity column specification&gt;</literal> is
      used for special columns which represent values based on an unanmed
      sequence generators. It is possible to insert a row into the able
      without specifying a value for the column. The value is then generated
      by the sequence generators according to its rules.</simpara>

      <simpara>The <literal>&lt;generation clause&gt;</literal> is used for
      special columns which represent values based on the values held in other
      columns in the same row. The <literal>&lt;value expression&gt;</literal>
      must reference only other, non-generatate, columns of the table in the
      same row. Therefore, any function used in the expression may not access
      SQL-data, and no <literal>&lt;query expression&gt;</literal> is allowed.
      When <literal>&lt;generation clause&gt;</literal> is used,
      <literal>&lt;data type&gt;</literal> or <literal>&lt;domain
      name&gt;</literal> may be omitted.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DEFAULT clause</primary>
      </indexterm>

      <simpara><emphasis role="bold">DEFAULT</emphasis></simpara>

      <simpara><emphasis>default clause</emphasis></simpara>

      <simpara>A default clause can be used if GENERATED is not specified. If
      a column has a <literal>&lt;default clause&gt;</literal> then it is
      possible to insert a row into the table without specifying a value for
      the column.</simpara>

      <simpara><literal>&lt;default clause&gt; ::= DEFAULT &lt;default
      option&gt;</literal></simpara>

      <simpara><literal>&lt;default option&gt; ::= &lt;literal&gt; |
      &lt;datetime value function&gt; | USER | CURRENT_USER | CURRENT_ROLE |
      SESSION_USER | SYSTEM_USER | CURRENT_CATALOG | CURRENT_SCHEMA |
      CURRENT_PATH | NULL</literal></simpara>

      <simpara>The type of the &lt;default option&gt; must match the type of
      the column.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CONSTRAINT (table constraint)</primary>
      </indexterm>

      <simpara><emphasis role="bold">CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>table constraint definition</emphasis></simpara>

      <simpara><literal>&lt;table constraint definition&gt; ::= [
      &lt;constraint name definition&gt; ] &lt;table constraint&gt; [
      &lt;constraint characteristics&gt; ]</literal></simpara>

      <simpara><literal>&lt;table constraint&gt; ::= &lt;unique constraint
      definition&gt; | &lt;referential constraint definition&gt; | &lt;check
      constraint definition&gt;</literal></simpara>

      <simpara>Four kinds of constraint can be defined on a table. Each kind
      has its own rules to limit the values that can be specified for
      different columns in each row of the table.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>UNIQUE constraint</primary>
      </indexterm>

      <indexterm significance="preferred" type="sql">
        <primary>PRIMARY KEY constraint</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIQUE</emphasis></simpara>

      <simpara><emphasis>unique constraint definition</emphasis></simpara>

      <simpara><literal>&lt;unique constraint definition&gt; ::= &lt;unique
      specification&gt; &lt;left paren&gt; &lt;unique column list&gt;
      &lt;right paren&gt; | UNIQUE ( VALUE )</literal></simpara>

      <simpara><literal>&lt;unique specification&gt; ::= UNIQUE | PRIMARY
      KEY</literal></simpara>

      <simpara><literal>&lt;unique column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara>A unique constraint is specified on a single column or on
      multiple columns. On each set of columns taken together, only one UNIQUE
      constraint can be specified. Each column of a PRIMARY KEY constraint has
      an implicit NOT NULL constraint.</simpara>

      <simpara>If <literal>UNIQUE( VALUE )</literal> is specified, the
      constraint created on all columns of the table.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>FOREIGN KEY constraint</primary>
      </indexterm>

      <simpara><emphasis role="bold">FOREIGN KEY</emphasis></simpara>

      <simpara><emphasis>referential constraint
      definition</emphasis></simpara>

      <simpara><literal>&lt;referential constraint definition&gt; ::= FOREIGN
      KEY &lt;left paren&gt; &lt;referencing columns&gt; &lt;right paren&gt;
      &lt;references specification&gt;</literal></simpara>

      <simpara><literal>&lt;references specification&gt; ::= REFERENCES
      &lt;referenced table and columns&gt; [ MATCH &lt;match type&gt; ] [
      &lt;referential triggered action&gt; ]</literal></simpara>

      <simpara><literal>&lt;match type&gt; ::= FULL | PARTIAL |
      SIMPLE</literal></simpara>

      <simpara><literal>&lt;referencing columns&gt; ::= &lt;reference column
      list&gt;</literal></simpara>

      <simpara><literal>&lt;referenced table and columns&gt; ::= &lt;table
      name&gt; [ &lt;left paren&gt; &lt;reference column list&gt; &lt;right
      paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;reference column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;referential triggered action&gt; ::= &lt;update
      rule&gt; [ &lt;delete rule&gt; ] | &lt;delete rule&gt; [ &lt;update
      rule&gt; ]</literal></simpara>

      <simpara><literal>&lt;update rule&gt; ::= ON UPDATE &lt;referential
      action&gt;</literal></simpara>

      <simpara><literal>&lt;delete rule&gt; ::= ON DELETE &lt;referential
      action&gt;</literal></simpara>

      <simpara><literal>&lt;referential action&gt; ::= CASCADE | SET NULL |
      SET DEFAULT | RESTRICT | NO ACTION</literal></simpara>

      <simpara>A referential constraint allows links to be established between
      the rows of two tables. The specified list of <literal>&lt;referencing
      columns&gt;</literal> corresponds one by one to the columns of the
      specified list of <literal>&lt;referenced columns&gt;</literal> in
      another table (or sometimes in the same table). For each row in the
      table, a row must exist in the referenced table with equivalent values
      in the two column lists. There must exist a single unique constraint in
      the referenced table on all the <literal>&lt;referenced
      columns&gt;</literal>.</simpara>

      <simpara>The <literal>[ MATCH match type ]</literal> clause is optional
      and has a effect only on multi-column foreign keys and only on rows
      containing at least a NULL in one of the <literal>&lt;referencing
      columns&gt;</literal>. If the clause is not specified, MATCH SIMPLE is
      the default. If there is a NULL in any of the columns, the row is
      subject to the <literal>MATCH</literal> specification. If <literal>MATCH
      SIMPLE</literal> is specified, then any NULL means the row can exist
      (without a corresponding row in the referenced table). If <literal>MATCH
      FULL</literal> is specified then either all the column values should be
      NULL or none of them. <literal>MATCH PARTIAL</literal> allows any NULL
      but the non NULL values must match those of a row in the referenced
      table. HyperSQL does not support <literal>MATCH
      PARTIAL</literal>.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CHECK constraint</primary>
      </indexterm>

      <simpara><emphasis role="bold">CHECK</emphasis></simpara>

      <simpara><emphasis>check constraint definition</emphasis></simpara>

      <simpara><literal>&lt;check constraint definition&gt; ::= CHECK &lt;left
      paren&gt; &lt;search condition&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara>A CHECK constraint can exist for a TABLE or for a DOMAIN. The
      <literal>&lt;search condition&gt;</literal> evaluates to an SQL BOOLEAN
      value for each row of the table. Within the <literal>&lt;search
      condition&gt;</literal> all columns of the table row can be referenced.
      The value should not be FALSE for any row.</simpara>

      <simpara>A CHECK constraint for a DOMAIN is similar. In its
      <literal>&lt;search condition&gt;</literal>, the term VALUE is used to
      represents the value to which the DOMAIN applies.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALTER TABLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALTER TABLE</emphasis></simpara>

      <simpara><emphasis>alter table statement</emphasis></simpara>

      <simpara><literal>&lt;alter table statement&gt; ::= ALTER TABLE
      &lt;table name&gt; &lt;alter table action&gt;</literal></simpara>

      <simpara><literal>&lt;alter table action&gt; ::= &lt;add column
      definition&gt; | &lt;alter column definition&gt; | &lt;drop column
      definition&gt; | &lt;add table constraint definition&gt; | &lt;drop
      table constraint definition&gt;</literal></simpara>

      <simpara>Change the definition of a table.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ADD COLUMN</primary>
      </indexterm>

      <simpara><emphasis role="bold">ADD COLUMN</emphasis></simpara>

      <simpara><emphasis>add column definition</emphasis></simpara>

      <simpara><literal>&lt;add column definition&gt; ::= ADD [ COLUMN ]
      &lt;column definition&gt; [ BEFORE &lt;other column name&gt;
      ]</literal></simpara>

      <simpara>Add a column to an existing table. The <literal>&lt;column
      definition&gt;</literal> is specified the same way as it is used in
      <literal>&lt;table definition&gt;</literal>. HyperSQL allows the use of
      <literal>[ BEFORE &lt;other column name&gt; ]</literal> to specify at
      which position the new column is added to the table.</simpara>

      <simpara>If the table contains rows, the new column must have a
      &lt;default clause&gt; or use one of the forms of GENERATED. The column
      values for each row is then filled with the result of the &lt;default
      clause&gt; or the generated value.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALTER COLUMN</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALTER COLUMN</emphasis></simpara>

      <simpara><emphasis>alter column definition</emphasis></simpara>

      <simpara><literal>&lt;alter column definition&gt; ::= ALTER [ COLUMN ]
      &lt;column name&gt; &lt;alter column action&gt;</literal></simpara>

      <simpara><literal>&lt;alter column action&gt; ::= &lt;set column default
      clause&gt; | &lt;drop column default clause&gt; | &lt;alter column data
      type clause&gt; | &lt;alter identity column
      specification&gt;</literal></simpara>

      <simpara>Change a column and its definition.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SET DEFAULT</primary>
      </indexterm>

      <simpara><emphasis role="bold">SET DEFAULT</emphasis></simpara>

      <simpara><emphasis>set column default clause</emphasis></simpara>

      <simpara><literal>&lt;set column default clause&gt; ::= SET &lt;default
      clause&gt;</literal></simpara>

      <simpara>Set the default clause for a column. This can be used if the
      column is not defined as GENERATED.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP DEFAULT (table)</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP DEFAULT</emphasis></simpara>

      <simpara><emphasis>drop column default clause</emphasis></simpara>

      <simpara><literal>&lt;drop column default clause&gt; ::= DROP
      DEFAULT</literal></simpara>

      <simpara>Drop the default clause from a column.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SET DATA TYPE</primary>
      </indexterm>

      <simpara><emphasis role="bold">SET DATA TYPE</emphasis></simpara>

      <simpara><emphasis>alter column data type clause</emphasis></simpara>

      <simpara><literal>&lt;alter column data type clause&gt; ::= SET DATA
      TYPE &lt;data type&gt;</literal></simpara>

      <simpara>Change the declared type of a column. The (proposed) SQL
      Standard allows only changes to type properties such as maximum length,
      precision, or scale, and only changes that cause the property to
      enlarge. HyperSQL allows changing the type if all the existing values
      can be cast into the new type without truncation.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>alter identity column</primary>
      </indexterm>

      <simpara><emphasis role="bold">alter identity
      column</emphasis></simpara>

      <simpara><emphasis>alter identity column
      specification</emphasis></simpara>

      <simpara><literal>&lt;alter identity column specification&gt; ::=
      &lt;alter identity column option&gt;...</literal></simpara>

      <simpara><literal>&lt;alter identity column option&gt; ::= &lt;alter
      sequence generator restart option&gt; | SET &lt;basic sequence generator
      option&gt;</literal></simpara>

      <simpara>Change the properties of an identity column. This command is
      similar to the commands used for changing the properties of named
      SEQUENCE objects discussed in this section.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP COLUMN</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP COLUMN</emphasis></simpara>

      <simpara><emphasis>drop column definition</emphasis></simpara>

      <simpara><literal>&lt;drop column definition&gt; ::= DROP [ COLUMN ]
      &lt;column name&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a column of a base table. The <literal>&lt;drop
      behavior&gt;</literal> is either <literal>RESTRICT</literal> or
      <literal>CASCADE</literal>. If it is not specified,
      <literal>RESTRICT</literal> is implicit. If the column is referenced in
      a table constraint that references other columns as well as this column,
      or if the column is referenced in a VIEW, or the column is referenced in
      a TRIGGER, then the statement will fail if <literal>RESTRICT</literal>
      is specified. If <literal>CASCADE</literal> is specified, then any
      CONSTRAINT, VIEW or TRIGGER object that references the column is dropped
      with a cascading effect.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ADD CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">ADD CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>add table constraint definition</emphasis></simpara>

      <simpara><literal>&lt;add table constraint definition&gt; ::= ADD
      &lt;table constraint definition&gt;</literal></simpara>

      <simpara>Add a constraint to a table. The existing rows of the table
      must conform to the added constraint, otherwise the statement will not
      succeed.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>drop table constraint definition</emphasis></simpara>

      <simpara><literal>&lt;drop table constraint definition&gt; ::= DROP
      CONSTRAINT &lt;constraint name&gt; &lt;drop
      behavior&gt;</literal></simpara>

      <simpara>Destroy a constraint on a table. The <literal>&lt;drop
      behavior&gt;</literal> has an effect only on UNIQUE and PRIMARY KEY
      constraints. If such a constraint is referenced by a FOREIGN KEY
      constraint, the FOREIGN KEY constraint will be dropped if
      <literal>CASCADE</literal> is specified. If the columns of such a
      constraint are used in a GROUP BY clause in the query expression of a
      VIEW or another kind of schema object, and a functional dependency
      relationship exists between these columns and the other columns in that
      query expression, then the VIEW or other schema object will be dropped
      when <literal>CASCADE</literal> is specified.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP TABLE</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP TABLE</emphasis></simpara>

      <simpara><emphasis>drop table statement</emphasis></simpara>

      <simpara><literal>&lt;drop table statement&gt; ::= DROP TABLE &lt;table
      name&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a table. If <literal>&lt;drop behavior&gt;</literal> is
      <literal>CASCADE</literal>, it causes all schema objects that reference
      the table to drop. In the case of constraints that reference the table,
      the constraint is dropped, rather than the TABLE or DOMAIN that contains
      it.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE VIEW</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE VIEW</emphasis></simpara>

      <simpara><emphasis>view definition</emphasis></simpara>

      <simpara><literal>&lt;view definition&gt; ::= CREATE [ RECURSIVE ] VIEW
      &lt;table name&gt; &lt;view specification&gt; AS &lt;query
      expression&gt; [ WITH [ CASCADED | LOCAL ] CHECK OPTION
      ]</literal></simpara>

      <simpara><literal>&lt;view specification&gt; ::= [ &lt;left paren&gt;
      &lt;view column list&gt; &lt;right paren&gt; ]</literal></simpara>

      <simpara><literal>&lt;view column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara>Define a viewed table.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP VIEW</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP VIEW</emphasis></simpara>

      <simpara><emphasis>drop view statement</emphasis></simpara>

      <simpara><literal>&lt;drop view statement&gt; ::= DROP VIEW &lt;table
      name&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a view. The <literal>&lt;drop behavior&gt;</literal> is
      similar to dropping a table.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE DOMAIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE DOMAIN</emphasis></simpara>

      <simpara><emphasis>domain definition</emphasis></simpara>

      <simpara><literal>&lt;domain definition&gt; ::= CREATE DOMAIN &lt;domain
      name&gt; [ AS ] &lt;predefined type&gt; [ &lt;default clause&gt; ] [
      &lt;domain constraint&gt;... ] [ &lt;collate clause&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;domain constraint&gt; ::= [ &lt;constraint name
      definition&gt; ] &lt;check constraint definition&gt; [ &lt;constraint
      characteristics&gt; ]</literal></simpara>

      <simpara>Define a domain. Although a DOMAIN is not a strictly a type in
      the SQL Standard, it can be informally considered as a type. A DOMAIN is
      based on a &lt;predefined type&gt;, which is a base type defined by the
      Standard. It can have a &lt;default clause&gt;, similar to a column
      default clause. It can also have one or more CHECK constraints which
      limit the values that can be assigned to a column or variable that has
      the DOMAIN as its type.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALTER DOMAIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALTER DOMAIN</emphasis></simpara>

      <simpara><emphasis>alter domain statement</emphasis></simpara>

      <simpara><literal>&lt;alter domain statement&gt; ::= ALTER DOMAIN
      &lt;domain name&gt; &lt;alter domain action&gt;</literal></simpara>

      <simpara><literal>&lt;alter domain action&gt; ::= &lt;set domain default
      clause&gt; | &lt;drop domain default clause&gt; | &lt;add domain
      constraint definition&gt; | &lt;drop domain constraint
      definition&gt;</literal></simpara>

      <simpara>Change a domain and its definition.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>SET DOMAIN DEFAULT</primary>
      </indexterm>

      <simpara><emphasis role="bold">SET DEFAULT</emphasis></simpara>

      <simpara><emphasis>set domain default clause</emphasis></simpara>

      <simpara><literal>&lt;set domain default clause&gt; ::= SET &lt;default
      clause&gt;</literal></simpara>

      <simpara>Set the default value in a domain.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP DOMAIN DEFAULT</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP DEFAULT</emphasis></simpara>

      <simpara><emphasis>drop domain default clause</emphasis></simpara>

      <simpara><literal>&lt;drop domain default clause&gt; ::= DROP
      DEFAULT</literal></simpara>

      <simpara>Remove the default clause of a domain.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ADD DOMAIN CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">ADD CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>add domain constraint definition</emphasis></simpara>

      <simpara><literal>&lt;add domain constraint definition&gt; ::= ADD
      &lt;domain constraint&gt;</literal></simpara>

      <simpara>Add a constraint to a domain.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP DOMAIN CONSTRAINT</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP CONSTRAINT</emphasis></simpara>

      <simpara><emphasis>drop domain constraint
      definition</emphasis></simpara>

      <simpara><literal>&lt;drop domain constraint definition&gt; ::= DROP
      CONSTRAINT &lt;constraint name&gt;</literal></simpara>

      <simpara>Destroy a constraint on a domain. If the <literal>&lt;drop
      behavior&gt;</literal> is <literal>CASCADE</literal>, and the constraint
      is a UNIQUE constraint which is referenced by a FOREIGN KEY constraint
      on another table, then the FOREIGN KEY constraint is also
      dropped.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP DOMAIN</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP DOMAIN</emphasis></simpara>

      <simpara><emphasis>drop domain statement</emphasis></simpara>

      <simpara><literal>&lt;drop domain statement&gt; ::= DROP DOMAIN
      &lt;domain name&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a domain. If <literal>&lt;drop behavior&gt;</literal>
      is <literal>CASCADE</literal>, it works differently from most other
      objects. If a table features a column of the specified DOMAIN, the
      column survives and inherits the DEFAULT CLAUSE, and the CHECK
      CONSTRAINT of the DOMAIN.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE CHARACTER SET</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE CHARACTER SET</emphasis></simpara>

      <simpara><emphasis>character set definition</emphasis></simpara>

      <simpara><literal>&lt;character set definition&gt; ::= CREATE CHARACTER
      SET &lt;character set name&gt; [ AS ] &lt;character set source&gt; [
      &lt;collate clause&gt; ]</literal></simpara>

      <simpara><literal>&lt;character set source&gt; ::= GET &lt;character set
      specification&gt;</literal></simpara>

      <simpara>Define a character set. A new CHARACTER SET is based on an
      existing CHARACTER SET. The optional <literal>&lt;collate
      clause&gt;</literal> specifies the collation to be used, otherwise the
      collation is inherited from the default collation for the source
      CHARACTER SET.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP CHARACTER SET</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP CHARACTER SET</emphasis></simpara>

      <simpara><emphasis>drop character set statement</emphasis></simpara>

      <simpara><literal>&lt;drop character set statement&gt; ::= DROP
      CHARACTER SET &lt;character set name&gt;</literal></simpara>

      <simpara>Destroy a character set. If the <literal>&lt;drop
      behavior&gt;</literal> is <literal>CASCADE</literal>, then all
      references to the collation revert to the default collation that would
      be in force if the dropped collation was not specified.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE COLLATION</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE COLLATION</emphasis></simpara>

      <simpara><emphasis>collation definition</emphasis></simpara>

      <simpara><literal>&lt;collation definition&gt; ::= CREATE COLLATION
      &lt;collation name&gt; FOR &lt;character set specification&gt; FROM
      &lt;existing collation name&gt; [ &lt;pad characteristic&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;existing collation name&gt; ::= &lt;collation
      name&gt;</literal></simpara>

      <simpara><literal>&lt;pad characteristic&gt; ::= NO PAD | PAD
      SPACE</literal></simpara>

      <simpara>Define a collation. A new collation is based on an existing
      COLLATION and applies to an existing CHARACTER SET. The <literal>&lt;pad
      characteristic&gt;</literal> specifies whether strings are padded with
      spaces for comparison.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP COLLATION</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP COLLATION</emphasis></simpara>

      <simpara><emphasis>drop collation statement</emphasis></simpara>

      <simpara><literal>&lt;drop collation statement&gt; ::= DROP COLLATION
      &lt;collation name&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a collation. If the <literal>&lt;drop
      behavior&gt;</literal> is <literal>CASCADE</literal>, then all
      references to the collation revert to the default collation that would
      be in force if the dropped collation was not specified.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE TRANSLATION</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE TRANSLATION</emphasis></simpara>

      <simpara><emphasis>transliteration definition</emphasis></simpara>

      <simpara><literal>&lt;transliteration definition&gt; ::= CREATE
      TRANSLATION &lt;transliteration name&gt; FOR &lt;source character set
      specification&gt; TO &lt;target character set specification&gt; FROM
      &lt;transliteration source&gt;</literal></simpara>

      <simpara><literal>&lt;source character set specification&gt; ::=
      &lt;character set specification&gt;</literal></simpara>

      <simpara><literal>&lt;target character set specification&gt; ::=
      &lt;character set specification&gt;</literal></simpara>

      <simpara><literal>&lt;transliteration source&gt; ::= &lt;existing
      transliteration name&gt; | &lt;transliteration
      routine&gt;</literal></simpara>

      <simpara><literal>&lt;existing transliteration name&gt; ::=
      &lt;transliteration name&gt;</literal></simpara>

      <simpara><literal>&lt;transliteration routine&gt; ::= &lt;specific
      routine designator&gt;</literal></simpara>

      <simpara>Define a character transliteration.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP TRANSLATION</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP TRANSLATION</emphasis></simpara>

      <simpara><emphasis>drop transliteration statement</emphasis></simpara>

      <simpara><literal>&lt;drop transliteration statement&gt; ::= DROP
      TRANSLATION &lt;transliteration name&gt;</literal></simpara>

      <simpara>Destroy a character transliteration.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE ASSERTION</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE ASSERTION</emphasis></simpara>

      <simpara><emphasis>assertion definition</emphasis></simpara>

      <simpara><literal>&lt;assertion definition&gt; ::= CREATE ASSERTION
      &lt;constraint name&gt; CHECK &lt;left paren&gt; &lt;search
      condition&gt; &lt;right paren&gt; [ &lt;constraint characteristics&gt;
      ]</literal></simpara>

      <simpara>Specify an integrity constraint.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP ASSERTION</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP ASSERTION</emphasis></simpara>

      <simpara><emphasis>drop assertion statement</emphasis></simpara>

      <simpara><literal>&lt;drop assertion statement&gt; ::= DROP ASSERTION
      &lt;constraint name&gt; [ &lt;drop behavior&gt; ]</literal></simpara>

      <simpara>Destroy an assertion.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE TRIGGER</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE TRIGGER</emphasis></simpara>

      <simpara><emphasis>trigger definition</emphasis></simpara>

      <simpara><literal>&lt;trigger definition&gt; ::= CREATE TRIGGER
      &lt;trigger name&gt; &lt;trigger action time&gt; &lt;trigger event&gt;
      ON &lt;table name&gt; [ REFERENCING &lt;transition table or variable
      list&gt; ] &lt;triggered action&gt;</literal></simpara>

      <simpara><literal>&lt;trigger action time&gt; ::= BEFORE | AFTER |
      INSTEAD OF</literal></simpara>

      <simpara><literal>&lt;trigger event&gt; ::= INSERT | DELETE | UPDATE [
      OF &lt;trigger column list&gt; ]</literal></simpara>

      <simpara><literal>&lt;trigger column list&gt; ::= &lt;column name
      list&gt;</literal></simpara>

      <simpara><literal>&lt;triggered action&gt; ::= [ FOR EACH { ROW |
      STATEMENT } ] [ &lt;triggered when clause&gt; ] &lt;triggered SQL
      statement&gt;</literal></simpara>

      <simpara><literal>&lt;triggered when clause&gt; ::= WHEN &lt;left
      paren&gt; &lt;search condition&gt; &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;triggered SQL statement&gt; ::= &lt;SQL procedure
      statement&gt; | BEGIN ATOMIC { &lt;SQL procedure statement&gt;
      &lt;semicolon&gt; }... END</literal></simpara>

      <simpara><literal>&lt;transition table or variable list&gt; ::=
      &lt;transition table or variable&gt;...</literal></simpara>

      <simpara><literal>&lt;transition table or variable&gt; ::= OLD [ ROW ] [
      AS ] &lt;old transition variable name&gt; | NEW [ ROW ] [ AS ] &lt;new
      transition variable name&gt; | OLD TABLE [ AS ] &lt;old transition table
      name&gt; | NEW TABLE [ AS ] &lt;new transition table
      name&gt;</literal></simpara>

      <simpara><literal>&lt;old transition table name&gt; ::= &lt;transition
      table name&gt;</literal></simpara>

      <simpara><literal>&lt;new transition table name&gt; ::= &lt;transition
      table name&gt;</literal></simpara>

      <simpara><literal>&lt;transition table name&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;old transition variable name&gt; ::=
      &lt;correlation name&gt;</literal></simpara>

      <simpara><literal>&lt;new transition variable name&gt; ::=
      &lt;correlation name&gt;</literal></simpara>

      <simpara>Trigger definition is a relatively complex statement. The
      combination of <literal>&lt;trigger action time&gt;</literal> and
      <literal>&lt;trigger event&gt;</literal> determines the type of the
      trigger. Examples include BEFORE DELETE, AFTER UPDATE, INSTEAD OF
      INSERT. If the optional <literal>[ OF &lt;trigger column list&gt;
      ]</literal> is specified for an UPDATE trigger, then the trigger is
      activated only if one of the columns that is in the <literal>&lt;trigger
      column list&gt;</literal> is specified in the UPDATE statement that
      activates the trigger.</simpara>

      <simpara>If a trigger is <literal>FOR EACH ROW</literal>, which is the
      default option, then the trigger is activated for each row of the table
      that is affected by the execution of an SQL statement. Otherwise, it is
      activated once only per statement execution. In the first case, there is
      a before and after state for each row. For UPDATE triggers, both before
      and after states exist, representing the row before the update, and
      after the update. For DELETE, triggers, there is only a before state.
      For INSERT triggers, there is only an after state. If a trigger is
      <literal>FOR EACH STATEMENT</literal>, then a transient table is created
      containing all the rows for the before state and another transient table
      is created for the after state.</simpara>

      <simpara>The <literal>[ REFERENCING &lt;transition table or variable&gt;
      ]</literal> is used to give a name to the before and after data row or
      table. This name can be referenced in the <literal>&lt;SQL procedure
      statement&gt;</literal> to access the data.</simpara>

      <simpara>The optional <literal>&lt;triggered when clause&gt;</literal>
      is a search condition, similar to the search condition of a DELETE or
      UPDATE statement. If the search condition is not TRUE for a row, then
      the trigger is not activated for that row.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP TRIGGER</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP TRIGGER</emphasis></simpara>

      <simpara><emphasis>drop trigger statement</emphasis></simpara>

      <simpara><literal>&lt;drop trigger statement&gt; ::= DROP TRIGGER
      &lt;trigger name&gt;</literal></simpara>

      <simpara>Destroy a trigger.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE TYPE</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE TYPE</emphasis></simpara>

      <simpara><emphasis>user-defined type definition</emphasis></simpara>

      <simpara><literal>&lt;user-defined type definition&gt; ::= CREATE TYPE
      &lt;user-defined type body&gt;</literal></simpara>

      <simpara><literal>&lt;user-defined type body&gt; ::= &lt;schema-resolved
      user-defined type name&gt; [ AS &lt;representation&gt; ] [
      &lt;user-defined type option list&gt; ] [ &lt;method specification
      list&gt; ]</literal></simpara>

      <simpara><literal>&lt;user-defined type option list&gt; ::=
      &lt;user-defined type option&gt; [ &lt;user-defined type option&gt;...
      ]</literal></simpara>

      <simpara><literal>&lt;user-defined type option&gt; ::= &lt;instantiable
      clause&gt; | &lt;finality&gt; | &lt;reference type specification&gt; |
      &lt;cast to ref&gt; | &lt;cast to type&gt; | &lt;cast to distinct&gt; |
      &lt;cast to source&gt;</literal></simpara>

      <simpara><literal>&lt;representation&gt; ::= &lt;predefined
      type&gt;</literal></simpara>

      <simpara><literal>&lt;instantiable clause&gt; ::= INSTANTIABLE | NOT
      INSTANTIABLE</literal></simpara>

      <simpara><literal>&lt;finality&gt; ::= FINAL | NOT
      FINAL</literal></simpara>

      <simpara><literal>* &lt;reference type specification&gt; ::=
      &lt;user-defined representation&gt; | &lt;derived representation&gt; |
      &lt;system-generated representation&gt;</literal></simpara>

      <simpara><literal>&lt;user-defined representation&gt; ::= REF USING
      &lt;predefined type&gt;</literal></simpara>

      <simpara><literal>&lt;derived representation&gt; ::= REF FROM &lt;list
      of attributes&gt;</literal></simpara>

      <simpara><literal>&lt;system-generated representation&gt; ::= REF IS
      SYSTEM GENERATED</literal></simpara>

      <simpara><literal>&lt;cast to ref&gt; ::= CAST &lt;left paren&gt; SOURCE
      AS REF &lt;right paren&gt; WITH &lt;cast to ref
      identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to ref identifier&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to type&gt; ::= CAST &lt;left paren&gt; REF
      AS SOURCE &lt;right paren&gt; WITH &lt;cast to type
      identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to type identifier&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;list of attributes&gt; ::= &lt;left paren&gt;
      &lt;attribute name&gt; [ { &lt;comma&gt; &lt;attribute name&gt; }... ]
      &lt;right paren&gt;</literal></simpara>

      <simpara><literal>&lt;cast to distinct&gt; ::= CAST &lt;left paren&gt;
      SOURCE AS DISTINCT &lt;right paren&gt; WITH &lt;cast to distinct
      identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to distinct identifier&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to source&gt; ::= CAST &lt;left paren&gt;
      DISTINCT AS SOURCE &lt;right paren&gt; WITH &lt;cast to source
      identifier&gt;</literal></simpara>

      <simpara><literal>&lt;cast to source identifier&gt; ::=
      &lt;identifier&gt;</literal></simpara>

      <simpara><literal>&lt;method specification list&gt; ::= &lt;method
      specification&gt; [ { &lt;comma&gt; &lt;method specification&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;method specification&gt; ::= &lt;original method
      specification&gt; | &lt;overriding method
      specification&gt;</literal></simpara>

      <simpara><literal>&lt;original method specification&gt; ::= &lt;partial
      method specification&gt; [ SELF AS RESULT ] [ SELF AS LOCATOR ] [
      &lt;method characteristics&gt; ]</literal></simpara>

      <simpara><literal>&lt;overriding method specification&gt; ::= OVERRIDING
      &lt;partial method specification&gt;</literal></simpara>

      <simpara><literal>&lt;partial method specification&gt; ::= [ INSTANCE |
      STATIC | CONSTRUCTOR ] METHOD &lt;method name&gt; &lt;SQL parameter
      declaration list&gt; &lt;returns clause&gt; [ SPECIFIC &lt;specific
      method name&gt; ]</literal></simpara>

      <simpara><literal>&lt;specific method name&gt; ::= [ &lt;schema name&gt;
      &lt;period&gt; ]&lt;qualified identifier&gt;</literal></simpara>

      <simpara><literal>&lt;method characteristics&gt; ::= &lt;method
      characteristic&gt;...</literal></simpara>

      <simpara><literal>&lt;method characteristic&gt; ::= &lt;language
      clause&gt; | &lt;parameter style clause&gt; | &lt;deterministic
      characteristic&gt; | &lt;SQL-data access indication&gt; | &lt;null-call
      clause&gt;</literal></simpara>

      <simpara>Define a user-defined type. Currently only simple distinct
      types can be define without further attributes.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>schema routine</primary>
      </indexterm>

      <simpara><emphasis role="bold">schema routine</emphasis></simpara>

      <simpara><emphasis>SQL-invoked routine</emphasis></simpara>

      <simpara><literal>&lt;SQL-invoked routine&gt; ::= &lt;schema
      routine&gt;</literal></simpara>

      <simpara><literal>&lt;schema routine&gt; ::= &lt;schema procedure&gt; |
      &lt;schema function&gt;</literal></simpara>

      <simpara><literal>&lt;schema procedure&gt; ::= CREATE &lt;SQL-invoked
      procedure&gt;</literal></simpara>

      <simpara><literal>&lt;schema function&gt; ::= CREATE &lt;SQL-invoked
      function&gt;</literal></simpara>

      <simpara><literal>&lt;SQL-invoked procedure&gt; ::= PROCEDURE &lt;schema
      qualified routine name&gt; &lt;SQL parameter declaration list&gt;
      &lt;routine characteristics&gt; &lt;routine body&gt;</literal></simpara>

      <simpara><literal>&lt;SQL-invoked function&gt; ::= { &lt;function
      specification&gt; | &lt;method specification designator&gt; }
      &lt;routine body&gt;</literal></simpara>

      <simpara><literal>&lt;SQL parameter declaration list&gt; ::= &lt;left
      paren&gt; [ &lt;SQL parameter declaration&gt; [ { &lt;comma&gt; &lt;SQL
      parameter declaration&gt; }... ] ] &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;SQL parameter declaration&gt; ::= [ &lt;parameter
      mode&gt; ] [ &lt;SQL parameter name&gt; ] &lt;parameter type&gt; [
      RESULT ]</literal></simpara>

      <simpara><literal>&lt;parameter mode&gt; ::= IN | OUT |
      INOUT</literal></simpara>

      <simpara><literal>&lt;parameter type&gt; ::= &lt;data type&gt; [
      &lt;locator indication&gt; ]</literal></simpara>

      <simpara><literal>&lt;locator indication&gt; ::= AS
      LOCATOR</literal></simpara>

      <simpara><literal>&lt;function specification&gt; ::= FUNCTION &lt;schema
      qualified routine name&gt; &lt;SQL parameter declaration list&gt;
      &lt;returns clause&gt; &lt;routine characteristics&gt; [ &lt;dispatch
      clause&gt; ]</literal></simpara>

      <simpara><literal>&lt;method specification designator&gt; ::= SPECIFIC
      METHOD &lt;specific method name&gt; | [ INSTANCE | STATIC | CONSTRUCTOR
      ] METHOD &lt;method name&gt; &lt;SQL parameter declaration list&gt; [
      &lt;returns clause&gt; ] FOR &lt;schema-resolved user-defined type
      name&gt;</literal></simpara>

      <simpara><literal>&lt;routine characteristics&gt; ::= [ &lt;routine
      characteristic&gt;... ]</literal></simpara>

      <simpara><literal>&lt;routine characteristic&gt; ::= &lt;language
      clause&gt; | &lt;parameter style clause&gt; | SPECIFIC &lt;specific
      name&gt; | &lt;deterministic characteristic&gt; | &lt;SQL-data access
      indication&gt; | &lt;null-call clause&gt; | &lt;returned result sets
      characteristic&gt; | &lt;savepoint level
      indication&gt;</literal></simpara>

      <simpara><literal>&lt;savepoint level indication&gt; ::= NEW SAVEPOINT
      LEVEL | OLD SAVEPOINT LEVEL</literal></simpara>

      <simpara><literal>&lt;returned result sets characteristic&gt; ::=
      DYNAMIC RESULT SETS &lt;maximum returned result
      sets&gt;</literal></simpara>

      <simpara><literal>&lt;parameter style clause&gt; ::= PARAMETER STYLE
      &lt;parameter style&gt;</literal></simpara>

      <simpara><literal>&lt;dispatch clause&gt; ::= STATIC
      DISPATCH</literal></simpara>

      <simpara><literal>&lt;returns clause&gt; ::= RETURNS &lt;returns
      type&gt;</literal></simpara>

      <simpara><literal>&lt;returns type&gt; ::= &lt;returns data type&gt; [
      &lt;result cast&gt; ] | &lt;returns table type&gt;</literal></simpara>

      <simpara><literal>&lt;returns table type&gt; ::= TABLE &lt;table
      function column list&gt;</literal></simpara>

      <simpara><literal>&lt;table function column list&gt; ::= &lt;left
      paren&gt; &lt;table function column list element&gt; [ { &lt;comma&gt;
      &lt;table function column list element&gt; }... ] &lt;right
      paren&gt;</literal></simpara>

      <simpara><literal>&lt;table function column list element&gt; ::=
      &lt;column name&gt; &lt;data type&gt;</literal></simpara>

      <simpara><literal>&lt;result cast&gt; ::= CAST FROM &lt;result cast from
      type&gt;</literal></simpara>

      <simpara><literal>&lt;result cast from type&gt; ::= &lt;data type&gt; [
      &lt;locator indication&gt; ]</literal></simpara>

      <simpara><literal>&lt;returns data type&gt; ::= &lt;data type&gt; [
      &lt;locator indication&gt; ]</literal></simpara>

      <simpara><literal>&lt;routine body&gt; ::= &lt;SQL routine spec&gt; |
      &lt;external body reference&gt;</literal></simpara>

      <simpara><literal>&lt;SQL routine spec&gt; ::= [ &lt;rights clause&gt; ]
      &lt;SQL routine body&gt;</literal></simpara>

      <simpara><literal>&lt;rights clause&gt; ::= SQL SECURITY INVOKER | SQL
      SECURITY DEFINER</literal></simpara>

      <simpara><literal>&lt;SQL routine body&gt; ::= &lt;SQL procedure
      statement&gt;</literal></simpara>

      <simpara><literal>&lt;external body reference&gt; ::= EXTERNAL [ NAME
      &lt;external routine name&gt; ] [ &lt;parameter style clause&gt; ] [
      &lt;transform group specification&gt; ] [ &lt;external security
      clause&gt; ]</literal></simpara>

      <simpara><literal>&lt;external security clause&gt; ::= EXTERNAL SECURITY
      DEFINER | EXTERNAL SECURITY INVOKER | EXTERNAL SECURITY IMPLEMENTATION
      DEFINED</literal></simpara>

      <simpara><literal>&lt;parameter style&gt; ::= SQL |
      GENERAL</literal></simpara>

      <simpara><literal>&lt;deterministic characteristic&gt; ::= DETERMINISTIC
      | NOT DETERMINISTIC</literal></simpara>

      <simpara><literal>&lt;SQL-data access indication&gt; ::= NO SQL |
      CONTAINS SQL | READS SQL DATA | MODIFIES SQL DATA</literal></simpara>

      <simpara><literal>&lt;null-call clause&gt; ::= RETURNS NULL ON NULL
      INPUT | CALLED ON NULL INPUT</literal></simpara>

      <simpara><literal>&lt;maximum returned result sets&gt; ::= &lt;unsigned
      integer&gt;</literal></simpara>

      <simpara><literal>&lt;transform group specification&gt; ::= TRANSFORM
      GROUP { &lt;single group specification&gt; | &lt;multiple group
      specification&gt; }</literal></simpara>

      <simpara><literal>&lt;single group specification&gt; ::= &lt;group
      name&gt;</literal></simpara>

      <simpara><literal>&lt;multiple group specification&gt; ::= &lt;group
      specification&gt; [ { &lt;comma&gt; &lt;group specification&gt; }...
      ]</literal></simpara>

      <simpara><literal>&lt;group specification&gt; ::= &lt;group name&gt; FOR
      TYPE &lt;path-resolved user-defined type name&gt;</literal></simpara>

      <simpara>Define an SQL-invoked routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALTER routine</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALTER routine</emphasis></simpara>

      <simpara><emphasis>alter routine statement</emphasis></simpara>

      <simpara><literal>&lt;alter routine statement&gt; ::= ALTER &lt;specific
      routine designator&gt; &lt;alter routine characteristics&gt; &lt;alter
      routine behavior&gt;</literal></simpara>

      <simpara><literal>&lt;alter routine characteristics&gt; ::= &lt;alter
      routine characteristic&gt;...</literal></simpara>

      <simpara><literal>&lt;alter routine characteristic&gt; ::= &lt;language
      clause&gt; | &lt;parameter style clause&gt; | &lt;SQL-data access
      indication&gt; | &lt;null-call clause&gt; | &lt;returned result sets
      characteristic&gt; | NAME &lt;external routine
      name&gt;</literal></simpara>

      <simpara><literal>&lt;alter routine behavior&gt; ::=
      RESTRICT</literal></simpara>

      <simpara>Alter a characteristic of an SQL-invoked routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP routine</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP</emphasis></simpara>

      <simpara><emphasis>drop routine statement</emphasis></simpara>

      <simpara><literal>&lt;drop routine statement&gt; ::= DROP &lt;specific
      routine designator&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy an SQL-invoked routine.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE CAST</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE CAST</emphasis></simpara>

      <simpara><emphasis>user-defined cast definition</emphasis></simpara>

      <simpara><literal>&lt;user-defined cast definition&gt; ::= CREATE CAST
      &lt;left paren&gt; &lt;source data type&gt; AS &lt;target data type&gt;
      &lt;right paren&gt; WITH &lt;cast function&gt; [ AS ASSIGNMENT
      ]</literal></simpara>

      <simpara><literal>&lt;cast function&gt; ::= &lt;specific routine
      designator&gt;</literal></simpara>

      <simpara><literal>&lt;source data type&gt; ::= &lt;data
      type&gt;</literal></simpara>

      <simpara><literal>&lt;target data type&gt; ::= &lt;data
      type&gt;</literal></simpara>

      <simpara>Define a user-defined cast.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP CAST</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP CAST</emphasis></simpara>

      <simpara><emphasis>drop user-defined cast statement</emphasis></simpara>

      <simpara><literal>&lt;drop user-defined cast statement&gt; ::= DROP CAST
      &lt;left paren&gt; &lt;source data type&gt; AS &lt;target data type&gt;
      &lt;right paren&gt; &lt;drop behavior&gt;</literal></simpara>

      <simpara>Destroy a user-defined cast.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>CREATE SEQUENCE</primary>
      </indexterm>

      <simpara><emphasis role="bold">CREATE SEQUENCE</emphasis></simpara>

      <simpara><emphasis>sequence generator definition</emphasis></simpara>

      <simpara><literal>&lt;sequence generator definition&gt; ::= CREATE
      SEQUENCE &lt;sequence generator name&gt; [ &lt;sequence generator
      options&gt; ]</literal></simpara>

      <simpara><literal>&lt;sequence generator options&gt; ::= &lt;sequence
      generator option&gt; ...</literal></simpara>

      <simpara><literal>&lt;sequence generator option&gt; ::= &lt;sequence
      generator data type option&gt; | &lt;common sequence generator
      options&gt;</literal></simpara>

      <simpara><literal>&lt;common sequence generator options&gt; ::=
      &lt;common sequence generator option&gt; ...</literal></simpara>

      <simpara><literal>&lt;common sequence generator option&gt; ::=
      &lt;sequence generator start with option&gt; | &lt;basic sequence
      generator option&gt;</literal></simpara>

      <simpara><literal>&lt;basic sequence generator option&gt; ::=
      &lt;sequence generator increment by option&gt; | &lt;sequence generator
      maxvalue option&gt; | &lt;sequence generator minvalue option&gt; |
      &lt;sequence generator cycle option&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator data type option&gt; ::= AS
      &lt;data type&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator start with option&gt; ::= START
      WITH &lt;sequence generator start value&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator start value&gt; ::= &lt;signed
      numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator increment by option&gt; ::=
      INCREMENT BY &lt;sequence generator increment&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator increment&gt; ::= &lt;signed
      numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator maxvalue option&gt; ::=
      MAXVALUE &lt;sequence generator max value&gt; | NO
      MAXVALUE</literal></simpara>

      <simpara><literal>&lt;sequence generator max value&gt; ::= &lt;signed
      numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator minvalue option&gt; ::=
      MINVALUE &lt;sequence generator min value&gt; | NO
      MINVALUE</literal></simpara>

      <simpara><literal>&lt;sequence generator min value&gt; ::= &lt;signed
      numeric literal&gt;</literal></simpara>

      <simpara><literal>&lt;sequence generator cycle option&gt; ::= CYCLE | NO
      CYCLE</literal></simpara>

      <simpara>Define a named sequence generator. A SEQUENCE object generates
      a sequence of integers according to the specified rules. The simple
      definition without the options defines a sequence of numbers in INTEGER
      type starting at 1 and incrementing by 1. By default the
      <literal>CYCLE</literal> property is set and the minimum and maximum
      limits are the minimum and maximum limits of the type of returned
      values. There are self-explanatory options for changing various
      properties of the sequence. The <literal>MAXVALUE</literal> and
      <literal>MINVALUE</literal> specify the upper and lower limits. If
      <literal>CYCLE</literal> is specified, after the sequence returns the
      highest or lowest value in range, the next value will respectively be
      the lowest or highest value in range. If <literal>NO CYCLE</literal> is
      specified, the use of the sequence generator results in an error once
      the limit has been reached.</simpara>

      <simpara>The integer types: SMALLINT, INTEGER, BIGINT, DECIMAL and
      NUMERIC can be used as the type of the sequence. DECIMAL and NUMERIC
      types should be specified with a scale of 0 and a precision not
      exceeding 18.</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>ALTER SEQUENCE</primary>
      </indexterm>

      <simpara><emphasis role="bold">ALTER SEQUENCE</emphasis></simpara>

      <simpara><emphasis>alter sequence generator
      statement</emphasis></simpara>

      <simpara><literal>&lt;alter sequence generator statement&gt; ::= ALTER
      SEQUENCE &lt;sequence generator name&gt; &lt;alter sequence generator
      options&gt;</literal></simpara>

      <simpara><literal>&lt;alter sequence generator options&gt; ::= &lt;alter
      sequence generator option&gt;...</literal></simpara>

      <simpara><literal>&lt;alter sequence generator option&gt; ::= &lt;alter
      sequence generator restart option&gt; | &lt;basic sequence generator
      option&gt;</literal></simpara>

      <simpara><literal>&lt;alter sequence generator restart option&gt; ::=
      RESTART [ WITH &lt;sequence generator restart value&gt;
      ]</literal></simpara>

      <simpara><literal>&lt;sequence generator restart value&gt; ::=
      &lt;signed numeric literal&gt;</literal></simpara>

      <simpara>Change the definition of an named sequence generator. The same
      options that are used in the definition of the SEQUENCE can be used to
      alter it. The exception is the option for the start value which is
      <literal>RESTART WITH</literal> for the ALTER SEQUENCE
      statement..</simpara>

      <indexterm significance="preferred" type="sql">
        <primary>DROP SEQUENCE</primary>
      </indexterm>

      <simpara><emphasis role="bold">DROP SEQUENCE</emphasis></simpara>

      <simpara><emphasis>drop sequence generator
      statement</emphasis></simpara>

      <simpara><literal>&lt;drop sequence generator statement&gt; ::= DROP
      SEQUENCE &lt;sequence generator name&gt; &lt;drop
      behavior&gt;</literal></simpara>

      <simpara>Destroy an external sequence generator. If the
      <literal>&lt;drop behavior&gt;</literal> is <literal>CASCADE</literal>,
      then all objects that reference the sequence are dropped. These objects
      can be VIEW, ROUTINE or TRIGGER objects.</simpara>

      <!-- From Foundation chapt. 13 -->

      <indexterm significance="preferred" type="sql">
        <primary>SQL executable statement</primary>
      </indexterm>

      <simpara><emphasis role="bold">SQL executable
      statement</emphasis></simpara>

      <simpara><emphasis>SQL procedure statement</emphasis></simpara>

      <simpara><literal>&lt;SQL procedure statement&gt; ::= &lt;SQL executable
      statement&gt;</literal></simpara>

      <simpara><literal>&lt;SQL executable statement&gt; ::= &lt;SQL schema
      statement&gt; | &lt;SQL data statement&gt; | &lt;SQL control
      statement&gt; | &lt;SQL transaction statement&gt; | &lt;SQL connection
      statement&gt; | &lt;SQL session statement&gt; | &lt;SQL diagnostics
      statement&gt; | &lt;SQL dynamic statement&gt;</literal></simpara>

      <simpara><literal>&lt;SQL schema statement&gt; ::= &lt;SQL schema
      definition statement&gt; | &lt;SQL schema manipulation
      statement&gt;</literal></simpara>

      <simpara><literal>&lt;SQL schema definition statement&gt; ::= &lt;schema
      definition&gt; | &lt;table definition&gt; | &lt;view definition&gt; |
      &lt;SQL-invoked routine&gt; | &lt;grant statement&gt; | &lt;role
      definition&gt; | &lt;domain definition&gt; | &lt;character set
      definition&gt; | &lt;collation definition&gt; | &lt;transliteration
      definition&gt; | &lt;assertion definition&gt; | &lt;trigger
      definition&gt; | &lt;user-defined type definition&gt; | &lt;user-defined
      cast definition&gt; | &lt;user-defined ordering definition&gt; |
      &lt;transform definition&gt; | &lt;sequence generator
      definition&gt;</literal></simpara>

      <simpara><literal>&lt;SQL schema manipulation statement&gt; ::= &lt;drop
      schema statement&gt; | &lt;alter table statement&gt; | &lt;drop table
      statement&gt; | &lt;drop view statement&gt; | &lt;alter routine
      statement&gt; | &lt;drop routine statement&gt; | &lt;drop user-defined
      cast statement&gt; | &lt;revoke statement&gt; | &lt;drop role
      statement&gt; | &lt;alter domain statement&gt; | &lt;drop domain
      statement&gt; | &lt;drop character set statement&gt; | &lt;drop
      collation statement&gt; | &lt;drop transliteration statement&gt; |
      &lt;drop assertion statement&gt; | &lt;drop trigger statement&gt; |
      &lt;alter type statement&gt; | &lt;drop data type statement&gt; |
      &lt;drop user-defined ordering statement&gt; | &lt;alter transform
      statement&gt; | &lt;drop transform statement&gt; | &lt;alter sequence
      generator statement&gt; | &lt;drop sequence generator
      statement&gt;</literal></simpara>
    </section>
  </section>

  <section>
    <title>The Information Schema</title>

    <para>The Information Schema is a special schema in each catalog. The SQL
    Standard defines a number of character sets and domains. In addition, all
    the implementation-defined collations belong to Information Schema</para>

    <section>
      <title>Predefined Character Sets, Collations and Domains</title>

      <para>The SQL Standard defines a number of character sets and domains in
      the INFORMATION SCHEMA. The</para>
    </section>

    <section>
      <title>Views in INFORMATION SCHEMA</title>

      <para></para>
    </section>
  </section>
</chapter>
