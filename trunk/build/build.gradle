defaultTasks 'help'

/*
 * The only end-user Gradle build properties used at this time are:
 *     retain.gradleds  Set to 'true' to retain the temporary files
 *                      "build-gradled.xml", "build-docbook-gradled.xml"
 *                      in the parent (real project root) directory.
 *     allTasks   Used only by the 'tasks' target.  Setting this to 'true' is
 *                equivalent to the tas-specific switch '--all' for the
 *                out-of-the-box 'tasks' target.  I.e., our
 *                'gradlew -PallTasks=true tasks'
 *                emulates out-of-the-box 'gradlew tasks --all'.
 * All other build properties are loaded indirectly by Ant, so you must use
 * Gradle's -D switch to set those Ant properties as Java system properties.
 */

project['repos.flatdir.url'] = 'http://pub.admc.com/lib-repos'
apply from: 'common.gradle'

task nichts  // Quiet task for testing root-level Groovy/Gradle development
nichts.description = 'Noop for testing Gradle'

// This task only for SCM administrator.  Update version and execute this task.
task updateWrapper(type: Wrapper) << {
    if (!project.hasProperty('newVersion'))
        throw new InvalidUserDataException(
                "Property 'newVersion' is required for task 'updateWrapper'")
    gradleVersion = project['newVersion']
}
updateWrapper.description = 'Update Gradle version.  For HSQLDB Administrators.'

/*
task serialver << {
    if (!project.hasProperty('className'))
        throw new InvalidUserDataException(
                "Property 'className' is required for task 'serialver'")

    String pathSep = System.properties['path.separator']
    // Could alternatively use Gradle's ExecSpec via exec(...)
    Process process = new ProcessBuilder([
        // 'D:\\progra~1\\portableGit-1.7.3.1-p\\bin\\ls',
        'serialver',
        '-classpath',
        ('classes' + pathSep + configurations.runtime.files.join(pathSep)
                + pathSep + configurations.compile.files.join(pathSep))
        ,
        project.property('className')
    ]).redirectErrorStream(true).start()
    // Must read input before waitFor-ing
    process.inputStream.eachLine { println it }
    process.waitFor()
    if (process.exitValue()) {
        //print process.inputStream.text
        throw new GradleException("'serialver' execution failed")
    }
}
serialver.description = "Generates Java serialversion for specified 'classname'"
*/

void resolveCheck(configName) {
    int artCount = configurations[configName].files.size()
    // Following test works only if deps' transitive is false.
    if (configurations[configName].allDependencies.size() != artCount) {
        logger.error(
                "Didn't resolve all dependencies for config '$configName'.  "
                + configurations[configName].allDependencies.size()
                + ' dependencies:\n    ' + configurations[configName]
                .allDependencies .collect({it.name}).join('\n    ')
                + '\nbut ' + artCount 
                + ' resolved artifacts:\n    '
                + configurations[configName].files.collect({it}).join('\n    ')
                + '\n'
        )
        throw new GradleException("Didn't resolve all dependencies.")
    }
    //configurations[configName].files.each { println '+' + it }
    //throw new GradleException("Quittin' early")
    logger.info(artCount + ' artifacts resolved')
}

/*  This task will become useful for native Gradle compilations
compileJava.dependsOn << {
    if (!project.hasProperty('resolveCheck.skip')
            || !Boolean.parseBoolean(project.property('resolveCheck.skip')))
        resolveCheck('compile')
}
*/

// Blaine wants to use a variant of the following to check for tabs in
// SqlTool's properties and *.txt files.
/*  X's inserted below or this multi-line comment would not work.
task checkTabs (dependsOn: war) << {
    FileTree tree = fileTree(dir: '.')
    tree.exclude '**X/.*'
    tree.exclude 'src/main/webapp/images'
    tree.exclude 'src/main/webapp/css/openid*.css'
    tree.exclude 'src/main/webapp/js/openid*.js'
    tree.include  'src/X**'
    tree.include  'doc/X**'
    def tabFiles = []
    tree.each { if (it.text.indexOf('\t') > -1) tabFiles << relativePath(it) }
    if (tabFiles.size() > 0) println '  ' + tabFiles.join('\n  ')
}
*/

import java.util.regex.Pattern
import java.util.regex.Matcher
import groovy.xml.XmlUtil
import groovy.xml.StreamingMarkupBuilder

private void recursivePush(newName, dli, msl, ips) {
    if (msl.contains(newName))
        throw new GradleException("Recursion duplication for target '$newName'")
    if (ips.contains(newName))
        throw new GradleException("Recursion cycle for target '$newName'")
    ips.add(0, newName)
    for (superEl in dli)
        if (superEl.contains(newName))
            for (subEl in superEl) {
                if (subEl == newName) break
                if (ips.contains(subEl))
                    throw new GradleException(
                            "Dependency cycle exists for target '$subEl'")
                if (!msl.contains(subEl)) // Recurse
                    recursivePush(subEl, dli, msl, ips)
            }
        //for (i = 0 .. superEl.size()-1)
    msl.add(newName)
    if (ips.remove(0) != newName)
        throw new GradleException('Internal IPS stack problem')
}

/**
 * @param fileNameInsertion.
 *        For translating input filenames to new output files.
 * @closures Will call thse with param of the corresponding Slurped XML
 *           (same number of elements as number of input files).
 *           Null to not do anything with it.
 */
File[] resequenceAntDependencies(String fileNameInsertion, closures, inFiles) {
    def xmls = []
    for (File f in inFiles)
        xmls << new XmlSlurper().parseText(f.getText("UTF-8"))
    def targetsIn = [:]      // name -> Target.  Those CONTAINING multi-depends.
    def dependListsIn = [:]  // name -> List<String>
    def inProcessStack = []  // For cycle checking
    def masterSeqList = []   // Sequential list of all ref'd targ names

    // 1:  Determine new sequence 'masterSeqList'
    for (xml in xmls) for (targ in xml.target.findAll{
        it.@depends != null && it.@depends.list().size() > 0}) {
            def listEls = Arrays.asList(targ.@depends.text().split("\\s*,\\s*"))
            if (listEls.size() > 0 && listEls[0].size() < 1) listEls.remove(0)
            if (listEls.size() < 2) continue  // No precedence if 1:1 dep.
            targetsIn[targ.@name.text()] = targ
            dependListsIn[targ.@name.text()] = listEls
        }
    logger.debug(targetsIn.size()
            + " name->Target's (just keys): " + targetsIn.keySet())
    logger.debug(dependListsIn.size() + " name->List's: " + dependListsIn)

    for (dl in dependListsIn.values())
        for (n in dl)
            if (!masterSeqList.contains(n))
                recursivePush(n,
                        dependListsIn.values(), masterSeqList, inProcessStack)
    logger.debug('RESULT:  ' + masterSeqList)

    // 2: Generate task-renaming map 'renameMap'
    //    and ouput dep lists 'dependListsOut'
    // Purposefully not declaring 'renameMap'
    // so it will make project.renameMap so we can share it.
    renameMap = [:]       // String -> String
    def dependListsOut = [:]  // name -> List<String>
    def outList               // Strings

    for (n in masterSeqList)
        renameMap[n] = String.format("%03d%s", renameMap.size() + 1, n);
    for (e in dependListsIn) {
        outList = []
        dependListsOut[e.key] = outList;
        for (n in e.value)
            outList << (renameMap.containsKey(n) ? renameMap[n] : n)
    }
    logger.info('renameMap: ' + renameMap)

    // 3: Modify Ant build file text
    // Update 'target' attrs, target name attrs, target depends attrs
    for (e in targetsIn)
        e.value.@depends = dependListsOut[e.key].join(', ')
    for (xml in xmls) {
        for (targ in xml.depthFirst().findAll{ it.@target.list().size() > 0 })
            if (renameMap.containsKey(targ.@target.text()))
                // { logger.debug("Trying " + targ.@target.text())
                targ.@target = renameMap.get(targ.@target.text())
        for (e in renameMap) {
            xml.target.find{it.@name.text() == e.key}.@name = e.value;
            // Following is for depends that did not contribute to sequencing,
            // but which still contain mapped target names.
            xml.target.findAll{it.@depends.text() == e.key}.@depends = e.value;
        }
    }

    // 3.5: Conditionally execute user-specified closures
    if (closures != null) {
        if (closures.size() != xmls.size())
            throw new GradleException(
                    'Size of given xmls != size of closures: '
                    + xmls.size() + ' vs. ' + closures.size())
        for (i in 0.. closures.size()-1)
            if (closures[i] != null) closures[i](xmls[i])
    }

    // 4: Write modified Ant build file
    List<File> outFiles = []
    File outFile
    Pattern dotPattern = Pattern.compile("\\.");
    for (i in 0 .. xmls.size()-1) {
        if (inFiles[i].name.indexOf('.') < 0)
            throw new GradleException(
                    "Input file name has no extension:  " + inFiles[i].name)
        outFile = new File(
                ((project.hasProperty('resequence.destDir'))
                        ? project['resequence.destDir']
                        : inFiles[i].getParentFile()),
                dotPattern.matcher(inFiles[i].getName()).replaceFirst(
                fileNameInsertion + '.'))
        outFiles << outFile
        logger.info("Writing '" + outFile.absolutePath + "'")
        outFile.write(XmlUtil.serialize(
            new StreamingMarkupBuilder().bind{mkp.yield xmls[i]}), "UTF-8")
    }
    return outFiles
}

// RESEQUENCE
project['resequence.destDir'] = file('..')
// The top-level entry Build file must be first!!!
sourceAntBuildFiles = [file('build.xml'), file('build-docbook.xml')]
if (project.hasProperty('addlAntBuildFiles'))
    sourceAntBuildFiles = addlAntBuildFiles + sourceAntBuildFiles 
//throw new GradleException(sourceAntBuildFiles.join(','))

antBuildClosures = [{
        it.import.find{it.@file = 'build-docbook-gradled.xml'}
        it.@name = it.@name.text() + "_gradled"
        it.attributes().remove("basedir")
    }, {
        it.@name = it.@name.text() + "_gradled"
        it.import.replaceNode {}
        // Global var because needed for our replacement task definition below
        ivySetupTaskName = '-ivy-setup'
        if (project.renameMap.containsKey(ivySetupTaskName))
                ivySetupTaskName = project.renameMap.get(ivySetupTaskName)
        it.appendNode { target(name: ivySetupTaskName) }
    }
]
if (project.hasProperty('addlAntBuildClosures'))
    antBuildClosures = addlAntBuildClosures + antBuildClosures

File[] outFs = resequenceAntDependencies(
        '-gradled', antBuildClosures, sourceAntBuildFiles)

ant.importBuild(outFs[0].absolutePath)
if (!project.hasProperty('retain.gradleds')
        || !Boolean.parseBoolean(project.property('retain.gradleds')))
    for (f in outFs) f.deleteOnExit()
version = ant.properties['hsqldb.version']  // Inherit version from "build.xml"

// This block generates wrapper tasks for the sole purpose of preventing the
// end user from seeing numbered task names.
Pattern candidatePattern = Pattern.compile("^\\d{3}([^-.][^.]*)\$");
Matcher m;
def hidingWrappers = [:]
Task newTask
for (t in getTasks()) {
    if (t.description == null) continue;
    m = candidatePattern.matcher(t.name);
    if (!m.matches()) continue;
    newTask = project.task(m.group(1))
    newTask.dependsOn = [t]
    newTask.description = t.description
    hidingWrappers[t] = newTask
}
apply from: 'ivy-setup.gradle'

import org.apache.tools.ant.types.Path
project.task([overwrite: true], ivySetupTaskName) << {
    ant.references['admc-rs-msv-jar.cpref'] =
            new Path(ant.project, configurations['admc-rs-msv-jar'].asPath)
    ant.references['admc-rs-msv-deps.cpref'] =
            new Path(ant.project, configurations['admc-rs-msv-deps'].asPath)
    ant.references['fop.cpref'] =
            new Path(ant.project, configurations['fop'].asPath)
    ant.references['xalan.cpref'] =
            new Path(ant.project, configurations['xalan'].asPath)
}


private def recursiveAggregator(additions, inMap, assemblage) {
    for (addition in additions) if (!assemblage.contains(addition)) {
        recursiveAggregator(inMap[addition], inMap, assemblage)
        assemblage << addition
    }
    return assemblage
}

/**
 *
 * Override both the Gradle out-of-the-box 'help' task, as well as our HSQLDB
 * Ant 'help' target, because the latter is very Ant-specific.
 * To get the both of both worlds, we combine the output of Gradle's OOTB
 * 'help' with Gradle-translated output of our Ant 'help' target.
 */
task help(overwrite:true) << {
    String antVer = ant.properties['ant.version']
            .replaceFirst("^[^\\d]*(\\d\\S+).*\$", "\$1")
    print """
Welcome to Gradle $gradle.gradleVersion.  (Wrapping Ant $antVer).

To run a build, run 'gradle <task> ...'

To see a list of available tasks, run 'gradle tasks'.
Add switch -q to make Gradle run quieter, or -i -s to run louder
(or -d -S for very loud).

    
Usage:
   gradlew --help           Display 'gradlew' command syntax
   gradlew tasks            Display all invocable targets
   gradlew explainjars      List all targets which build jar files
   gradlew explainprops     Explain how to change build properties
   gradlew ANYTHING ELSE    Run 'gradlew' for details

examples:
   gradlew hsqldb
   gradlew clean
"""
}
help.description = 'Displays a help message'

task explainprops << {
    println '''
There are two types of build properties that you can change.
See comments at top of "build-*.xml" files for available Ant build properties.
See comments at top of "build-*.gradle" files for available Gradle build
properties.

For property settings that you want to apply to most builds, use a Java
properties file named "build.properties".  For example, to usually build
non-debug/speed-and-size optimized Java classes, set
   build.debug=true
Whether or not you set properties in this way, you can override with
invocation-specific properties as follow.

For invocation-specific Ant property settings, use -D switches.  For example
    gradlew -Dbuild.debug=false hsqldb

For invocation-specific Gradle property settings, use -P switches like this:
    gradlew -Pretain.gradleds=true hsqldb
'''
}
explainprops.description = 'Explain how to change default build properties'

/**
 * Override OOTB 'tasks'.
 * Hides -private tasks from Ant.
 * Hides tasks without descriptions.
 * Hides Ant-subproject tasks because for tasks in sub-projects, Gradle always
 *  creates unqualified and one qualified to the sub-project.
 * Hide renamed tasks so that user will only see the "generated wrappers"
 *  created above for this purpose.
 *
 * Only problem here is that Gradle gives us no way to discern overridden
 * tasks, so that we could present both the sub-project target and the
 * super-project target in this case.
 * In this case, we present only the overriding target until Gradle fixes the
 * bug that I registered.
 */
task tasks << {
    Pattern seqRenamedPattern = Pattern.compile("\\d{3}.+");
    // Following pattern purposefull skips import-qualified tasks.
    // We'll just report on the unqualified ones.
    Pattern privatePattern = Pattern.compile("(?:\\d{3})?(-.*)");
    print """
------------------------------------------------------------
Root Project
------------------------------------------------------------

Help tasks
----------
dependencies - Displays the dependencies of root project '$project.name'.
explainjars - List all targets which build jar files
explainprops - How to change build properties of root project '$project.name'.
help - Displays a help message
projects - Displays the sub-projects of root project '$project.name'.
properties - Displays the properties of root project '$project.name'.
tasks - Displays the tasks in root project '$project.name'.

Other tasks
-----------
"""
    boolean displayAll = (project.hasProperty('allTasks')
            && Boolean.parseBoolean(project.property('allTasks')))
    def describedPrivates = []
    def hardTaskDescriptions =
            ['tasks', 'help', 'explainprops', 'explainjars'] as Set
    Matcher pMatcher
    NEXT_TASK:
    for (t in getTasks()) {
        if (t.name.length() < 1)
            throw new GradleException('Task with 0 length name encountered.')
        if (t.description != null) {
            pMatcher = privatePattern.matcher(t.name)
            if (pMatcher.matches()) {
                if (pMatcher.groupCount() != 1 || pMatcher.group(1) == null)
                    throw new GradleException(
                        'Internal problem w/ regex pattern: ' + privatePattern)
                describedPrivates << pMatcher.group(1)
                continue
            }
        }
        if (!displayAll && t.description != null && t.name.indexOf('.') < 0
                && !seqRenamedPattern.matcher(t.name).matches()
                && !hardTaskDescriptions.contains(t.name))
            println t.name + ' - ' + t.description
    }

    if (displayAll) {
        def dependOnMap = [:]
        def depList
        for (t in getTasks()) {
            if (hidingWrappers.containsValue(t)) continue
            depList = []
            dependOnMap[t] = depList
            for (u in t.dependsOn)
                if (u instanceof Task) depList << u
                else if (u instanceof TaskDependency)
                    // Retarded that t must pass itself as param to its own u:
                    for (v in u.getDependencies(t)) depList << v
        }
        def allDependees = [] as Set
        for (vs in dependOnMap.values()) allDependees.addAll(vs)
        for (t in getTasks())
            if (!allDependees.contains(t) && !hidingWrappers.containsValue(t)
                    && !hardTaskDescriptions.contains(t.name)) {
                print t.name
                if (t.description != null) print " - $t.description"
                if (hidingWrappers.containsKey(t))
                    print ' [Wrapped by ' + hidingWrappers[t].name + ']'
                println()
                for (u in recursiveAggregator(
                        dependOnMap[t], dependOnMap, [])) {
                    print "    $u.name"
                    if (u.description != null) print " - $u.description"
                    if (hidingWrappers.containsKey(u))
                        print ' [Wrapped by ' + hidingWrappers[u].name + ']'
                    println()
                }
            }
    } else {
        println('''
To see all tasks and more detail, run 'gradle -PallTasks=true tasks'.
(N.b. our -P switch differs from Gradle's out-of-the-box --all switch for this
purpose).''')
    }
    if (describedPrivates.size() > 0)
        logger.warn('\nWARNING:  Private Ant tasks have descriptions: '
                + describedPrivates.join(', '))
}
tasks['tasks'].description =
        "Displays the tasks in root project '$project.name'."
