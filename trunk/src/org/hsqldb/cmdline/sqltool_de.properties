# $Id$

# IMPORTANT:  Make sure to use ISO-8859-1 encoding for any extended characters,
# both in this file (actually any .properties file) and all referenced text
# files.

# GENERAL .properties SYNTAX:
#   White space AT END OF LINES IS SIGNIFICANT
#   White space at beginning of lines is not
#   \ at very end of line makes the following line a continuation line (with
#     no implied newline in the value.
#     (Combined with the previous 2 rules, this means that white space before
#     this \ is significant, and whitespace at beginning of continutation lines
#     is not).
#   \n does not work as an escape.  Use unicode \u000a for line breaks instead.

# German Locale String resources for SqlTool.
# This file is loaded by RefCapablePropertyResourceBundle, so if any
# property here has no value set, the value MUST be set in a file
# located at sqltool/PROPERTYNAME.text

# The empty val settings in sqltool.properties are inherited to the other
# languages, so see the "sqltool.properties" file about that.

# Traditional inline .properties values:
rawmode.prompt=row
SqlTool.varset.badformat=Syntax der Variablen entspricht nicht dem Format "name=währung[,...]".
SqlTool.abort_continue.mutuallyexclusive=Die Schalter '--abortOnErr' und \
                        '--continueOnErr' schließen sich gegenseitig aus.
sqltempfile.fail=Die angegebe SQL konnte nicht in der Datei gespeichert werden.\u000aUrsache: %{1}
rcdata.inlineurl.missing=Das 'url' Element wird für inlineRC benötigt.
rcdata.inline.extravars=Nicht unterstützte(s) inlineRC Element(e) angegeben: %{1}.
rcdata.inlineusername.missing=Das 'user' Element wird für inlineRC benötigt.
rcdata.password.visible=Das 'password' Element muß leer sein.  \
            Um ein Passwort zu verwenden lassen Sie das\u000a\
            'password' Element weg, sie werden dann separat danach gefragt!
password.readfail=Fehler beim einlesen des Passwortes.\u000aUrsache: %{1}
rcdata.genfromvalues.fail=RCData ließ sich aus den angegebenen Werten nicht erzeugen.\u000aUrsache: %{1}
conndata.retrieval.fail=Konnte keine Verbindungsinformationen für urlid "%{1} finden".\u000aUrsache: %{2}
jdbc.established=JDBC Verbindung herstellte zu eine %{1} v. %{2} Datenbank\u000a\
    als "%{3}" mit %{4} Isolation.
connection.fail=Konnte keine Verbindung herstellen zu %{1} als Benutzer "%{3}"! \u000aUrsache: %{3}
tempfile.removal.fail=Beim Versuch die temporäre Datei '%{1} zu löschen trat ein Fehler auf'.
# Value for following line has trailing whitespace on purpose.
passwordFor.prompt=Bitte Passwort angeben für %{1}!:  

sqlfile.readfail=Die SQL Datei '%{1} konnte nicht gelesen werden.
raw.movedtobuffer=Raw-SQL Block in den Edit-Puffer verschoben. Geben Sie ":;" ein, um den Block auszuführen!
input.movedtobuffer=Aktueller Befehl wurde in den Edit-Puffer verschoben.
sqlstatement.empty=Leere SQL-Anweisung.
causereport=Ursache: %{1}
break.unsatisfied=Unzureichende 'break' Anweisung (%{1} Typ).
continue.unsatisfied=Unzureichende 'continue' Anweisung%{1:+ (type '%1')}.
input.unterminated=Unvollständige Eingabe:  "%{1}"
primaryinput.accessfail=Fehler beim Zugriff auf die Primäreingabe.
aborting=SqlTool abgebrochen:  %{1}
plvar.set.incomplete=Einstellung der Variable '%{1}' ist unvollständig geblieben.
rollingback=Die SQL-Transaktion wird rückgängig gemacht.
bufhist.unspecified=Kein Befehl spezifiziert.  Rufen Sie ":?" auf, um die Kommandos für den Befehlszwischenspeicher und den Verlauf anzuzeigen!
special.unspecified=Kein Befehl spezifiziert.  Rufen Sie "\\?" auf, um die Sonderbefehle aufzulisten!
buffer.executing=Befehl aus dem Edit-Puffer ausgeführt:\u000a"%{1}"\u000a
nobuffer.yet=Noch kein Pufferinhalt.
commandnum.malformat=Fehlerhaft formatierter Befehl Nr. "%{1}".
buffer.restored=Folgender Befehl wurde wieder hergestellt.\u000a\
        ":?" eingeben, um die Pufferbefehle anzuzeigen.\u000a%{1}
substitution.malformat=Fehlerhafte Ersetzungsanweisung.
substitution.nomatch=Puffer unverändert, da der Musterabgleich fehlschlug.
substitution.syntax=Syntax für Ersetzungen: ":s/von regex/zu string/igm;".  \
                     Optionale Schalter: i, g, m, ;.
buffer.unknown=Unbekannter Pufferbefehl ":%{1}".
dsv.x.syntax=Exportsyntax:  "\\x Tabelle_oder_angezeigter_name "  OR  "\\x SELECT Anweisung".\u000a\
(Nicht mit ';' beenden, da der \\x Befehl selbst keine SQL-Anweisung ist.
dsv.m.syntax=Importsyntax:  \\m Datei/Pfad.dsv [*]   (* bedeutet keine Anmerkungen in der DSV Datei).
special.extrachars=Extrazeichen nach "\\%{1}" Befehl:  %{2}
buffer.extrachars=Extrazeichen nach ":%{1}" Befehl:  %{2}
special.malformat=Fehlerhaft formatierter Sonderbefehl.
html.mode=HTML Modus ist jetzt gesetzt auf %{1}.
dsv.targetfile.demand=Sie müssen die PL-Variable "*DSV_TARGET_FILE" setzten, um die fragliche Variante von \\x zu verwenden.
file.wrotechars=Das Zeichen %{1} wurde in die Datei '%{2}' geschrieben.
file.writefail=Konnte nicht in die Datei '%{1}' schreiben.
file.appendfail=Konnnte nichts zur Datei '%{1}' hinzufügen.
destfile.demand=Sie müssen einen Namen für die Zieldatei angeben.
special.d.like=\\d Angezeigte Befehle müssen wie '\\dX' oder '\\d OBJECTNAME' sein.  '\\d?' eingeben für weitere Auflistungen.
outputfile.nonetoclose=Für die Abfrage existiert keine Ausgabedatei welche geschlossen werden könnte.
outputfile.reopening=Schließe Ausgabedatei der aktuellen Abfrage und öffne sie erneut.
outputfile.header=Ausgabe der Abfrage von %{1}.
buffer.empty=Kein Befehl im Edit-Puffer.
sqlfile.name.demand=Geben Sie bitte einen SQL-Dateinamen an.
sqlfile.execute.fail=Konnte den Inhalt der SQL-Datei '%{1} nicht ausführen.
a.setting=Auto-Commit-Modus wird gesetzt auf %{1}.
committed=Transaktion ausgeführt.
special.b.malformat=Fehlerhaft formatierter Binärbefehl.
binary.loadedbytesinto=%{1} Bytes in den Binärpuffer geladen.
binary.filefail=Fehler beim schreiben der Binärdaten in Datei '%{1}'.
c.setting="Nach-Fehler-fortfahren" (Continue-on-error) wird gesetzt auf %{1}.
bang.incomplete=Nach dem externen Befehl muss ein '!' folgen um ihn auszuführen.
bang.command.fail=Externer Befehl ist fehlgeschlagen:\u000a"%{1}"
special.unknown=Unbekannter Sonderbefehl "\\%{1}".
raw.empty=RAW-Anweisung wurde abgebrochen (keine Eingabe erhalten).
dsv.nocolsleft=Keine weiteren Spalten verblieben, nachdem %{1:+"%1" und }"-" Spalten ausgelassen worden sind.
dsv.skipcols.missing=Die folgende(n) Leerspalte(n) ist nicht vorhanden:  %{1}.
plalias.malformat=Fehlerhafte Verwendung des PL-Alias.
plvar.undefined=Unbestimmte PL-Variable "%{1}".
var.infinite=Mögliche endlose Variable gehen zurück, '%{1}' mit einbeziehend.
sysprop.empty=Leerer Systemvariablename.
sysprop.unterminated=Unvollständiger Systemvariablenname.
sysprop.undefined: Nicht gesetzte Systemeinstellung "%{1}".
plvar.nameempty=Leerer PL-Variablenname.
plvar.unterminated=Unvollständiger PL-Variablenname.
pl.malformat=Fehlerhafter PL-Befehl.
pl.expansionmode=Status der PL-Variablenexpansion ist nun %{1}.
end.noblock=Fehlender Abschluss der 'end'-Anweisung.
continue.syntax=PL 'continue' Anweisung erfordert kein Argument oder von \
                 'foreach', 'while'.
break.syntax=PL 'break' Anweisung erfordert kein Argument oder von \
                 'foreach', 'if', 'while', 'file'.
pl.list.parens=Die äußersten Klammern sind nicht Teil der Werte.
pl.list.lengths=Zeigt den Variablennamen und die Länge der Werte. \
            (Verwende 'listvalues', um die Werte zu sehen).
dumpload.malformat=Fehlerhafter PL 'dump' oder 'load' Befehl.
plvar.nocolon=PL Variablennamen dürfen nicht ':' enthalten.
plvar.tildedash.nomoreargs=PL ~/_ Befehle akzeptieren keine anderen Argumente ("%{1}").
dumpload.fail=Konnte Variable '%{1}'  nicht in/von Datei '%{2}' speichern/laden.
prepare.malformat=Fehlerhafter PL 'prepare' Befehl.
foreach.malformat=Fehlerhafter PL 'foreach' Befehl.
pl.block.fail=Konnte die Anweisungen vom PL-Block nicht ausführen.
ifwhile.malformat=Fehlerhafter PL 'if'/'while' Befehl.
if.malformat=Fehlerhafter PL 'if' Befehl.
while.malformat=Fehlerhafter PL 'while' Befehl.
pl.unknown=Unbekannter PL-Befehl "%{1}".
pl.block.unterminated=Nicht beendeter PL '%{1}' Block
vendor.oracle.dS=*** WARNUNG:\u000a\
    *** Liste Tabelle im Systemeigenen Schemata, da\u000a\
    *** Oracle (TM) keine JDBC System-Tabellenliste zurückgibt.
vendor.derby.dr=Derby verfügt nicht über SQL-Rollen.
vendor.nosup.d=SqlFile unterstützt noch nicht \\d%{1} für Ihren Datenbanktyp.
vendor.derby.du=Es ist unmöglich, eine zuverlässige Benutzerliste von Derby zu erhalten.
special.d.unknown=Unbekannte \\d Wahl: '%{1}'.
metadata.fetch.fail=Konnte die Metadaten der Datenbank nicht bekommen.
metadata.fetch.failfor=Konnte die Metadaten der Datenbank für '%{1}' nicht bekommen.
prepare.demandqm='Prepared statements' müssen ein '?' enthalten.
binbuffer.empty=Binärpuffer ist leer.
vendor.nosup.sysschemas=*** WARNUNG:\u000a\
        *** Lasse Tabellen vom System eigenen Schemata wegfallen\u000a\
        *** (weil DB-Distributor sie nicht von JDBC unterscheidet).
noresult=Kein Resultat.
dsv.bincol=Tabelle hat eine binäre Spalte. DSV Dateien sind Textdateien und keine Binärdateien.
binbuf.write=Lese %{1} Bytes von Spalte '%{2}' (Typ %{3}) in den Binärpuffer.
rows.fetched=%{1} Reihen geholt.
rows.fetched.dsv=%{1} Reihen von der Datenbank geholt.
row.update.multiple=%{1} Reihen aktualisierten.
row.update.singular=1 Reihe aktualisierte.
history.unavailable=Befehlsverlauf nicht vorhanden.
history.none=Noch keinen Verlauf.
editbuffer.contents=Edit-Pufferinhalt:\u000a"%{1}"
buffer.instructions=Copy ein Befehl zum Puffer wie so ":27" or ":-3".  \
                    wiederausführt Puffer wie so ":;".
history.number.req=Du mußt eine positive absolute Befehl Zahl, oder eine \
   negative Zahl\u000aspezifizieren, um die rückseitigen X Befehle zu bedeuten.
history.backto=Befehlgeschichte geht nur zurück zu #%{1}.
history.upto=Befehlgeschichte geht nur zurück bis #%{1}.
history.back=Befehlgeschichte geht nur zurück %{1} Befehl(e).
describe.table.name=name
describe.table.datatype=datenart
describe.table.width=breite
describe.table.nonulls=kein-nulls
logical.unrecognized=Unerkannte funktionelle Operation.
read.toobig=Inhalt ist zu groß, einen Schluck innen zu lesen.\u000a\
    Lassen Sie das Programm mit mehr RAM laufen (Versuchen Java -Xm* Schalter).
read.partial=Las nicht alle Bytes. %{1} Bytes aus %{2} heraus innen lesen.
read.convertfail=Wert zu groß in Zeichenkette umwandeln. \u000a\
    Lassen Sie das Programm mit mehr RAM laufen (Versuchen Java -Xm* Schalter).
dsv.coldelim.present=Tabelle Daten enthalten unsere Element Trennzeichen '%{1}'.
dsv.rowdelim.present=Tabelle Daten enthalten unsere Segment Trennzeichen '%{1}'.
dsv.nullrep.present=Tabelle Daten enthalten unsere null Zeichen '%{1}'.
dsv.constcols.nullcol=*DSV_CONST_COLS Element hat null Spalte Namen.
file.readfail=Die Datei '%{1} kann nicht lesen werden.
inputfile.closefail=Konnte Eingang Datei schließen nicht.
dsv.header.none=Kein Vorsatz in Eingang Datei.
dsv.header.noswitchtarg=Vorsatzschalter an DSV Datei Leitung %{1}, aber keine Zieltabelle ist schon spezifiziert worden.
dsv.header.noswitchmatch=Nahe erreicht vom Versuch an DSV Datei Zeile %{1}, ohne ein Vorsatzschalter zusammenzubringen.
dsv.header.nonswitched=Vorsatzzeile innerhalb Schalter ohne Tabelle-Matcher an DSV Datei Zeile %{1}.
dsv.nocolheader=Kein Spalteüberschrift für Spalte #%{1} an DSV Datei Zeile %{2}.
dsv.metadata.mismatch=Metadaten passen für Spalten falsch an.
query.metadatafail=Konnte Metadaten für Abfrage nicht erhalten, indem das Verwenden:\u000a"%{1}"
dsv.rejectfile.setupfail=Konnte Ausschußdatei '%{1}' aufstellen nicht.
dsv.rejectreport.setupfail=Konnte Ausschußreport '%{1}' aufstellen nicht.
none=Kein
insertion.preparefail=Konnte Einfügung vorbereiten, Zeichenkette zu gründen nicht:\u000a"%{1}"
dsv.header.matchernonhead=Nicht Vorsatz Zeile innerhalb Tebelle-Matcher Block an DSV Datei Zeile %{1}.
dsv.colcount.mismatch=Vorsatz hat %{1} Spalten, aber Eingabesatz hat %{2} Spalte Werte.
dsv.insertcol.mismatch=Erwartete Gesamtmenge von %{1} Einsatzwerten, aber erfaßte %{2}.
dsv.nonskip.mismatch=Vorsatz hat %{1} nicht auslassen Spalten, aber der Eingabesatz hat %{2} Einfügungwerte.
time.bad=Schlechter Datum/Zeitwert.
boolean.bad=Schechter Booleanwert '%{1}'.
inputrec.modified=%{1} Reihen geändert durch diesen Eingabesatz.
dsv.recin.fail=Analysieren oder Einsatz der Eingang Zeile %{1} %{2:+, column '%2' }ausfallen.
dsv.import.summary=Importzusammenfassung (%{1}Ausgelassen / Zurückgewiesen / Eingefügt):  \
                    %{2} / %{3} / %{4}%{5:+ vor dem Abbruch}.
insertions.notcommitted=Einfügungen sind verloren, wenn du nicht commit.
autocommit.fetchfail=Konnte Anschluß autocommit Wert erhalten nicht.
dsv.rejectfile.purgefail:Konnte nicht notwendige Ausschußdatei '%{1}' bereinigen nicht.
dsv.rejectreport.purgefail=Konnte nicht notwendige Ausschußreport '%{1}' bereinigen nicht.
edit.malformat=Malformatted Pufferbefehl.
input.malformat=Syntaxfehler in der Eingabe.
append.empty=Use ':,' einen Befehl zu wiederholen, ohne anhängend
transiso.report=Transaction Isolation Ebene ist jetzt %{1} %{2}
exectime.reporting=Execution-Zeit Berichterstattung auf %{1} gesetzt
exectime.report=Dauterte %{1} ms.
regex.malformat=Falsh regex Muster: %{1}
encode.fail=Output-Kodierung fehlgeschlagen: %{1}
macro.tip=Laufen Sie /? für Makro-Hilfe!
macrodef.malformat=Malformatted Makro-Definition-Befehl
macrodef.empty=Keine Inhalte für Makro
macrodef.semi=Makro-Werte können nicht mit ";"
macro.malformat=Malformatted Makro-Befehl
macro.undefined=Es gibt keine definierte Makro mit Namen "%{1}".
errstream.deprecated:\
    WARNUNG: Die SqlFile Execute-Methode mit Fehler-Stream-Parameter wurde\
    verworfen. Ihre Bewerbung sollte aktualisiert werden, um eine\
    Logging-Anlage.  Ausgehend ...
log.syntax=SYNTAX:  \\l EBENE Nachricht\u000a\
    Wo EBENE ist ein:  FINEST, FINER, INFO, WARNING, SEVERE
log.syntax.error=Logging-Syntax-Fehler.  Laufen Sie '\\l?' für Hilfe!
reject.rpc=Clearing *DSV_RECORDS_PER_COMMIT, da Nicht-Integer angegaben wurde: %{1}
rpc.autocommit.failure=Konnte nicht engerichtet für die *DSV_RECORDS_PER_COMMIT Option
rpc.commit.failure=Konnte nicht finalisieren Commit Status für *DSV_RECORDS_PER_COMMIT option
