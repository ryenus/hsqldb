/*
 * $Id$
 *
 * Tests interactive commands :s*
 */

\c false
/* Since running interactively, need to either invoke with --abortOnErr switch,
 * or use "\c false" Special command, to detect failures. */

CREATE TABLE t(id INTEGER GENERATED BY DEFAULT AS IDENTITY, vc VARCHAR);

/* Just verify that an error is not thrown by the two following commands.
   And that they don't effect the command history. */
:b
:h

INSERT INTO t(vc) VALUES('one')

/* In interactive mode, the blank line above will move the command to the
 * edit buffer without executing it. */

:s/n/MM/;
/*Since this executes, command #3 in history will become "INSERT... 'oMMe'".*/

SELECT count(*) FROM t;
*if (*? != 1)
    \q Blank lines not behaving right in Interactive mode
*end if

SELECT count(*) FROM t WHERE vc = 'oMMe';
*if (*? != 1)
    \q Simple substitution of edit buffer failed.
*end if

/* Tailing white space in line below, on purpose. */
:3   s@M@.@g;  

SELECT count(*) FROM t;
*if (*? != 2)
    \q Recall + subst. + exec failed / 1
*end if

SELECT count(*) FROM t WHERE vc = 'o..e';
*if (*? != 1)
    \q Recall + subst. + exec failed / 2
*end if

:3
/* Purposeful trailing white space in following line */
:s:MM:x:g   
:;

SELECT count(*) FROM t;
*if (*? != 3)
    \q Recall + subst., then exec failed / 1
*end if

SELECT count(*) FROM t WHERE vc = 'oxe';
*if (*? != 1)
    \q Recall + subst., then exec failed / 2
*end if

/* Test simple recall and execution */
:3
:;
:3;
:;

SELECT count(*) FROM t
*if (*? != 6)
    \q Recall and execs failed / 1
*end if

/* SELECT vc FROM t; */
SELECT count(*) FROM t WHERE vc = 'oMMe';
*if (*? != 4)
    \q Recall and execs failed / 2
*end if

INSERT INTO t(vc) VALUES 'pref

:apost';

SELECT count(*) FROM t
*if (*? != 7)
    \q Append + repl failed / 1
*end if

SELECT vc FROM t;
SELECT count(*) FROM t WHERE vc = 'prefpost';
*if (*? != 1)
    \q Append + repl failed / 2
*end if

SELECT count(*) FROM t;

\p Intervening command making previous become command # -2.
:h
:-2a WHERE vc = 'oMMe';

*if (*? != 4)
    \q Recall + Append + exec failed / 1
*end if

:-2
:a AND

id = 0

:;
*if (*? != 1)
    \q Recall + multi-line Append failed / 1
*end if

/* Can't think of a portable way to test :w.
   The assumptions about "rm" and /tmp are very undesirable.
   Would be much easier if PL variables worked in : commands.

   If this test fails, there will be a temp file left in /tmp
   which will cause this test to fail for other users!
   (Because other users won't have permission to overwrite it).
*/

\! rm -f /tmp/sqltool-wtest.sql
\p Testing write of non-sql, #1
:w /tmp/sqltool-wtest.sql
INSERT INTO t (vc) VALUES ('a');
:w /tmp/sqltool-wtest.sql
:;
INSERT INTO t (vc) VALUES ('b');
INSERT INTO t (vc) VALUES ('c');
:w /tmp/sqltool-wtest.sql
\p Testing write of non-sql, #2
:w /tmp/sqltool-wtest.sql
INSERT INTO t (vc) VALUES ('d');
INSERT INTO t (vc) VALUES ('e');
INSERT INTO t (vc) VALUES ('f');
:-2w /tmp/sqltool-wtest.sql
:w  /tmp/sqltool-wtest.sql  
/* Following line has trailing white space */
:w  /tmp/sqltool-wtest.sql  
:;
/* The :; commands will do non-effectual INSERTs, not :w's, since :
   commands may not be recalled (since they don't make it into the buffer). */

/* Clean up the temp file if at all possible! */
DELETE FROM t;
\i /tmp/sqltool-wtest.sql

SELECT COUNT(*) FROM t;
*if (*? != 5)
    \! rm -f /tmp/sqltool-wtest.sql
    \q :w test failed / 1
*end if
SELECT COUNT(*) FROM t WHERE vc = 'a';
*if (*? != 1)
    \! rm -f /tmp/sqltool-wtest.sql
    \q :w test failed / 2
*end if
SELECT COUNT(*) FROM t WHERE vc = 'c';
*if (*? != 1)
    \! rm -f /tmp/sqltool-wtest.sql
    \q :w test failed / 3
*end if
SELECT COUNT(*) FROM t WHERE vc = 'e';
*if (*? != 1)
    \! rm -f /tmp/sqltool-wtest.sql
    \q :w test failed / 4
*end if
SELECT COUNT(*) FROM t WHERE vc = 'f';
*if (*? != 2)
    \! rm -f /tmp/sqltool-wtest.sql
    \q :w test failed / 5
*end if

\! rm -f /tmp/sqltool-wtest.sql
