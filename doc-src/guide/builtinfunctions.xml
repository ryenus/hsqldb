<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % dummy22 SYSTEM "../entities/global.ent">
%dummy22;
]>
<chapter version="5.0" xml:id="builtinfunctions-chapt"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:id="builtinfunctions-title">Built In Functions</title>

  <info>
    <authorgroup>
      <author>
        <personname><firstname>Fred</firstname><surname>Toussi</surname></personname>

        <affiliation>
          <orgname>The HSQL Development Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <pubdate>&timestamp;</pubdate>

    <keywordset>
      <keyword>HSQLDB</keyword>

      <keyword>HyperSQL</keyword>

      <keyword>SQL</keyword>
    </keywordset>

    <legalnotice>
      <para>Copyright 2010-2020 Fred Toussi. Permission is granted to
      distribute this document without any alteration under the terms of the
      HSQLDB license. Additional permission is granted to the HSQL Development
      Group to distribute this document with or without alterations under the
      terms of the HSQLDB license.</para>
    </legalnotice>
  </info>

  <section xml:id="bfc_overview">
    <title>Overview</title>

    <para>HyperSQL supports a wide range of built-in functions and allows
    user-defined functions written in SQL and Java languages. User-defined
    functions are covered in the <link endterm="sqlroutines-title"
    xlink:href="#sqlroutines-chapt"/> chapter. If a built-in function is not
    available, you can write your own using procedural SQL or Java.</para>

    <para>Built-in aggregate functions such as <literal>SUM,</literal>
    <literal>MAX</literal>, <literal>ARRAY_AGG</literal>,
    <literal>GROUP_CONCAT</literal> are covered in the <link
    endterm="dataaccess-title" xlink:href="#dataaccess-chapt"/> chapter, which
    covers SQL in general. SQL expressions such as
    <literal>COALESCE</literal>, <literal>NULLIF</literal> and
    <literal>CAST</literal> are also discussed there.</para>

    <para>The built-in functions fall into three groups:</para>

    <para><itemizedlist>
        <listitem>
          <para>SQL Standard Functions</para>

          <para>A wide range of functions defined by SQL/Foundation are
          supported. SQL/Foundation functions that have no parameter are
          called without empty parentheses. Functions with multiple parameters
          often use keywords instead of commas to separate the parameters.
          Many functions are overloaded. Among these, some have one or more
          optional parameters that can be omitted, while the return type of
          some functions is dependent upon the type of one of the parameters.
          The usage of SQL Standard Functions (where they can be used) is
          covered more extensively in the <link endterm="dataaccess-title"
          xlink:href="#dataaccess-chapt"/> chapter</para>
        </listitem>

        <listitem>
          <para>JDBC Open Group CLI Functions</para>

          <para>These functions were defined as an extension to the CLI
          standard, which is the basis for ODBC and JDBC and supported by many
          database products. JDBC supports an escape mechanism to specify
          function calls in SQL statements in a manner that is independent of
          the function names supported by the target database engine. For
          example <literal>SELECT {fn DAYOFMONTH (dateColumn)} FROM
          myTable</literal> can be used in JDBC and is translated to Standard
          SQL as <literal>SELECT EXTRACT (DAY_OF_MONTH FROM dateColumn) FROM
          myTable</literal> if a database engine supports the Standard syntax.
          If a database engine does not support Standard SQL, then the
          translation will be different. HyperSQL supports all the function
          names specified in the JDBC specifications as native functions.
          Therefore, there is no need to use the <literal>{fn FUNC_NAME ( ...
          ) }</literal> escape with HyperSQL. If a JDBC function is supported
          by the SQL Standard in a different form, the SQL Standard form is
          the preferred form to use.</para>
        </listitem>

        <listitem>
          <para>HyperSQL Built-In Functions</para>

          <para>Many additional built-in functions are available for some
          useful operations. Some of these functions return the current
          setting for the session and the database. The General Functions
          accept arguments of different types and return values based on
          comparison between the arguments.</para>
        </listitem>
      </itemizedlist></para>

    <para>In the BNF specification used here, words in capital letters are
    actual tokens. Syntactic elements such as expressions are enclosed in
    angle brackets. The <literal>&lt;left paren&gt;</literal> and
    <literal>&lt;right paren&gt;</literal> tokens are represented with the
    actual symbol. Optional elements are enclosed with square brackets (
    <literal>&lt;left bracket&gt;</literal> and <literal>&lt;right
    bracket&gt;</literal> ). Multiple options for a required element are
    enclosed with braces (<literal> &lt;left brace&gt;</literal> and
    <literal>&lt;right brace&gt;</literal> )<literal>.</literal> Alternative
    tokens are separated with the vertical bar ( <literal>&lt;vertical
    bar&gt;</literal> ). At the end of each function definition, the standard
    which specifies the function is noted in parentheses as JDBC or HyperSQL,
    or the SQL/Foundation part of the SQL Standard.</para>
  </section>

  <section xml:id="bfc_string_binary_functions">
    <title>String and Binary String Functions</title>

    <para>In SQL, there are three kinds of string: character, binary and bit.
    The units are respectively characters, octets, and bits. Each kind of
    string can be in different data types. CHAR, VARCHAR and CLOB are the
    character data types. BINARY, VARBINARY and BLOB are the binary data
    types. BIT and BIT VARYING are the bit string types. In all string
    functions, the position of a unit of the string within the whole string is
    specified from 1 to the length of the whole string. In the BNF,
    <literal>&lt;char value expr&gt; </literal>indicates any valid SQL
    expression that evaluates to a character type. Likewise,
    <literal>&lt;binary value expr&gt; </literal>indicates a binary type
    and<literal> &lt;num value expr&gt; </literal>indicates a numeric
    type.</para>

    <indexterm significance="preferred" type="sql">
      <primary>ASCII function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ASCII</emphasis></simpara>

    <para><literal>ASCII ( &lt;char value expr&gt; )</literal></para>

    <para>Returns an INTEGER equal to the ASCII code value of the first
    character of <literal>&lt;char value expr&gt;</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>BIT_LENGTH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BIT_LENGTH</emphasis></simpara>

    <para><literal>BIT_LENGTH ( &lt;string value expression&gt;
    )</literal></para>

    <para>BIT_LENGTH can be used with character, binary and bit strings. It
    return a BIGINT value that measures the bit length of the string.
    (Foundation)</para>

    <para>See also CHARACTER_LENGTH and OCTET_LENGTH.</para>

    <indexterm significance="preferred" type="sql">
      <primary>CHAR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CHAR</emphasis></simpara>

    <para><literal>CHAR ( &lt;UNICODE code&gt; ) </literal></para>

    <para>The argument is an INTEGER. Returns a character string containing a
    single character that has the specified<literal> &lt;UNICODE
    code&gt;</literal>, which is an integer. ASCII codes are a subset of the
    allowed values for <literal>&lt;UNICODE code&gt;</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CHAR_LENGTH</primary>
    </indexterm>

    <indexterm significance="preferred" type="sql">
      <primary>CHARACTER_LENGTH</primary>
    </indexterm>

    <simpara><emphasis role="bold">CHARACTER_LENGTH</emphasis></simpara>

    <para><literal>{ CHAR_LENGTH | CHARACTER_LENGTH } ( &lt;char value
    expression&gt; [ USING { CHARACTERS | OCTETS } ] )</literal></para>

    <para>The CHAR_LENGTH or CHARACTER_LENGTH function can be used with
    character strings, while OCTET_LENGTH can be used with character or binary
    strings and BIT_LENGTH can be used with character, binary and bit
    strings.</para>

    <para>All functions return a BIGINT value that measures the length of the
    string in the given unit. CHAR_LENGTH counts characters, OCTET_LENGTH
    counts octets and BIT_LENGTH counts bits in the string. For CHAR_LENGTH,
    if <literal>[ USING OCTETS ] </literal>is specified, the octet count is
    returned, which is twice the normal length. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CONCAT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CONCAT</emphasis></simpara>

    <para><literal>CONCAT ( &lt;char value expr 1&gt;, &lt;char value expr
    2&gt; [, ...] )</literal></para>

    <para><literal>CONCAT ( &lt;binary value expr 1&gt;, &lt;binary value expr
    2&gt; [, ...] )</literal></para>

    <para>The arguments are character strings or binary strings. Returns a
    string formed by concatenation of the arguments. Minimum number of
    arguments is 2. Equivalent to the SQL concatenation expression
    <literal>&lt;value expr 1&gt; || &lt;value expr 2&gt; [ || ...] </literal>
    .</para>

    <para>Handling of null values in the CONCAT function depends on the
    database property <literal>sql.concat_nulls</literal> ( <literal>SET
    DATABASE SQL SYNTAX CONCAT NULLS { TRUE || FALSE }</literal> ). By
    default, any null value will cause the function to return null. If the
    property is set false, then NULL values are replaced with empty
    strings.</para>

    <para>(JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CONCAT_WS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CONCAT_WS</emphasis></simpara>

    <para><literal>CONCAT_WS ( &lt;char value separator&gt;, &lt;char value
    expr 1&gt;, &lt;char value expr 2&gt; [, ...] )</literal></para>

    <para>The arguments are character strings. Returns a string formed by
    concatenation of the arguments from the second argument, using the
    separator from the first argument. Minimum number of arguments is 3.
    Equivalent to the SQL concatenation expression <literal>&lt;value expr
    1&gt; || &lt;separator&gt; || &lt;value expr 2&gt; [ || ...]</literal> .
    The function ignores null values and returns an empty string if all values
    are null. It returns null only if the separator is null.</para>

    <para>This function is similar to a MySQL function of the same
    name.</para>

    <para>(HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DIFFERENCE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DIFFERENCE</emphasis></simpara>

    <para><literal>DIFFERENCE ( &lt;char value expr 1&gt;, &lt;char value expr
    2&gt; )</literal></para>

    <para>The arguments are character strings. Converts the arguments into
    SOUNDEX codes, and returns an INTEGER between 0-4 which indicates how
    similar the two SOUNDEX value are. If the values are the same, it returns
    4, if the values have no similarity, it returns 0. In-between values are
    returned for partial similarity. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>FROM_BASE64 function</primary>
    </indexterm>

    <simpara><emphasis role="bold">FROM_BASE64</emphasis></simpara>

    <para><literal>FROM_BASE64( &lt;character value expr&gt;
    )</literal></para>

    <para>Returns a binary string by converting from the base64
    <literal>&lt;character value expr&gt;</literal>. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>INSERT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">INSERT</emphasis></simpara>

    <para><literal>INSERT ( &lt;char value expr 1&gt;, &lt;offset&gt;,
    &lt;length&gt;, &lt;char value expr 2&gt; )</literal></para>

    <para>Returns a character string based on <literal>&lt;char value expr
    1&gt;</literal> in which <literal>&lt;length&gt;</literal> characters have
    been removed from the <literal>&lt;offset&gt;</literal> position and in
    their place, the whole <literal>&lt;char value expr 2&gt;</literal> is
    copied. Equivalent to SQL/Foundation <literal>OVERLAY( &lt;char value
    expr1&gt; PLACING &lt; char value expr2&gt; FROM &lt;offset&gt; FOR
    &lt;length&gt; )</literal> . (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>INSTR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">INSTR</emphasis></simpara>

    <para><literal>INSTR ( &lt;char value expr 1&gt;, &lt;char value expr
    2&gt; [ , &lt;offset&gt; ] ) </literal></para>

    <para>Returns as a BIGINT value the starting position of the first
    occurrence of <literal>&lt;char value expr 2&gt;</literal> within
    <literal>&lt;char value expr 1&gt;</literal>. If
    <literal>&lt;offset</literal>&gt; is specified, the search begins with the
    position indicated by <literal>&lt;offset&gt;</literal>. If the search is
    not successful, 0 is returned. Similar to the <literal>LOCATE</literal>
    function but the order of the arguments is reversed. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>HEX function</primary>
    </indexterm>

    <simpara><emphasis role="bold">HEX</emphasis></simpara>

    <para><literal>HEX( &lt;binary value expr&gt; )</literal></para>

    <para><literal>HEX( &lt;numeric value expr&gt; )</literal></para>

    <para>Returns a character string of hexadecimal digits and letters
    representing the <literal>&lt;binary value expr&gt;</literal>. Exactly the
    same as the <literal>RAWTOHEX</literal> function. With
    <literal>&lt;numeric value expr&gt;</literal> the hexadecimal digits
    represent the number in base 16 (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>HEXTORAW function</primary>
    </indexterm>

    <simpara><emphasis role="bold">HEXTORAW</emphasis></simpara>

    <para><literal>HEXTORAW( &lt;char value expr&gt; )</literal></para>

    <para>Returns a binary string formed by translation of hexadecimal digits
    and letters in the &lt;<literal>char value expr&gt;</literal>. Each
    character of the <literal>&lt;char value expr&gt;</literal> must be a
    digit or a letter in the A | B | C | D | E | F set. Each byte of the
    retired binary string is formed by translating two hex digits into one
    byte. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LCASE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LCASE</emphasis></simpara>

    <para><literal>LCASE ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string that is the lower-case version of the
    <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
    <literal>LOWER (&lt;char value expr&gt;)</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LEFT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LEFT</emphasis></simpara>

    <para><literal>LEFT ( &lt;char value expr&gt;, &lt;count&gt; )
    </literal></para>

    <para>Returns a character string consisting of the first
    <literal>&lt;count&gt;</literal> characters of <literal>&lt;char value
    expr&gt;</literal>. Equivalent to SQL/Foundation<literal>
    SUBSTRING(&lt;char value expr&gt; FROM 0 FOR &lt;count&gt;)</literal>.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LENGTH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LENGTH</emphasis></simpara>

    <para><literal>LENGTH ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns as a BIGINT value the number of characters in
    <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
    <literal>CHAR_LENGTH(&lt;char value expr&gt;)</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOCATE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOCATE</emphasis></simpara>

    <para><literal>LOCATE ( &lt;char value expr 1&gt;, &lt;char value expr
    2&gt; [ , &lt;offset&gt; ] ) </literal></para>

    <para>Returns as a BIGINT value the starting position of the first
    occurrence of <literal>&lt;char value expr 1&gt;</literal> within
    <literal>&lt;char value expr 2&gt;</literal>. If
    <literal>&lt;offset</literal>&gt; is specified, the search begins with the
    position indicated by <literal>&lt;offset&gt;</literal>. If the search is
    not successful, 0 is returned. Without the third argument,<literal>
    LOCATE</literal> is equivalent to the SQL Standard function
    <literal>POSITION(&lt;char value expr 1&gt; IN &lt;char value expr
    2&gt;)</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOWER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOWER</emphasis></simpara>

    <para><literal>LOWER ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string that is the lower-case version of the
    <literal>&lt;char value expr&gt;</literal>. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LPAD function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LPAD</emphasis></simpara>

    <para><literal>LPAD ( &lt;char value expr 1&gt;, &lt;length&gt; [,
    &lt;char value expr 2&gt; ] ) </literal></para>

    <para>Returns a character string with the length of
    <literal>&lt;length&gt;</literal> characters. The string contains the
    characters of <literal>&lt;char value expr 1&gt;</literal> padded to the
    left with spaces. If <literal>&lt;length&gt;</literal> is smaller than the
    length of the string argument, the argument is truncated. If the optional
    <literal>&lt;char value expr 2&gt;</literal> is specified, this string is
    used for padding, instead of spaces. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LTRIM function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LTRIM</emphasis></simpara>

    <para><literal>LTRIM ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string based on <literal>&lt;char value
    expr&gt;</literal> with the leading space characters removed. Equivalent
    to SQL/Foundation <literal>TRIM( LEADING ' ' FROM &lt;char value expr&gt;
    )</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>OCTET_LENGTH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">OCTET_LENGTH</emphasis></simpara>

    <para><literal>OCTET_LENGTH ( &lt;string value expression&gt;
    )</literal></para>

    <para>The OCTET_LENGTH function can be used with character or binary
    strings.</para>

    <para>Return a BIGINT value that measures the length of the string in
    octets<literal>. When used with character strings</literal>, the octet
    count is returned, which is twice the normal length. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>OVERLAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">OVERLAY</emphasis></simpara>

    <para><literal>OVERLAY ( &lt;char value expr 1&gt; PLACING &lt;char value
    expr 2&gt;</literal></para>

    <para><literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ] [
    USING CHARACTERS ] )</literal></para>

    <para><literal>OVERLAY ( &lt;binary value expr 1&gt; PLACING &lt;binary
    value expr 2&gt;</literal></para>

    <para><literal>FROM &lt;start position&gt; [ FOR &lt;string length&gt; ]
    )</literal></para>

    <para>The character version of OVERLAY returns a character string based on
    <literal>&lt;char value expr 1&gt;</literal> in which <literal>&lt;string
    length&gt;</literal> characters have been removed from the
    <literal>&lt;start position&gt;</literal> and in their place, the whole
    <literal>&lt;char value expr 2&gt;</literal> is copied.</para>

    <para>The binary version of OVERLAY returns a binary string formed in the
    same manner as the character version. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>POSITION function</primary>
    </indexterm>

    <simpara><emphasis role="bold">POSITION</emphasis></simpara>

    <para><literal>POSITION ( &lt;char value expr 1&gt; IN &lt;char value expr
    2&gt; [ USING CHARACTERS ] )</literal></para>

    <para><literal>POSITION ( &lt;binary value expr 1&gt; IN &lt;binary value
    expr 2&gt; )</literal></para>

    <para>The character and binary versions of POSITION search the string
    value of the second argument for the first occurrence of the first
    argument string. If the search is successful, the position in the string
    is returned as a BIGINT. Otherwise zero is returned. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RAWTOHEX function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RAWTOHEX</emphasis></simpara>

    <para><literal>RAWTOHEX( &lt;binary value expr&gt; )</literal></para>

    <para>Returns a character string composed of hexadecimal digits
    representing the bytes in the <literal>&lt;binary value
    expr&gt;</literal>. Each byte of the <literal>&lt;binary value
    expr&gt;</literal> is translated into two hex digits. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REGEXP_MATCHES function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REGEXP_MATCHES</emphasis></simpara>

    <para><literal>REGEXP_MATCHES ( &lt;char value expr&gt;, &lt;regular
    expression&gt; ) </literal></para>

    <para>Returns true if the <literal>&lt;char value expr&gt;</literal>
    matches the <literal>&lt;regular expression&gt;</literal> as a whole. The
    <literal>&lt;regular expression&gt;</literal> is defined according to Java
    language regular expression rules. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REGEXP_REPLACE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REGEXP_REPLACE</emphasis></simpara>

    <para><literal>REGEXP_REPLACE ( &lt;char value expr 1&gt;, &lt;regular
    expression&gt;, &lt;char value expr 3&gt; ) </literal></para>

    <para>Replaces <literal>&lt;char value expr 1&gt;</literal> regions that
    match the <literal>&lt;regular expression&gt;</literal> with
    <literal>&lt;char value expr 3&gt;</literal>. The <literal>&lt;regular
    expression&gt;</literal> is defined according to Java language regular
    expression rules. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REGEXP_SUBSTRING function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REGEXP_SUBSTRING</emphasis></simpara>

    <para><literal>REGEXP_SUBSTRING ( &lt;char value expr&gt;, &lt;regular
    expression&gt; ) </literal></para>

    <para>Returns the first region in the <literal>&lt;char value
    expr&gt;</literal> that matches the <literal>&lt;regular
    expression&gt;</literal>. The <literal>&lt;regular
    expression&gt;</literal> is defined according to Java language regular
    expression rules. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REGEXP_SUBSTRING_ARRAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REGEXP_SUBSTRING_ARRAY</emphasis></simpara>

    <para><literal>REGEXP_SUBSTRING_ARRAY ( &lt;char value expr&gt;,
    &lt;regular expression&gt; ) </literal></para>

    <para>Returns all the regions in the <literal>&lt;char value
    expr&gt;</literal> that match the <literal>&lt;regular
    expression&gt;</literal>. The <literal>&lt;regular
    expression&gt;</literal> is defined according to Java language regular
    expression rules. Returns an array containing the matching regions
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REPEAT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REPEAT</emphasis></simpara>

    <para><literal>REPEAT ( &lt;char value expr&gt;, &lt;count&gt; )
    </literal></para>

    <para>Returns a character string based on<literal> &lt;char value
    expr&gt;</literal>, repeated <literal>&lt;count&gt;</literal> times.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REPLACE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REPLACE</emphasis></simpara>

    <para><literal>REPLACE ( &lt;char value expr 1&gt;, &lt;char value expr
    2&gt; [, &lt;char value expr 3&gt; ] )</literal></para>

    <para>Returns a character string based on <literal>&lt;char value expr
    1&gt;</literal> where each occurrence of <literal>&lt;char value expr
    2&gt;</literal> has been replaced with a copy of <literal>&lt;char value
    expr 3&gt;</literal>. If the function is called with just two arguments,
    the &lt;char value expr 3&gt; defaults to the empty string and calling the
    function simply removes the occurrences of <literal>&lt;char value expr
    2&gt;</literal> from the first string.(JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>REVERSE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">REVERSE</emphasis></simpara>

    <para><literal>REVERSE ( &lt;char value expr&gt; )</literal></para>

    <para>Returns a character string based on <literal>&lt;char value
    expr&gt;</literal> with characters in the reverse order. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RIGHT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RIGHT</emphasis></simpara>

    <para><literal>RIGHT ( &lt;char value expr&gt;, &lt;count&gt; )
    </literal></para>

    <para>Returns a character string consisting of the last
    <literal>&lt;count&gt;</literal> characters of <literal>&lt;char value
    expr&gt;</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RPAD function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RPAD</emphasis></simpara>

    <para><literal>RPAD ( &lt;char value expr 1&gt;, &lt;length&gt; [,
    &lt;char value expr 2&gt; ] ) </literal></para>

    <para>Returns a character string with the length of
    <literal>&lt;length&gt;</literal> characters. The string begins with the
    characters of <literal>&lt;char value expr 1&gt;</literal> padded to the
    right with spaces. If <literal>&lt;length&gt;</literal> is smaller than
    the length of the string argument, the argument is truncated. If the
    optional <literal>&lt;char value expr 2&gt;</literal> is specified, this
    string is used for padding, instead of spaces. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RTRIM function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RTRIM</emphasis></simpara>

    <para><literal>RTRIM ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string based on <literal>&lt;char value
    expr&gt;</literal> with the trailing space characters removed. Equivalent
    to SQL/Foundation <literal>TRIM(TRAILING ' ' FROM &lt;character
    string&gt;)</literal>. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SOUNDEX function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SOUNDEX</emphasis></simpara>

    <para><literal>SOUNDEX ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a four-character code representing the sound of
    <literal>&lt;char value expr&gt;</literal>. The US census algorithm is
    used. For example, the soundex value for "Washington" is W252.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SPACE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SPACE</emphasis></simpara>

    <para><literal>SPACE ( &lt;count&gt; ) </literal></para>

    <para>Returns a character string consisting of <literal>&lt;count&gt;
    </literal>spaces. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SUBSTR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SUBSTR</emphasis></simpara>

    <para><literal>{ SUBSTR | SUBSTRING } ( &lt;char value expr&gt;,
    &lt;offset&gt;, &lt;length&gt; )</literal></para>

    <para>The JDBC version of SQL/Foundation <literal>SUBSTRING</literal>
    returns a character string that consists of
    <literal>&lt;length&gt;</literal> characters from <literal>&lt;char value
    expr&gt; </literal>starting at the <literal>&lt;offset&gt;</literal>
    position. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SUBSTRING function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SUBSTRING</emphasis></simpara>

    <para><literal>SUBSTRING ( &lt;char value expr&gt; FROM &lt;start
    position&gt; [ FOR &lt;string length&gt; ] [ USING CHARACTERS ]
    )</literal></para>

    <para><literal>SUBSTRING ( &lt;binary value expr&gt; FROM &lt;start
    position&gt; [ FOR &lt;string length&gt; ] )</literal></para>

    <para>The character version of SUBSTRING returns a character string that
    consists of the characters of the <literal>&lt;char value expr&gt;
    </literal>from <literal>&lt;start position&gt;</literal>. If the
    optional<literal> &lt;string length&gt;</literal> is specified, only
    <literal>&lt;string length&gt; </literal>characters are returned.</para>

    <para>The binary version of SUBSTRING returns a binary string in the same
    manner. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TO_BASE64 function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TO_BASE64</emphasis></simpara>

    <para><literal>TO_BASE64( &lt;binary value expr&gt; )</literal></para>

    <para>Returns a character string as a base 64 representation of the bytes
    in the <literal>&lt;binary value expr&gt;</literal>. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRIM function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRIM</emphasis></simpara>

    <para><literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim
    character&gt; ] FROM ] &lt;char value expr&gt; )</literal></para>

    <para><literal>TRIM ([ [ LEADING | TRAILING | BOTH ] [ &lt;trim octet&gt;
    ] FROM ] &lt;binary value expr&gt; )</literal></para>

    <para>The character version of TRIM returns a character string based on
    <literal>&lt;char value expr&gt;</literal>. Consecutive instances of
    <literal>&lt;trim character&gt; </literal>are removed from the beginning,
    the end or both ends of the<literal>&lt;char value expr&gt;
    </literal>depending on the value of the optional first qualifier
    <literal>[ LEADING | TRAILING | BOTH ]</literal>. If no qualifier is
    specified, <literal>BOTH </literal>is used as default. If <literal>[
    &lt;trim character&gt; ]</literal> is not specified, the space character
    is used as default.</para>

    <para>The binary version of TRIM returns a binary string based on
    <literal>&lt;binary value expr&gt;</literal>. Consecutive instances of
    <literal>&lt;trim octet&gt; </literal>are removed in the same manner as in
    the character version. If<literal> [ &lt;trim octet&gt; ]</literal> is not
    specified, the 0 octet is used as default. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRANSLATE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRANSLATE</emphasis></simpara>

    <para><literal>TRANSLATE( &lt;char value expr1&gt;, &lt;char value
    expr2&gt;, &lt;char value expr3&gt; )</literal></para>

    <para>Returns a character string based on <literal>&lt;char value
    expr1&gt;</literal> source. Each character of the source is checked
    against the characters in <literal>&lt;char value expr2&gt;</literal>. If
    the character is not found, it is not modified. If the character is found,
    then the character in the same position in <literal>&lt;char value
    expr3&gt;</literal> is used. If <literal>&lt;char value
    expr2&gt;</literal> is longer than <literal>&lt;char value
    expr3&gt;</literal>, then those characters at the end that have no
    counterpart in <literal>&lt;char value expr3&gt;</literal> are dropped
    from the result. (HyperSQL)</para>

    <informalexample>
      <programlisting> -- in this example any accented character in acolumn is replaced with one without an accent
 TRANSLATE( acolumn, 'ÁÇÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕËÜáçéíóúàèìòùâêîôûãõëü', 'ACEIOUAEIOUAEIOUAOEUaceiouaeiouaeiouaoeu');
</programlisting>
    </informalexample>

    <indexterm significance="preferred" type="sql">
      <primary>UCASE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">UCASE</emphasis></simpara>

    <para><literal>UCASE ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string that is the upper case version of the
    <literal>&lt;char value expr&gt;</literal>. Equivalent to SQL/Foundation
    <literal>UPPER( &lt;char value expr&gt; )</literal> . (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>UPPER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">UPPER</emphasis></simpara>

    <para><literal>UPPER ( &lt;char value expr&gt; ) </literal></para>

    <para>Returns a character string that is the upper case version of the
    <literal>&lt;char value expr&gt;</literal> . (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>UNHEX function</primary>
    </indexterm>

    <simpara><emphasis role="bold">UNHEX</emphasis></simpara>

    <para><literal>UNHEX( &lt;char value expr&gt; )</literal></para>

    <para>Returns a binary string formed by translation of hexadecimal digits
    and letters in the &lt;<literal>char value expr&gt;</literal>. Exactly the
    same as the <literal>HEXTORAW</literal> function(HyperSQL)</para>
  </section>

  <section xml:id="bfc_numeric_functions">
    <title>Numeric Functions</title>

    <indexterm significance="preferred" type="sql">
      <primary>ABS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ABS</emphasis></simpara>

    <para><literal>ABS ( &lt;num value expr&gt; | &lt;interval value expr&gt;
    ) </literal></para>

    <para>Returns the absolute value of the argument as a value of the same
    type. (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ACOS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ACOS</emphasis></simpara>

    <para><literal>ACOS ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the arc-cosine of the argument in radians as a value of
    DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ASIN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ASIN</emphasis></simpara>

    <para><literal>ASIN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the arc-sine of the argument in radians as a value of DOUBLE
    type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ATAN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ATAN</emphasis></simpara>

    <para><literal>ATAN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the arc-tangent of the argument in radians as a value of
    DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ATAN2 function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ATAN2</emphasis></simpara>

    <para><literal>ATAN2 ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    ) </literal></para>

    <para>The <literal>&lt;num value expr 1&gt;</literal> and <literal>&lt;num
    value expr 2&gt;</literal> express the <varname>x</varname> and
    <varname>y</varname> coordinates of a point. Returns the angle, in
    radians, representing the angle coordinate of the point in polar
    coordinates, as a value of DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CEIL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CEILING</emphasis></simpara>

    <para><literal>{ CEIL | CEILING } ( &lt;num value expr&gt; )
    </literal></para>

    <para>Returns the smallest integer greater than or equal to the argument.
    If the argument is exact numeric then the result is exact numeric with a
    scale of 0. If the argument is approximate numeric, then the result is of
    DOUBLE type. (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>BITAND function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BITAND</emphasis></simpara>

    <para><literal>BITAND ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    )</literal></para>

    <para><literal>BITAND ( &lt;bit value expr 1&gt;, &lt;bit value expr 2&gt;
    )</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>BITANDNOT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BITANDNOT</emphasis></simpara>

    <para><literal>BITANDNOT ( &lt;num value expr 1&gt;, &lt;num value expr
    2&gt; )</literal></para>

    <para><literal>BITANDNOT ( &lt;bit value expr 1&gt;, &lt;bit value expr
    2&gt; )</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>BITNOT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BITNOT</emphasis></simpara>

    <para><literal>BITNOT ( &lt;num value expr 1&gt; )</literal></para>

    <para><literal>BITNOT ( &lt;bit value expr 1&gt; )</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>BITOR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BITOR</emphasis></simpara>

    <para><literal>BITOR ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    )</literal></para>

    <para><literal>BITOR ( &lt;bit value expr 1&gt;, &lt;bit value expr 2&gt;
    )</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>BITXOR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">BITXOR</emphasis></simpara>

    <para><literal>BITXOR ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    )</literal></para>

    <para><literal>BITXOR ( &lt;bit value expr 1&gt;, &lt;bit value expr 2&gt;
    )</literal></para>

    <para>These functions perform bit operations on two values, or in the case
    of BITNOT on a single value. The values are either integer values, or bit
    strings. The result is an integer value of the same type as the arguments,
    or a bit string of the same length as the argument. Each bit of the result
    is formed by performing the operation on corresponding bits of the
    arguments. The names of the function indicate NOT, OR, AND, XOR
    operations. The BITANDNOT performs NOT on the second argument, then
    performs AND on result and the first argument. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>COS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">COS</emphasis></simpara>

    <para><literal>COS ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the cosine of the argument (an angle expressed in radians)
    as a value of DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>COSH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">COSH</emphasis></simpara>

    <para><literal>COSH ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the hyperbolic cosine of the argument as a value of DOUBLE
    type. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>COT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">COT</emphasis></simpara>

    <para><literal>COT ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the cotangent of the argument as a value of DOUBLE type. The
    <literal>&lt;num value expr&gt;</literal> represents an angle expressed in
    radians. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DEGREES function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DEGREES</emphasis></simpara>

    <para><literal>DEGREES ( &lt;num value expr&gt; ) </literal></para>

    <para>Converts the argument (an angle expressed in<literal>
    radians</literal>) into degrees and returns the value in the DOUBLE type.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>EXP function</primary>
    </indexterm>

    <simpara><emphasis role="bold">EXP</emphasis></simpara>

    <para><literal>EXP ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the exponential value of the argument as a value of DOUBLE
    type. (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>FLOOR function</primary>
    </indexterm>

    <simpara><emphasis role="bold">FLOOR</emphasis></simpara>

    <para><literal>FLOOR ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the largest integer that is less than or equal to the
    argument. If the argument is exact numeric then the result is exact
    numeric with a scale of 0. If the argument is approximate numeric, then
    the result is of DOUBLE type. (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LN</emphasis></simpara>

    <para><literal>LN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the natural logarithm of the argument, as a value of DOUBLE
    type. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOG function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOG</emphasis></simpara>

    <para><literal>LOG ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the natural logarithm of the argument, as a value of DOUBLE
    type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOG10 function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOG10</emphasis></simpara>

    <para><literal>LOG10 ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the base 10 logarithm of the argument as a value of DOUBLE
    type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>MOD function</primary>
    </indexterm>

    <simpara><emphasis role="bold">MOD</emphasis></simpara>

    <para><literal>MOD ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt; )
    </literal></para>

    <para>Returns the remainder (modulus) of <literal>&lt;num value expr
    1&gt;</literal> divided by <literal>&lt;num value expr 2&gt;.</literal>
    The data type of the returned value is the same as the second argument.
    (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>NAVL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">NANVL</emphasis></simpara>

    <para><literal>NANVL ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    ) </literal></para>

    <para>Returns an alternative for the NaN (Not a Number) double value in
    <literal>&lt;num value expr 1&gt;</literal> as <literal>&lt;num value expr
    2&gt;.</literal>, otherwise returns the first argument. The data type of
    the returned value is DOUBLE. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>PI function</primary>
    </indexterm>

    <simpara><emphasis role="bold">PI</emphasis></simpara>

    <para><literal>PI () </literal></para>

    <para>Returns the constant pi as a value of DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>POWER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">POWER</emphasis></simpara>

    <para><literal>POWER ( &lt;num value expr 1&gt;, &lt;num value expr 2&gt;
    ) </literal></para>

    <para>Returns the value of <literal>&lt;num value expr 1&gt;</literal>
    raised to the power of <literal>&lt;int value expr 2&gt;</literal> as a
    value of DOUBLE type. (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RADIANS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RADIANS</emphasis></simpara>

    <para><literal>RADIANS ( &lt;num value expr&gt; ) </literal></para>

    <para>Converts the argument (an angle expressed in<literal>
    degrees</literal>) into radians and returns the value in the DOUBLE type.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>RAND function</primary>
    </indexterm>

    <simpara><emphasis role="bold">RAND</emphasis></simpara>

    <para><literal>RAND ( [ &lt;int value expr&gt; ] ) </literal></para>

    <para>Returns a random value in the DOUBLE type. The optional <literal>[
    &lt;int value expr&gt; ]</literal> is used as seed value. In HyperSQL each
    session has a separate random number generator. The first call that uses a
    seed parameter sets the seed for subsequent calls that do not include a
    parameter. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ROUND number function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ROUND</emphasis></simpara>

    <para><literal>ROUND ( &lt;num value expr&gt;, &lt;int value expr&gt; )
    </literal></para>

    <para>The <literal>&lt;num value expr&gt; </literal>is of the DOUBLE type
    or DECIMAL type. The function returns a DOUBLE or DECIMAL value which is
    the value of the argument rounded to <literal>&lt;int value
    expr&gt;</literal> places right of the decimal point. If <literal>&lt;int
    value expr&gt;</literal> is negative, the first argument is rounded to
    <literal>&lt;int value expr&gt;</literal> places to the left of the
    decimal point.</para>

    <para>This function rounds values ending with .5 or larger away from zero
    for DECIMAL arguments and results. When the value ends with .5 or larger
    and the argument and result are DOUBLE, It rounds the value towards the
    closest even value.</para>

    <para>The datetime version is discussed in the next section. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SIGN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SIGN</emphasis></simpara>

    <para><literal>SIGN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns an INTEGER, indicating the sign of the argument. If the
    argument is negative then -1 is returned. If it is equal to zero then 0 is
    returned. If the argument is positive then 1 is returned. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SIN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SIN</emphasis></simpara>

    <para><literal>SIN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the sine of the argument (an angle expressed in radians) as
    a value of DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SINH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SINH</emphasis></simpara>

    <para><literal>SINH ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the hyperbolic sine of the argument as a value of DOUBLE
    type. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SQRT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SQRT</emphasis></simpara>

    <para><literal>SQRT ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the square root of the argument as a value of DOUBLE type.
    (JDBC and Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TAN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TAN</emphasis></simpara>

    <para><literal>TAN ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the tangent of the argument (an angle expressed in radians)
    as a value of DOUBLE type. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TANH function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TANH</emphasis></simpara>

    <para><literal>TANH ( &lt;num value expr&gt; ) </literal></para>

    <para>Returns the hyperbolic tangent of the argument as a value of DOUBLE
    type. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TO_NUMBER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TO_NUMBER</emphasis></simpara>

    <para><literal>TO_NUMBER ( &lt;char value expr&gt; ) </literal></para>

    <para>Performs a cast from character to DECIMAL number. The character
    string must consist of digits and can have a decimal point. Use the SQL
    Standard CAST expression instead of this non-standard function.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRUNC function numeric</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRUNC</emphasis></simpara>

    <para><literal>TRUNC ( &lt;num value expr&gt; [, &lt;int value expr&gt;] )
    </literal></para>

    <para>This is a similar to the <literal>TRUNCATE</literal> function when
    the first argument is numeric. If the second argument is omitted, zero is
    used in its place.</para>

    <para>The datetime version is discussed in the next section.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRUNCATE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRUNCATE</emphasis></simpara>

    <para><literal>TRUNCATE ( &lt;num value expr&gt; [, &lt;int value
    expr&gt;] ) </literal></para>

    <para>Returns a value in the same type as <literal>&lt;num value
    expr&gt;</literal> but may reduce the scale of DECIMAL and NUMERIC values.
    The value is rounded by replacing digits with zeros from <literal>&lt;int
    value expr&gt;</literal> places right of the decimal point to the end. If
    <literal>&lt;int value expr&gt;</literal> is negative, <literal>ABS(
    &lt;int value expr&gt; )</literal> digits to left of the decimal point and
    all digits to the right of the decimal points are replaced with zeros.
    Results of calling TRUNCATE with 12345.6789 with (-2, 0, 2, 4) are (12300,
    12345, 12345.67, 12345.6789). The function does not change the number if
    the second argument is larger than or equal to the scale of the first
    argument.</para>

    <para>If the second argument is not a constant (when it is a parameter or
    column reference) then the type of the return value is always the same as
    the type of the first argument. In this case, the discarded digits are
    replaced with zeros. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>WIDTH_BUCKET function</primary>
    </indexterm>

    <simpara><emphasis role="bold">WIDTH_BUCKET</emphasis></simpara>

    <para><literal>WIDTH_BUCKET ( &lt;value expr 1&gt; , &lt;value expr 2&gt;,
    &lt;value expr 3&gt;, &lt;int value expr&gt; ) </literal></para>

    <para>Returns an integer value between 0 and <literal>&lt;int value
    expr&gt; + 1</literal>. The initial three parameters are of the same
    numeric or datetime type. The range, ( <literal>&lt;value expr 2&gt; ,
    &lt;value expr 3&gt;</literal> ) is divided into <literal>&lt;int value
    expr&gt;</literal> equal sections (buckets). The returned integer value
    indicates the index of the bucket where <literal>&lt;value expr
    1&gt;</literal> can be placed. If the <literal>&lt;value expr
    1&gt;</literal> falls before or after the range, the return value is 0 or
    <literal>&lt;value expr 1&gt; + 1</literal> respectively.</para>

    <para>This function can be used with numeric or datetime values. Invalid
    arguments, including <literal>&lt;int value expr&gt;</literal> smaller
    than 1, or equal values for <literal>&lt;value expr 2&gt;</literal> and
    <literal>&lt;value expr 3&gt;</literal> will cause an exception.
    (Foundation)</para>

    <para>An example is given below:</para>

    <informalexample>
      <programlisting> WIDTH_BUCKET( 5, 10, 110, 10)
 0

 WIDTH_BUCKET( 23, 10, 110, 10)
 2

 WIDTH_BUCKET( 100, 10, 110, 10)
 10

 WIDTH_BUCKET( 200, 10, 110, 10)
 11
</programlisting>
    </informalexample>
  </section>

  <section xml:id="bfc_datetime_functions">
    <title>Date Time and Interval Functions</title>

    <para>Functions to report the time zone.</para>

    <section xml:id="bfc_timezone_functions">
      <title>Functions to Report the Time Zone.</title>

      <indexterm significance="preferred" type="sql">
        <primary>TIMEZONE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TIMEZONE</emphasis></simpara>

      <para><literal>TIMEZONE()</literal></para>

      <para>Returns the current time zone for the session. Returns an INTERVAL
      HOUR TO MINUTE value. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SESSION_TIMEZONE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">SESSION_TIMEZONE</emphasis></simpara>

      <para><literal>SESSION_TIMEZONE()</literal></para>

      <para>Returns the default time zone for the current session. Returns an
      INTERVAL HOUR TO MINUTE value. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SESSIONTIMEZONE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">SESSIONTIMEZONE</emphasis></simpara>

      <para><literal>SESSIONTIMEZONE()</literal></para>

      <para>Same as SESSION_TIMEZONE. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DATABASE_TIMEZONE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATABASE_TIMEZONE</emphasis></simpara>

      <para><literal>DATABASE_TIMEZONE()</literal></para>

      <para>Returns the time zone for the database engine. This is based on
      where the database server process is located. Returns an INTERVAL HOUR
      TO MINUTE value. (HyperSQL)</para>

      <simpara><emphasis role="bold">DBTIMEZONE</emphasis></simpara>

      <para><literal>DBTIMEZONE()</literal></para>

      <para>Similar to DATABASE_TIMEZONE. Returns a string. Works in ORA
      compatibility mode only.(HyperSQL)</para>
    </section>

    <section xml:id="bfc_current_datetime">
      <title>Functions to Report the Current Datetime</title>

      <indexterm significance="preferred" type="sql">
        <primary>CURRENT_DATE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURRENT_DATE</emphasis></simpara>

      <para><literal>CURRENT_DATE</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>CURRENT_TIME function</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURRENT_TIME</emphasis></simpara>

      <para><literal>CURRENT_TIME [ ( &lt;time precision&gt; )
      ]</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>LOCALTIME function</primary>
      </indexterm>

      <simpara><emphasis role="bold">LOCALTIME</emphasis></simpara>

      <para><literal>LOCALTIME [ ( &lt;time precision&gt; ) ]</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>CURRENT_TIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURRENT_TIMESTAMP</emphasis></simpara>

      <para><literal>CURRENT_TIMESTAMP [ ( &lt;timestamp precision&gt; )
      ]</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>LOCALTIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">LOCALTIMESTAMP</emphasis></simpara>

      <para><literal>LOCALTIMESTAMP [ ( &lt;timestamp precision&gt; )
      ]</literal></para>

      <para>These datetime functions return the datetime value representing
      the moment the function is called. CURRENT_DATE returns a value of DATE
      type. CURRENT_TIME returns a value of TIME WITH TIME ZONE type.
      LOCALTIME returns a value of TIME type. CURRENT_TIMESTAMP returns a
      value of TIMESTAMP WITH TIME ZONE type. LOCALTIMESTAMP returns a value
      of TIMESTAMP type. If the optional <literal>[ ( &lt;time precision&gt; )
      ]</literal> or<literal> [ ( &lt;timestamp precision&gt; ) ]</literal> is
      used, then the returned value has the specified fraction of the second
      precision. (Foundation)</para>

      <indexterm significance="preferred" type="sql">
        <primary>NOW function</primary>
      </indexterm>

      <simpara><emphasis role="bold">NOW</emphasis></simpara>

      <para><literal>NOW ()</literal></para>

      <para>This function is equivalent to <literal>LOCALTIMESTAMP</literal>.
      It can be used as a no-arg function as the parens are optional.
      (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>CURDATE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURDATE</emphasis></simpara>

      <para><literal>CURDATE ()</literal></para>

      <para>This function is equivalent to<literal> CURRENT_DATE</literal>.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>CURTIME function</primary>
      </indexterm>

      <simpara><emphasis role="bold">CURTIME</emphasis></simpara>

      <para><literal>CURTIME ()</literal></para>

      <para>This function is equivalent to<literal> LOCALTIME</literal>.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SYSDATE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">SYSDATE</emphasis></simpara>

      <para><literal>SYSDATE</literal></para>

      <para>This function is similar to <literal>LOCALTIMESTAMP </literal>but
      it returns the timestamp when it is called. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SYSTIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">SYSTIMESTAMP</emphasis></simpara>

      <para><literal>SYSTIMESTAMP</literal></para>

      <para>This no-arg function is similar to
      <literal>CURRENT_TIMESTAMP</literal> and is enabled in ORA syntax mode
      only. It returns the timestamp when it is called. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>TODAY function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TODAY</emphasis></simpara>

      <para><literal>TODAY</literal></para>

      <para>This no-arg function is equivalent to<literal> CURRENT_DATE.
      </literal>(HyperSQL)</para>
    </section>

    <section xml:id="bfc_extract_datetime">
      <title>Functions to Extract an Element of a Datetime</title>

      <indexterm significance="preferred" type="sql">
        <primary>DATENAME, DATEPART and EOMONTH functions</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATENAME, DATEPART and
      EOMONTH</emphasis></simpara>

      <para>These functions are available in the MSS compatibility mode and
      perform the equivalent of EXTRACT function or the LAST_DAY function.
      (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DAYNAME function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DAYNAME</emphasis></simpara>

      <para><literal>DAYNAME ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_NAME FROM
      ... ) </literal>Returns a string in the range of Sunday - Saturday.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DAYOFMONTH function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DAYOFMONTH</emphasis></simpara>

      <para><literal>DAYOFMONTH ( &lt;datetime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( DAY_OF_MONTH
      FROM ... ) </literal>Returns an integer value in the range of 1-31.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DAYOFWEEK function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DAYOFWEEK</emphasis></simpara>

      <para><literal>DAYOFWEEK ( &lt;datetime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_WEEK FROM
      ... ) </literal>Returns an integer value in the range of 1-7. The first
      day of the week is Sunday. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DAYOFYEAR function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DAYOFYEAR</emphasis></simpara>

      <para><literal>DAYOFYEAR ( &lt;datetime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( DAY_OF_YEAR FROM
      ... ) </literal>Returns an integer value in the range of 1-366.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>DAYS function datetime</primary>
      </indexterm>

      <simpara><emphasis role="bold">DAYS</emphasis></simpara>

      <para><literal>DAYS ( &lt;datetime value expr&gt; ) </literal></para>

      <para>The <literal>&lt;datetime value expr&gt; </literal>is of DATE or
      TIMESTAMP type. This function returns the DAY number since the first day
      of the calendar. The first day is numbered 1. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>HOUR function</primary>
      </indexterm>

      <simpara><emphasis role="bold">HOUR</emphasis></simpara>

      <para><literal>HOUR ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( HOUR FROM ... )
      </literal>Returns an integer value in the range of 0-23. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>MINUTE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">MINUTE</emphasis></simpara>

      <para><literal>MINUTE ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( MINUTE FROM ...
      ) </literal>Returns an integer value in the range of 0 - 59.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>MONTH function</primary>
      </indexterm>

      <simpara><emphasis role="bold">MONTH</emphasis></simpara>

      <para><literal>MONTH ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( MONTH FROM ... )
      </literal>Returns an integer value in the range of 1-12. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>MONTHNAME function</primary>
      </indexterm>

      <simpara><emphasis role="bold">MONTHNAME</emphasis></simpara>

      <para><literal>MONTHNAME ( &lt;datetime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( NAME_OF_MONTH
      FROM ... ) </literal>Returns a string in the range of January -
      December. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>QUARTER function</primary>
      </indexterm>

      <simpara><emphasis role="bold">QUARTER</emphasis></simpara>

      <para><literal>QUARTER ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( QUARTER FROM ...
      ) </literal>Returns an integer in the range of 1 - 4. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SECOND function</primary>
      </indexterm>

      <simpara><emphasis role="bold">SECOND</emphasis></simpara>

      <para><literal>SECOND ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to <literal>EXTRACT ( SECOND FROM ...
      ) </literal>Returns an integer or decimal in the range of 0 - 59, with
      the same precision as the &lt;datetime value expr&gt;. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>SECONDS_SINCE_MIDNIGHT function</primary>
      </indexterm>

      <simpara><emphasis
      role="bold">SECONDS_SINCE_MIDNIGHT</emphasis></simpara>

      <para><literal>SECONDS_SINCE_MIDNIGHT ( &lt;datetime value expr&gt;
      )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT (
      SECONDS_SINCE_MIDNIGHT FROM ... ) </literal>Returns an integer in the
      range of 0 - 86399. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>UNIX_MILLIS function</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIX_MILLIS</emphasis></simpara>

      <para><literal>UNIX_MILLIS ( [ &lt;datetime value expression&gt; ] )
      </literal></para>

      <para>This function returns a BIGINT value. With no parameter, it
      returns the number of milliseconds since 1970-01-01. With a DATE or
      TIMESTAMP parameter, it converts the argument into number of
      milliseconds since 1970-01-01. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>UNIX_TIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">UNIX_TIMESTAMP</emphasis></simpara>

      <para><literal>UNIX_TIMESTAMP ( [ &lt;datetime value expression&gt; ] )
      </literal></para>

      <para>This function returns a BIGINT value. With no parameter, it
      returns the number of seconds since 1970-01-01. With a DATE or TIMESTAMP
      parameter, it converts the argument into number of seconds since
      1970-01-01. The TIMESTAMP ( &lt;num value expression&gt; function
      returns a TIMESTAMP from a Unix timestamp. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>WEEK function</primary>
      </indexterm>

      <simpara><emphasis role="bold">WEEK</emphasis></simpara>

      <para><literal>WEEK ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( WEEK_OF_YEAR
      FROM ... ) </literal>Returns an integer in the range of 1 - 54.
      (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>YEAR function</primary>
      </indexterm>

      <simpara><emphasis role="bold">YEAR</emphasis></simpara>

      <para><literal>YEAR ( &lt;datetime value expr&gt; )</literal></para>

      <para>This function is equivalent to<literal> EXTRACT ( YEAR FROM ... )
      </literal>Returns an integer in the range of 1 - 9999. (JDBC)</para>

      <indexterm significance="preferred" type="sql">
        <primary>EXTRACT function</primary>
      </indexterm>

      <simpara><emphasis role="bold">EXTRACT</emphasis></simpara>

      <para><literal>EXTRACT ( &lt;extract field&gt; FROM &lt;extract
      source&gt; )</literal></para>

      <para><literal>&lt;extract field&gt; ::= YEAR | MONTH | DAY | HOUR |
      MINUTE | DAY_OF_WEEK | WEEK_OF_YEAR | QUARTER | DAY_OF_YEAR |
      DAY_OF_MONTH |</literal></para>

      <para><literal>TIMEZONE_HOUR | TIMEZONE_MINUTE | SECOND |
      SECONDS_SINCE_MIDNIGHT |</literal></para>

      <para><literal>DAY_NAME | MONTH_NAME</literal></para>

      <para><literal>&lt;extract source&gt; ::= &lt;datetime value expr&gt; |
      &lt;interval value expr&gt;</literal></para>

      <para>The EXTRACT function returns a field or element of the
      <literal>&lt;extract source&gt;</literal>. The <literal>&lt;extract
      source&gt;</literal> is a datetime or interval expression. The type of
      the return value is BIGINT for most of the<literal> &lt;extract
      field&gt;</literal> options. The exceptions is <literal>SECOND
      </literal>where a DECIMAL value is returned which has the same precision
      as the datetime or interval expression. The field values
      <literal>DAY_NAME </literal>or<literal> MONTH_NAME </literal>result in a
      character string. When <literal>MONTH_NAME</literal> is specified, a
      string in the range January - December is returned. When
      <literal>DAY_NAME </literal>is specified, a string in the range Sunday
      -Saturday is returned.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      &lt;datetime value expr&gt;</literal>, different groups of
      <literal>&lt;extract source&gt;</literal> can be used depending on the
      data type of the expression. The <literal>TIMEZONE_HOUR |
      TIMEZONE_MINUTE</literal> options are valid only for TIME WITH TIMEZONE
      and TIMESTAMP WITH TIMEZONE data types. The <literal>HOUR | MINUTE |
      SECOND | SECONDS_MIDNIGHT</literal> options, are valid for TIME and
      TIMESTAMP types. The rest of the fields are valid for DATE and TIMESTAMP
      types.</para>

      <para>If the <literal>&lt;extract source&gt;</literal> is <literal>FROM
      &lt;interval value expr&gt;</literal>, the <literal>&lt;extract
      field&gt;</literal> must be one of the fields of the INTERVAL type of
      the expressions. The <literal>YEAR | MONTH</literal> options may be
      valid for INTERVAL types based on months. The <literal>DAY | HOUR |
      MINUTE | SECOND | SECONDS_MIDNIGHT</literal> options may be valid for
      INTERVAL types based on seconds. For example,<literal> DAY | HOUR |
      MINUTE</literal> are the only valid fields for the INTERVAL DAY TO
      MINUTE data type. (Foundation with HyperSQL extensions)</para>
    </section>

    <section xml:id="bfc_datetime_arithmetic">
      <title>Functions for Datetime Arithmetic</title>

      <indexterm significance="preferred" type="sql">
        <primary>NEXT_DAY function</primary>
      </indexterm>

      <simpara><emphasis role="bold">NEXT_DAY</emphasis></simpara>

      <para><literal>NEXT_DAY ( &lt;datetime value expr&gt;, &lt;character
      value expr&gt;)</literal></para>

      <para>This function returns a TIMESTAMP for compatibility reasons. The
      return value is the next weekday named by the second argument that
      occurs after the first date. For example next Wednesday is expressed as
      <literal>NEXT_DAY(CURRENT_DATE, 'WEDNESDAY')</literal>.
      (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>ADD_MONTHS function</primary>
      </indexterm>

      <simpara><emphasis role="bold">ADD_MONTHS</emphasis></simpara>

      <para><literal>ADD_MONTHS ( &lt;datetime value expr&gt;, &lt;numeric
      value expr&gt;)</literal></para>

      <para>This function is similar but different to simple addition a MONTH
      interval to a datetime value. The SQL Standard expression,
      <literal>&lt;datetime value expr&gt; + n MONTH</literal>, when used with
      the last day of a short month such as February, returns a date that has
      the same day of the month in the target month. The
      <literal>ADD_MONTHS</literal> function adjusts the target day to the
      last day of the target month. For all other days, the behaviour is the
      same. This function always returns a TIMESTAMP(0) value, regardless of
      the type of the argument. (HyperSQL)</para>

      <para>The example below compares the output of the function and the
      expression.</para>

      <para><informalexample>
          <programlisting> VALUES ADD_MONTHS ( DATE '2012-02-29' , 1), DATE '2012-02-29' + 1 MONTH

 C1                  C2         
 ------------------- ---------- 
 2012-03-31 00:00:00 2012-03-29 
</programlisting>
        </informalexample></para>

      <indexterm significance="preferred" type="sql">
        <primary>LAST_DAY function</primary>
      </indexterm>

      <simpara><emphasis role="bold">LAST_DAY</emphasis></simpara>

      <para><literal>LAST_DAY ( &lt;datetime value expr&gt; )</literal></para>

      <para>Returns the last day of the month for the given
      <literal>&lt;datetime value expr&gt;</literal>. The returned value
      preserves the year, month, hour, minute and second fields of the
      timestamp. The type of the result is always TIMESTAMP(0).
      (HyperSQL)</para>

      <para><informalexample>
          <programlisting> VALUES LAST_DAY ( TIMESTAMP '2012-02-14 12:30:44')

 C1                  
 ------------------- 
 2012-02-29 12:30:44 
</programlisting>
        </informalexample></para>

      <indexterm significance="preferred" type="sql">
        <primary>MONTHS_BETWEEN function</primary>
      </indexterm>

      <simpara><emphasis role="bold">MONTHS_BETWEEN</emphasis></simpara>

      <para><literal>MONTHS_BETWEEN ( &lt;datetime value expr1&gt; ,
      &lt;datetime value expr2&gt; )</literal></para>

      <para>Returns the a number (not an INTERVAL) possibly with a fraction,
      representing the number of months between two days. If both dates have
      the same day of month, or are on the last day of the month, the result
      is an exact numeric. Otherwise, the fraction is calculated base on 31
      days per month. You can cast the resulting value into INTERVAL MONTH and
      use it for datetime arithmetic. (HyperSQL)</para>

      <para><informalexample>
          <programlisting> VALUES MONTHS_BETWEEN ( TIMESTAMP '2013-02-14 12:30:44', TIMESTAMP '2012-01-04 12:30:44')

 C1                                  
 ----------------------------------- 
 13.32258064516129000000000000000000 
</programlisting>
        </informalexample></para>

      <indexterm significance="preferred" type="sql">
        <primary>TIMESTAMPADD function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TIMESTAMPADD</emphasis></simpara>

      <para><literal>TIMESTAMPADD ( &lt;tsi datetime field&gt;, &lt;numeric
      value expression&gt;, &lt;datetime value expr&gt;)</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>TIMESTAMPDIFF function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TIMESTAMPDIFF</emphasis></simpara>

      <para><literal>TIMESTAMPDIFF ( &lt;tsi datetime field&gt;, &lt;datetime
      value expr 1&gt;, &lt;datetime value expr 2&gt;)</literal></para>

      <para><literal>&lt;tsi datetime field&gt; ::= SQL_TSI_FRAC_SECOND |
      SQL_TSI_MILLI_SECOND | SQL_TSI_SECOND | SQL_TSI_MINUTE | SQL_TSI_HOUR |
      SQL_TSI_DAY | SQL_TSI_WEEK | SQL_TSI_MONTH | SQL_TSI_QUARTER |
      SQL_TSI_YEAR</literal></para>

      <para>HyperSQL supports full SQL Standard datetime features. It supports
      adding integers representing units of time directly to datetime values
      using the arithmetic plus operator. It also supports subtracting one
      <literal>&lt;datetime value expr&gt;</literal> from another in the given
      units of date or time using the minus operator. An example of
      <literal>&lt;datetime value expr&gt; + &lt;numeric value expression&gt;
      &lt;datetime field&gt; </literal>is <literal>LOCALTIMESTAMP + 5
      DAY</literal>. An example of <literal>( &lt;datetime value expr&gt; -
      &lt;numeric value expression&gt; ) &lt;datetime field&gt; </literal>is
      <literal>(CURRENT_DATE - DATE '2008-08-8') MONTH </literal>which returns
      the number of calendar months between the two dates.</para>

      <para>The two JDBC functions, <literal>TIMESTAMPADD </literal>and
      <literal>TIMESTAMPDIFF</literal> perform a similar function to the above
      SQL expressions. The &lt;tsi datetime field&gt; names are keywords and
      are different from those used in the EXTRACT functions. These names are
      valid for use only when calling these two functions. With TIMESTAMPDIFF,
      the names indicate the unit of time used to compute the difference
      between two datetime fields. With TIMESTAMPADD they represent the unit
      of time used for the &lt;numeric value expression&gt;. The unit of time
      for each name is self-explanatory. In the case of SQL_TSI_FRAC_SECOND,
      the unit is nanosecond.</para>

      <para>The return value for TIMESTAMPADD is of the same type as the
      datetime argument used. The return type for TIMESTAMPDIFF is always
      BIGINT, regardless of the type of arguments. The two datetime arguments
      of TIMESTAMPDIFF should be of the same type. The TIME type is not
      supported for the arguments to these functions.</para>

      <para><literal>TIMESTAMPDIFF</literal> is evaluated as &lt;datetime
      value expr 2&gt; - &lt;datetime value expr 1&gt;. (JDBC)</para>

      <informalexample>
        <programlisting> TIMESTAMPADD ( SQL_TSI_MONTH, 3, DATE '2008-11-22' )

 TIMESTAMPDIFF ( SQL_TSI_HOUR, TIMESTAMP '2008-11-20 20:30:40', TIMESTAMP '2008-11-21 21:30:40' )
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>DATE_ADD function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATE_ADD</emphasis></simpara>

      <para><literal>DATE_ADD ( &lt;datetime value expr&gt; , &lt;interval
      value expr&gt; )</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>DATE_SUB function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATE_SUB</emphasis></simpara>

      <para><literal>DATE_SUB ( &lt;datetime value expr&gt; , &lt;interval
      value expr&gt; )</literal></para>

      <para>These functions are equivalent to arithmetic addition and
      subtraction, &lt;datetime value expr&gt; + &lt;interval value expr&gt;
      and &lt;datetime value expr&gt; - &lt;interval value expr&gt;. The
      functions are provided for compatibility with other databases. The
      supported interval units are the standard SQL interval unit listed in
      other chapters of this guide. The TIME type is supported for the
      argument to these functions. (HyperSQL)</para>

      <informalexample>
        <programlisting> DATE_ADD ( DATE '2008-11-22', INTERVAL 3 MONTH )

 DATE_SUB ( TIMESTAMP '2008-11-22 20:30:40', INTERVAL 20 HOUR )
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>DATEADD function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATEADD</emphasis></simpara>

      <para><literal>DATEADD ( &lt;field&gt;, &lt;numeric value expr&gt;,
      &lt;datetime value expr&gt; )</literal></para>

      <indexterm significance="preferred" type="sql">
        <primary>DATEDIFF function</primary>
      </indexterm>

      <simpara><emphasis role="bold">DATEDIFF</emphasis></simpara>

      <para><literal>DATEDIFF ( &lt;field&gt;, &lt;datetime value expr 1&gt;,
      &lt;datetime value expr 2&gt; )</literal></para>

      <para><literal>&lt;field&gt; ::= 'yy' | 'year' | 'mm' | 'month' | 'dd' |
      'day' | 'hh' | 'hour' | 'mi' | 'minute' | 'ss' | 'second' | 'ms' |
      'millisecond'</literal></para>

      <para><literal>&lt;field&gt; ::= YY | YEAR | MM | MONTH | DD | DAY | HH
      | HOUR | MI | MINUTE | SS | SECOND | MS | MILLISECOND</literal></para>

      <para>The DATEADD and DATEDIFF functions are alternatives to
      TIMESTAMPADD and TIMESTAMPDIFF, with fewer available field options. The
      field names are specified as strings or as keywords. The short field
      names translate to YEAR, MONTH, DAY, HOUR, MINUTE, SECOND and
      MILLISECOND. <literal>DATEDIFF</literal> is evaluated as &lt;datetime
      value expr 2&gt; - &lt;datetime value expr 1&gt;. (HyperSQL}</para>

      <para><literal>DATEDIFF ( &lt;datetime value expr 1&gt;, &lt;datetime
      value expr 2&gt; )</literal></para>

      <para>This special form of <literal>DATEDIFF</literal> does not have a
      field parameter and return the number of days between two dates. This
      form is evaluated as <literal>&lt;datetime value expr 1&gt; -
      &lt;datetime value expr 2&gt;</literal>, which is different from the
      main form. This form is compatible with some other database engines. The
      TIME type is not supported for the arguments to these functions.
      (HyperSQL}</para>

      <informalexample>
        <programlisting> DATEADD ( 'month', 3, DATE '2008-11-22' )

 DATEDIFF ( 'hour', TIMESTAMP '2008-11-22 20:30:40', TIMESTAMP '2008-11-22 00:30:40' )
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>ROUND function datetime</primary>
      </indexterm>

      <simpara><emphasis role="bold">ROUND</emphasis></simpara>

      <para><literal>ROUND ( &lt;datetime value expr&gt; [ , &lt;char value
      expr&gt; ] ) </literal></para>

      <para>The <literal>&lt;datetime value expr&gt; </literal>is of DATE,
      TIME or TIMESTAMP type. The <literal>&lt;char value expr&gt;</literal>
      is a format string for YEAR, MONTH, WEEK OF YEAR, DAY, HOUR, MINUTE or
      SECOND as listed in the table for TO_CHAR and TO_DATE format elements
      (see below). The datetime value is rounded up or down after the
      specified field and the rest of the fields to the right are set to one
      for MONTH and DAY, or zero, for the rest of the fields. For example,
      rounding a timestamp value on the DAY field results in midnight the same
      date or midnight the next day if the time is at or after 12 noon. If the
      second argument is omitted, the datetime value is rounded to the nearest
      day. (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>TRUNC function datetime</primary>
      </indexterm>

      <simpara><emphasis role="bold">TRUNC</emphasis></simpara>

      <para><literal>TRUNC ( &lt;datetime value expr&gt; [ , &lt;char value
      expr&gt; ] ) </literal></para>

      <para>Similar to the ROUND function, the <literal>&lt;num value expr&gt;
      </literal>is of DATE, TIME or TIMESTAMP type. The <literal>&lt;char
      value expr&gt;</literal> is a format string (such as 'YY' or 'MM') for
      YEAR, MONTH, WEEK OF YEAR, DAY, HOUR, MINUTE or SECOND as listed in the
      table for TO_CHAR and TO_DATE format elements (see below). The datetime
      value is truncated after the specified field and the rest of the fields
      to the right are set to one for MONTH and DAY, or zero, for the rest of
      the fields. For example, applying TRUNC to a timestamp value on the DAY
      field results in midnight the same date. Examples of ROUND and TRUNC
      functions are given below. If the second argument is omitted, the
      datetime value is truncated to midnight the same date. (HyperSQL)</para>

      <informalexample>
        <programlisting> ROUND ( TIMESTAMP'2008-08-01 20:30:40', 'YYYY' )

 TIMESTAMP '2009-01-01 00:00:00'

 TRUNC ( TIMESTAMP'2008-08-01 20:30:40', 'YYYY' )

 TIMESTAMP '2008-01-01 00:00:00'
</programlisting>
      </informalexample>
    </section>

    <section xml:id="bfc_datetime_format">
      <title>Functions to Convert or Format a Datetime</title>

      <indexterm significance="preferred" type="sql">
        <primary>TIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TIMESTAMP</emphasis></simpara>

      <para>TIMESTAMP ( &lt;num value expr&gt; )</para>

      <para>TIMESTAMP ( &lt;char value expr&gt; )</para>

      <para><literal>TIMESTAMP ( &lt;char value expr&gt;, &lt;char value
      expr&gt; )</literal></para>

      <para><literal>TIMESTAMP ( &lt;date value expr&gt;, &lt;time value
      expr&gt; )</literal></para>

      <para>This function translates the arguments into a TIMESTAMP WIHOUT
      TIME ZONE value.</para>

      <para>When the single argument is a numeric value, it is interpreted as
      a Unix timestamp in seconds.</para>

      <para>When the single argument is a formatted date or timestamp string,
      it is translated to a TIMESTAMP.</para>

      <para>When two arguments are used, the first argument is the date part
      and the second argument is the time part of the returned TIMESTAMP
      value. An example, including the result, is given below:</para>

      <informalexample>
        <programlisting> TIMESTAMP ( '2008-11-22', '20:30:40' )

 TIMESTAMP '2008-11-22 20:30:40.000000'
</programlisting>
      </informalexample>

      <indexterm significance="preferred" type="sql">
        <primary>TIMESTAMP_WITH_ZONE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TIMESTAMP_WITH_ZONE</emphasis></simpara>

      <para>TIMESTAMP_WITH_ZONE ( &lt;num value expr&gt; )</para>

      <para>TIMESTAMP_WITH_ZONE ( &lt;char value expr&gt; )</para>

      <para>This function translates the arguments into a TIMESTAMP WITH TIME
      ZONE value.</para>

      <para>When the single argument is a numeric value, it is interpreted as
      a Unix timestamp in seconds.</para>

      <para>When the single argument is TIMESTAMP, it is converted to
      TIMESTAMP WITH TIME ZONE.</para>

      <para>The time zone of the returned value is the local time zone at the
      time of the timestamp argument. This accounts for daylight saving times.
      For example, if the local time zone was +4:00 at the time of the given
      Unix timestamp, the returned value is local timestamp at the time with
      time zone +4:00.</para>

      <indexterm significance="preferred" type="sql">
        <primary>TO_CHAR function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TO_CHAR</emphasis></simpara>

      <para><literal>TO_CHAR ( &lt;datetime value expr&gt;, &lt;char value
      expr&gt; )</literal></para>

      <para>This function formats a datetime or numeric value to the format
      given in the second argument. The format string can contain pattern
      elements from the list given below, plus punctuation and space
      characters. An example, including the result, is given below:</para>

      <informalexample>
        <programlisting> TO_CHAR ( TIMESTAMP'2008-02-01 20:30:40', 'YYYY BC MONTH, DAY HH' )

 2008 AD February, Friday 8

 TO_CHAR ( TIMESTAMP'2008-02-01 20:30:40', '"The Date is" YYYY BC MONTH, DAY HH' )

 The Date is 2008 AD February, Friday 8
</programlisting>
      </informalexample>

      <para>The format is internally translated to a
      <classname>java.text.SimpleDateFormat</classname> format string.
      Separator characters (space, comma, period, hyphen, colon, semicolon,
      forward slash) can be included between the pattern elements. Unsupported
      format strings should not be used. You can include a string literal
      inside the format string by enclosing it in double quotes (see the
      second example above). (HyperSQL)</para>

      <indexterm significance="preferred" type="sql">
        <primary>TO_DATE function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TO_DATE</emphasis></simpara>

      <para><literal>TO_DATE ( &lt;char value expr&gt;, &lt;char value
      expr&gt; )</literal></para>

      <para>This function translates a formatted datetime sting to a
      TIMESTAMP(0) according to the format given in the second argument. See
      TO_TIMESTAMP below for further details.</para>

      <indexterm significance="preferred" type="sql">
        <primary>TO_TIMESTAMP function</primary>
      </indexterm>

      <simpara><emphasis role="bold">TO_TIMESTAMP</emphasis></simpara>

      <para><literal>TO_TIMESTAMP ( &lt;char value expr&gt;, &lt;char value
      expr&gt; )</literal></para>

      <para>This function translates a formatted datetime sting to a
      TIMESTAMP(6) according to the format given in the second argument. The
      format string can contain pattern elements from the list given below,
      plus punctuation and space characters. The pattern should contain all
      the necessary fields to construct a date, including, year, month, day of
      month, etc. The returned timestamp can then be cast into DATE or TIME
      types if necessary. An example, including the result, is given
      below:</para>

      <informalexample>
        <programlisting> TO_TIMESTAMP ( '22/11/2008 20:30:40', 'DD/MM/YYYY HH:MI:SS' )

 TIMESTAMP '2008-11-22 20:30:40.000000'
</programlisting>
      </informalexample>

      <para>The format strings that can be used for TO_DATE and TO_TIMESTAMP
      are more restrictive than those used for TO_CHAR, because the format
      string must contain the elements needed to build a full DATE or
      TIMESTAMP value. For example, you cannot use the 'WW', 'W', 'HH' or
      'HH12' format elements with TO_DATE or TO_TIMESTAMP</para>

      <para>The format is internally translated to a
      <classname>java.text.SimpleDateFormat</classname> format string.
      Unsupported format strings should not be used. With TO_CHAR, you can
      include a string literal inside the format string by enclosing it in
      double quotes. (HyperSQL)</para>

      <para>The supported format components are all uppercase as
      follows:</para>

      <table colsep="1" frame="all" pgwide="0">
        <title>TO_CHAR, TO_DATE and TO_TIMESTAMP format elements</title>

        <tgroup cols="2">
          <colspec colwidth="5cm"/>

          <colspec/>

          <tbody>
            <row>
              <entry><literal>BC | B.C. | AD | A.D.</literal></entry>

              <entry>Returns <literal>AD</literal> for common era and
              <literal>BC</literal> for before common era</entry>
            </row>

            <row>
              <entry><literal>RRRR</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>YYYY</literal></entry>

              <entry><para>4-digit year</para></entry>
            </row>

            <row>
              <entry><literal>IYYY</literal></entry>

              <entry><para>4-digit year, corresponding to ISO week of the
              year. The reported year for the last few days of the calendar
              year may be the next year.</para></entry>
            </row>

            <row>
              <entry><literal>YY</literal></entry>

              <entry><para>2 digit year</para></entry>
            </row>

            <row>
              <entry><literal>IY</literal></entry>

              <entry><para>2 digit year, corresponding to ISO week of the year
              </para></entry>
            </row>

            <row>
              <entry><literal>MM</literal></entry>

              <entry><para>Month (01-12)</para></entry>
            </row>

            <row>
              <entry><literal>MON</literal></entry>

              <entry><para>Short three-letter name of month</para></entry>
            </row>

            <row>
              <entry><literal>MONTH</literal></entry>

              <entry><para>Name of month</para></entry>
            </row>

            <row>
              <entry><literal>WW</literal></entry>

              <entry><para>Week of year (1-53) where week 1 starts on the
              first day of the year and continues to the seventh day of the
              year (not a calendar week).</para></entry>
            </row>

            <row>
              <entry><literal>W</literal></entry>

              <entry><para>Week of month (1-5) where week 1 starts on the
              first day of the month and ends on the seventh (not a calendar
              week).</para></entry>
            </row>

            <row>
              <entry><literal>IW</literal></entry>

              <entry><para>Week of year (1-52 or 1-53) based on the ISO
              standard. Week starts on Monday. The first week may start near
              the end of previous year.</para></entry>
            </row>

            <row>
              <entry><literal>DAY</literal></entry>

              <entry><para>Name of day.</para></entry>
            </row>

            <row>
              <entry><literal>DD</literal></entry>

              <entry><para>Day of month (01-31).</para></entry>
            </row>

            <row>
              <entry><literal>DDD</literal></entry>

              <entry><para>Day of year (1-366).</para></entry>
            </row>

            <row>
              <entry><literal>DY</literal></entry>

              <entry><para>Short three-letter name of day.</para></entry>
            </row>

            <row>
              <entry><literal>HH</literal></entry>

              <entry><para>Hour of day (00-11).</para></entry>
            </row>

            <row>
              <entry><literal>HH12</literal></entry>

              <entry><para>Hour of day (00-11).</para></entry>
            </row>

            <row>
              <entry><literal>HH24</literal></entry>

              <entry><para>Hour of day (00-23).</para></entry>
            </row>

            <row>
              <entry><literal>MI</literal></entry>

              <entry><para>Minute (00-59).</para></entry>
            </row>

            <row>
              <entry><literal>SS</literal></entry>

              <entry><para>Second (00-59).</para></entry>
            </row>

            <row>
              <entry><literal>FF</literal></entry>

              <entry><para>Fractional seconds. Use without
              repetition.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section xml:id="bfc_array_functions">
    <title>Array Functions</title>

    <para>Array functions are specialised functions with ARRAY parameters or
    return values. For the ARRAY_AGG aggregate function, see the <link
    endterm="dataaccess-title" xlink:href="#dataaccess-chapt"/>
    chapter.</para>

    <indexterm significance="preferred" type="sql">
      <primary>CARDINALITY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CARDINALITY</emphasis></simpara>

    <para><literal>CARDINALITY( &lt;array value expr&gt; )</literal></para>

    <para>Returns the element count for the given array argument.
    (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>MAX_CARDINALITY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">MAX_CARDINALITY</emphasis></simpara>

    <para><literal>MAX_CARDINALITY( &lt;array value expr&gt;
    )</literal></para>

    <para>Returns the maximum allowed element count for the given array
    argument. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>POSITION_ARRAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">POSITION_ARRAY</emphasis></simpara>

    <para><literal>POSITION_ARRAY( &lt;value expression&gt; IN &lt;array value
    expr&gt; [ FROM &lt;int value expr&gt; ] )</literal></para>

    <para>Returns the position of the first match for the <literal>&lt;value
    expression&gt;</literal> in the array. By default the search starts from
    the beginning of the array. The optional <literal>&lt;int value
    expr&gt;</literal> specifies the start position. Positions are counted
    from 1. Returns zero if no match is found. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SORT_ARRAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SORT_ARRAY</emphasis></simpara>

    <para><literal>SORT_ARRAY( &lt;array value expr&gt; [ { ASC | DESC } ] [
    NULLS { FIRST | LAST } ] )</literal></para>

    <para>Returns a sorted copy of the array. By default, sort is performed in
    ascending order and NULL elements are sorted first. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRIM_ARRAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRIM_ARRAY</emphasis></simpara>

    <para><literal>TRIM_ARRAY( &lt;array value expr&gt;, &lt;num value
    expr&gt; )</literal></para>

    <para>Returns a new array that contains the elements of the
    <literal>&lt;array value expr&gt;</literal> minus the number of elements
    specified by the <literal>&lt;num value expr&gt;. </literal>Elements are
    discarded from the end of the array. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SEQUENCE_ARRAY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SEQUENCE_ARRAY</emphasis></simpara>

    <para><literal>SEQUENCE_ARRAY( &lt;value expr 1&gt;, &lt;value expr 2&gt;,
    &lt;value expr 3 )</literal></para>

    <para>Returns a new array that contains a sequence of values. The
    <literal>&lt;value expr 1&gt;</literal> is the lower bound of the range.
    The <literal>&lt;value expr 2&gt;</literal> is the upper bound of the
    range. The <literal>&lt;value expr 3&gt;</literal> is the increment. The
    elements of the array are within the inclusive range. The first element is
    <literal>&lt;value expr 1&gt;</literal> and each subsequent element is the
    sum of the previous element and the increment. If the increment is zero,
    only the first element is returned. When the increment is negative, the
    lower bound should be larger than the upper bound. The type of the
    arguments can be all number types, or a datetime range and an interval for
    the third argument (HyperSQL)</para>

    <para>In the examples below, a number sequence and a date sequence are
    shown. The UNNEST table expression is used to form a table from the
    array.</para>

    <informalexample>
      <programlisting> SEQUENCE_ARRAY(0, 100, 5)

 ARRAY[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100] 

 SELECT * FROM UNNEST(SEQUENCE_ARRAY(10, 12, 1))

 C1 
 -- 
 10 
 11 
 12 

 SELECT * FROM UNNEST(SEQUENCE_ARRAY(CURRENT_DATE, CURRENT_DATE + 6 DAY, 1 DAY)) WITH ORDINALITY AS T(D, I) 

 D          I 
 ---------- - 
 2010-08-01 1 
 2010-08-02 2 
 2010-08-03 3 
 2010-08-04 4 
 2010-08-05 5 
 2010-08-06 6 
 2010-08-07 7

</programlisting>
    </informalexample>
  </section>

  <section xml:id="bfc_general_functions">
    <title>General Functions</title>

    <para>General functions can take different types of arguments. Some
    General Functions accept a variable number of arguments.</para>

    <para>Also see the <link endterm="dataaccess-title" os=""
    xlink:href="#dataaccess-chapt"/> chapter for SQL expressions that are
    similar to functions, for example CAST and NULLIF.</para>

    <indexterm significance="preferred" type="sql">
      <primary>CASEWHEN function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CASEWHEN</emphasis></simpara>

    <para><literal>CASEWHEN( &lt;boolean value expr&gt;, &lt;value expr 2&gt;,
    &lt;value expr 3&gt; )</literal></para>

    <para>If the <literal>&lt;boolean value expr&gt;</literal> is true,
    returns <literal>&lt;value expr 2&gt;</literal> otherwise returns
    <literal>&lt;value expr 3&gt;. Use a CASE WHEN expression instead for more
    extensive capabilities and options.</literal> CASE WHEN is documented in
    the <link endterm="dataaccess-title" os=""
    xlink:href="#dataaccess-chapt"/> chapter. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>COALESCE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">COALESCE</emphasis></simpara>

    <para><literal>COALESCE( &lt;value expr 1&gt;, &lt;value expr 2&gt; [,
    ...] )</literal></para>

    <para>Returns <literal>&lt;value expr 1&gt;</literal> if it is not null,
    otherwise returns <literal>&lt;value expr 2&gt;</literal> if not null and
    so on. The type of both arguments must be comparable. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CONVERT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CONVERT</emphasis></simpara>

    <para><literal>CONVERT ( &lt;value expr&gt; , &lt;data type&gt;
    )</literal></para>

    <para><literal>&lt;data type&gt; ::= { SQL_BIGINT | SQL_BINARY | SQL_BIT
    |SQL_BLOB | SQL_BOOLEAN | SQL_CHAR | SQL_CLOB | SQL_DATE | SQL_DECIMAL |
    SQL_DATALINK |SQL_DOUBLE | SQL_FLOAT | SQL_INTEGER | SQL_LONGVARBINARY |
    SQL_LONGNVARCHAR | SQL_LONGVARCHAR | SQL_NCHAR | SQL_NCLOB | SQL_NUMERIC |
    SQL_NVARCHAR | SQL_REAL | SQL_ROWID | SQL_SQLXML | SQL_SMALLINT | SQL_TIME
    | SQL_TIMESTAMP | SQL_TINYINT | SQL_VARBINARY | SQL_VARCHAR} [ (
    &lt;precision, length or scale parameters&gt; ) ]</literal></para>

    <para>The CONVERT function is a JDBC escape function, equivalent to the
    SQL standard CAST expression. It converts the <literal>&lt;value
    expr&gt;</literal> into the given <literal>&lt;data type&gt;</literal> and
    returns the value. The <literal>&lt;data type&gt;</literal> options are
    synthetic names made by prefixing type names with <literal>SQL_</literal>.
    Some of the <literal>&lt;data type&gt;</literal> options represent valid
    SQL types, but some are based on non-standard type names, namely
    <literal>{ SQL_LONGNVARCHAR | SQL_LONGVARBINARY |SQL_LONGVARCHAR |
    SQL_TINYINT }</literal>. None of the synthetic names can be used in any
    other context than the CONVERT function.</para>

    <para>The definition of CONVERT in the JDBC Standard does not allow the
    precision, scale or length to be specified. This is required by the SQL
    standard for BINARY, BIT, BLOB, CHAR, CLOB, VARBINARY and VARCHAR types
    and is often needed for DECIMAL and NUMERIC. Defaults are used for
    precision.</para>

    <para>HyperSQL also allows the use of real type names (without the
    <literal>SQL_</literal> prefix). In this usage, HyperSQL allows the use of
    precision, scale or length for the type definition when they are valid for
    the type definition.</para>

    <para>When MS SQL Server compatibility mode is on, the parameters of
    CONVERT are switched and only the real type names with required precision,
    scale or length are allowed. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DECODE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DECODE</emphasis></simpara>

    <para><literal>DECODE( &lt;value expr main&gt;, &lt;value expr match
    1&gt;, &lt;value expr result 1&gt; [...,] [, &lt;value expr default&gt;]
    )</literal></para>

    <para>DECODE takes at least 3 arguments. The <literal>&lt;value expr
    main&gt;</literal> is compared with <literal>&lt;value expr match
    1&gt;</literal> and if it matches, <literal>&lt;value expr result
    1&gt;</literal> is returned. If there are additional pairs of
    <literal>&lt;value expr match n&gt;</literal> and <literal>&lt;value expr
    result n&gt;</literal>, comparison is repeated until a match is found the
    result is returned. If no match is found, the <literal>&lt;value expr
    default&gt;</literal> is returned if it is specified, otherwise NULL is
    returned. The type of the return value is a combination of the types of
    the <literal>&lt;value expr result ... &gt;</literal> arguments.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>GREATEST function</primary>
    </indexterm>

    <simpara><emphasis role="bold">GREATEST</emphasis></simpara>

    <para><literal>GREATEST( &lt;value expr 1&gt;, [&lt;value expr ...&gt;,
    ...] )</literal></para>

    <para>The GREATEST function takes one or more arguments. It compares the
    arguments with each other and returns the greatest argument. The return
    type is the combined type of the arguments. Arguments can be of any type,
    so long as they are comparable. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>IFNULL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">IFNULL</emphasis></simpara>

    <indexterm significance="preferred" type="sql">
      <primary>ISNULL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ISNULL</emphasis></simpara>

    <para><literal>IFNULL | ISNULL ( &lt;value expr 1&gt;, &lt;value expr
    2&gt; )</literal></para>

    <para>Returns <literal>&lt;value expr 1&gt;</literal> if it is not null,
    otherwise returns <literal>&lt;value expr 2&gt;</literal>. The type of the
    return value is the type of <literal>&lt;value expr 1&gt;</literal>.
    Almost equivalent to SQL Standard <literal>COALESCE(&lt;value expr 1&gt;,
    &lt;value expr 2&gt;)</literal> function, but without type modification.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LEAST function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LEAST</emphasis></simpara>

    <para><literal>LEAST( &lt;value expr 1&gt;, [&lt;value expr ...&gt;, ...]
    )</literal></para>

    <para>The LEAST function takes one or more arguments. It compares the
    arguments with each other and returns the smallest argument. The return
    type is the combined type of the arguments. Arguments can be of any type,
    so long as they are comparable. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOAD_FILE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOAD_FILE</emphasis></simpara>

    <para><literal>LOAD_FILE ( &lt;char value expr 1&gt; [, &lt;char value
    expr 2&gt;] )</literal></para>

    <para>Returns a BLOB or CLOB containing the URL or file path specified in
    the first argument. If used with a single argument, the function returns a
    BLOB. If used with two arguments, the function returns a CLOB and the
    second argument is the character encoding of the file.</para>

    <para>The file path is interpreted the same way as a TEXT TABLE source
    file location. The <literal>hsqldb.allow_full_path</literal> system
    property must be set <literal>true</literal> in order to access files
    outside the directory structure of the database files.</para>

    <para>(HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>NULLIF function</primary>
    </indexterm>

    <simpara><emphasis role="bold">NULLIF</emphasis></simpara>

    <para><literal>NULLIF( &lt;value expr 1&gt;, &lt;value expr 2&gt;
    )</literal></para>

    <para>Returns <literal>&lt;value expr 1&gt;</literal> if it is not equal
    to <literal>&lt;value expr 2&gt;</literal>, otherwise returns null. The
    type of both arguments must be the same. This function is a shorthand for
    a specific CASE expression. (Foundation)</para>

    <indexterm significance="preferred" type="sql">
      <primary>NVL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">NVL</emphasis></simpara>

    <para><literal>NVL( &lt;value expr 1&gt;, &lt;value expr 2&gt;
    )</literal></para>

    <para>Returns <literal>&lt;value expr 1&gt;</literal> if it is not null,
    otherwise returns <literal>&lt;value expr 2&gt;</literal>. The type of the
    return value is the type of <literal>&lt;value expr 1&gt;</literal>. For
    example, if <literal>&lt;value expr 1&gt;</literal> is an INTEGER column
    and <literal>&lt;value expr 2&gt;</literal> is a DOUBLE constant, the
    return type is cast into INTEGER. This function is similar to IFNULL.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>NVL2 function</primary>
    </indexterm>

    <simpara><emphasis role="bold">NVL2</emphasis></simpara>

    <para><literal>NVL2( &lt;value expr 1&gt;, &lt;value expr 2&gt;, &lt;value
    expr 3&gt; )</literal></para>

    <para>If <literal>&lt;value expr 1&gt;</literal> is not null, returns
    <literal>&lt;value expr 2&gt;</literal>, otherwise returns
    <literal>&lt;value expr 3&gt;</literal>. The type of the return value is
    the type of <literal>&lt;value expr 2&gt;</literal> unless it is null.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>UUID function</primary>
    </indexterm>

    <simpara><emphasis role="bold">UUID</emphasis></simpara>

    <para><literal>UUID ( [ { &lt;char value expr&gt; | &lt;binary value
    expr&gt; ] } ) </literal></para>

    <para>With no parameter, this function returns a new UUID value as a
    16-byte binary value in the UUID type. With a UUID hexadecimal string
    argument, it returns the 16-byte binary value in UUID. With a 16-byte
    binary or UUID argument, it returns the formatted UUID character
    representation. Note UUID is a type derived from BINARY(16) that in
    represented as a hexadecimal character string with the required hyphens.
    (HyperSQL)</para>

    <simpara><emphasis role="bold">NEWID</emphasis></simpara>

    <para><literal>NEWID () </literal></para>

    <para>ThIs is a synonyms for the no-arg UUID function in MSS compatibility
    mode. (HyperSQL)</para>

    <simpara><emphasis role="bold">SYS_GUID</emphasis></simpara>

    <para><literal>SYS_GUID () </literal></para>

    <para>Returns a UUID value as a 16 byte binary value in ORA compatibility
    mode. (HyperSQL)</para>
  </section>

  <section xml:id="bfc_system_functions">
    <title>System Functions</title>

    <indexterm significance="preferred" type="sql">
      <primary>CRYPT_KEY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CRYPT_KEY</emphasis></simpara>

    <para><literal>CRYPT_KEY( &lt;value expr 1&gt;, &lt;value expr 2&gt;
    )</literal></para>

    <para>Returns a binary string representation of a cryptography key for the
    given cipher and cryptography provider. The cipher specification is
    specified by <literal>&lt;value expr 1&gt;</literal> and the provider by
    <literal>&lt;value expr 2&gt;</literal>. To use the default provider,
    specify null for <literal>&lt;value expr 2&gt;</literal>.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DIAGNOSTICS function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DIAGNOSTICS</emphasis></simpara>

    <para><literal>DIAGNOSTICS ( ROW_COUNT )</literal></para>

    <para>This is a convenience function for use instead of the <literal>GET
    DIAGNOSTICS ...</literal> statement. The argument specifies the name of
    the diagnostics variable. Currently the only supported variable is the
    <literal>ROW_COUNT</literal> variable. The function returns the row count
    returned by the last executed statement. The return value is 0 after most
    statements. Calling this function immediately after executing an INSERT,
    UPDATE, DELETE or MERGE statement returns the row count for the last
    statement, as it is returned by the JDBC statement. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>IDENTITY function</primary>
    </indexterm>

    <simpara><emphasis role="bold">IDENTITY</emphasis></simpara>

    <para><literal>IDENTITY ()</literal></para>

    <para>Returns the last IDENTITY value inserted into a row by the current
    session. The statement, CALL IDENTITY() can be made after an INSERT
    statement that inserts a row into a table with an IDENTITY column. The
    CALL IDENTITY() statement returns the last IDENTITY value that was
    inserted into a table by the current session. Each session manages this
    function call separately and is not affected by inserts in other sessions.
    The statement can be executed as a direct statement or a prepared
    statement. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DATABASE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DATABASE</emphasis></simpara>

    <para><literal>DATABASE ()</literal></para>

    <para>Returns the file name (without directory information) of the
    database. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DATABASE_NAME function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DATABASE_NAME</emphasis></simpara>

    <para><literal>DATABASE_NAME ()</literal></para>

    <para>Returns the database name. This name is a 16-character, uppercase
    string. It is generated as a string based on the timestamp of the creation
    of the database, for example HSQLDB32438AEAFB. The name can be redefined
    by an admin user but the new name must be all uppercase and 16 characters
    long. This name is used in log messages with external logging frameworks.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DATABASE_VERSION function</primary>
    </indexterm>

    <simpara><emphasis role="bold">DATABASE_VERSION</emphasis></simpara>

    <para><literal>DATABASE_VERSION ()</literal></para>

    <para>Returns the full version string for the database engine. For
    example, 2.5.0. (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>USER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">USER</emphasis></simpara>

    <para><literal>USER ()</literal></para>

    <para>Equivalent to the SQL function <literal>CURRENT_USER</literal>.
    (JDBC)</para>

    <indexterm significance="preferred" type="sql">
      <primary>CURRENT_USER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CURRENT_USER</emphasis></simpara>

    <para><literal>CURRENT_USER</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>CURRENT_ROLE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CURRENT_ROLE</emphasis></simpara>

    <para><literal>CURRENT_ROLE</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>SESSION_USER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SESSION_USER</emphasis></simpara>

    <para><literal>SESSION_USER</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>SYSTEM_USER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SYSTEM_USER</emphasis></simpara>

    <para><literal>SYSTEM_USER</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>CURRENT_SCHEMA function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CURRENT_SCHEMA</emphasis></simpara>

    <para><literal>CURRENT_SCHEMA</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>CURRENT_CATALOG function</primary>
    </indexterm>

    <simpara><emphasis role="bold">CURRENT_CATALOG</emphasis></simpara>

    <para><literal>CURRENT_CATALOG</literal></para>

    <para>These functions return the named current session attribute. They are
    all SQL Standard functions.</para>

    <para>The CURRENT_USER is the user that connected to the database, or a
    user subsequently set by the SET AUTHORIZATION statement.</para>

    <para>SESSION_USER is the same as CURRENT_USER</para>

    <para>SYSTEM_USER is the user that connected to the database. It is not
    changed with any command until the session is closed.</para>

    <para>CURRENT_SCHEMA is default schema of the user, or a schema
    subsequently set by the SET SCHEMA command.</para>

    <para>CURRENT_CATALOG is always the same within a given HyperSQL database
    and indicates the name of the catalog.</para>

    <indexterm significance="preferred" type="sql">
      <primary>IS_AUTOCOMMIT function</primary>
    </indexterm>

    <simpara><emphasis role="bold">IS_AUTOCOMMIT</emphasis></simpara>

    <para><literal>IS_AUTOCOMMIT()</literal></para>

    <para>Returns TRUE if the session is in auto-commit mode.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>IS_READONLY_SESSION function</primary>
    </indexterm>

    <simpara><emphasis role="bold">IS_READONLY_SESSION</emphasis></simpara>

    <para><literal>IS_READONLY_SESSION()</literal></para>

    <para>Returns TRUE if the session is in read only mode. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>IS_READONLY_DATABASE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">IS_READONLY_DATABASE</emphasis></simpara>

    <para><literal>IS_READONLY_DATABASE()</literal></para>

    <para>Returns TRUE if the database is a read only database.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>IS_READONLY_DATABASE_FILES function</primary>
    </indexterm>

    <simpara><emphasis
    role="bold">IS_READONLY_DATABASE_FILES</emphasis></simpara>

    <para><literal>IS_READONLY_DATABASE_FILES()</literal></para>

    <para>Returns TRUE if the database is a read-only files database. In this
    kind of database, it is possible to modify the data, but the changes are
    not persisted to the database files. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ISOLATION_LEVEL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ISOLATION_LEVEL</emphasis></simpara>

    <para><literal>ISOLATION_LEVEL()</literal></para>

    <para>Returns the current transaction isolation level for the session.
    Returns either READ COMMITTED or SERIALIZABLE as a string.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SESSION_ID function</primary>
    </indexterm>

    <simpara><emphasis role="bold">SESSION_ID</emphasis></simpara>

    <para><literal>SESSION_ID()</literal></para>

    <para>Returns the id of the session as a BIGINT value. Each session id is
    unique during the operational lifetime of the database. Id's are restarted
    after a shutdown and restart. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>SESSION_ISOLATION_LEVEL function</primary>
    </indexterm>

    <simpara><emphasis
    role="bold">SESSION_ISOLATION_LEVEL</emphasis></simpara>

    <para><literal>SESSION_ISOLATION_LEVEL()</literal></para>

    <para>Returns the default transaction isolation level for the current
    session. Returns either READ COMMITTED or SERIALIZABLE as a string.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>DATABASE_ISOLATION_LEVEL function</primary>
    </indexterm>

    <simpara><emphasis
    role="bold">DATABASE_ISOLATION_LEVEL</emphasis></simpara>

    <para><literal>DATABASE_ISOLATION_LEVEL()</literal></para>

    <para>Returns the default transaction isolation level for the database.
    Returns either READ COMMITTED or SERIALIZABLE as a string.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRANSACTION_SIZE function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRANSACTION_SIZE</emphasis></simpara>

    <para><literal>TRANSACTION_SIZE()</literal></para>

    <para>Returns the row change count for the current transaction. Each row
    change represents a row INSERT or a row DELETE operation. There will be a
    pair of row change operations for each row that is updated.</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRANSACTION_ID function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRANSACTION_ID</emphasis></simpara>

    <para><literal>TRANSACTION_ID()</literal></para>

    <para>Returns the current transaction ID for the session as a BIGINT
    value. The database maintains a global incremental id which is allocated
    to new transactions and new actions (statement executions) in different
    sessions. This value is unique to the current transaction.
    (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ACTION_ID function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ACTION_ID</emphasis></simpara>

    <para><literal>ACTION_ID()</literal></para>

    <para>Returns the current action ID for the session as a BIGINT value. The
    database maintains a global incremental id which is allocated to new
    transactions and new actions (statement executions) in different sessions.
    This value is unique to the current action. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>TRANSACTION_CONTROL function</primary>
    </indexterm>

    <simpara><emphasis role="bold">TRANSACTION_CONTROL</emphasis></simpara>

    <para><literal>TRANSACTION_CONTROL()</literal></para>

    <para>Returns the current transaction model for the database. Returns
    LOCKS, MVLOCKS or MVCC as a string. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>LOB_ID function</primary>
    </indexterm>

    <simpara><emphasis role="bold">LOB_ID</emphasis></simpara>

    <para><literal>LOB_ID( &lt;column reference&gt; )</literal></para>

    <para>Returns internal ID of a lob as a BIGINT value. Lob ID's are unique
    and never reused. The &lt;column reference&gt; is the name of the column
    (or variable, or argument) which is a CLOB or BLOB. Returns null if the
    value is null. (HyperSQL)</para>

    <indexterm significance="preferred" type="sql">
      <primary>ROWNUM function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ROWNUM</emphasis></simpara>

    <para><literal>ROWNUM()</literal></para>

    <indexterm significance="preferred" type="sql">
      <primary>ROW_NUMBER function</primary>
    </indexterm>

    <simpara><emphasis role="bold">ROW_NUMBER</emphasis></simpara>

    <para><literal>ROW_NUMBER() OVER()</literal></para>

    <para>Returns the current row number (from 1) being processed in a select
    statement. This has the same semantics as the ROWNUM pseudo-column in ORA
    syntax mode, but can be used in any syntax mode. The function is used in a
    SELECT or DELETE statement. The ROWNUM of a row is incremented as the rows
    are added to the result set. It is therefore possible to use a condition
    such as WHERE ROWNUM() &lt; 10, but not ROWNUM() &gt; 10 or ROWNUM = 10.
    The <literal>ROW_NUMBER() OVER()</literal> alternative performs the same
    function and is included for compatibility with other database
    engines.(HyperSQL)</para>
  </section>
</chapter>
